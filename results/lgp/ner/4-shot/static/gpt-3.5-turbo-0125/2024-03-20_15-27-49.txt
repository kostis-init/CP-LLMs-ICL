Solution accuracy: 54.0%
Inverse Solution accuracy: 57.0%
Constraint accuracy: 67.76750330250991%
Model accuracy: 50.0%

Wrong solutions: 26, total: 100
Wrong inverse solutions: 43, total: 100
Wrong constraints: 85, total: 757
Wrong models: 48, total: 100
Errors: solution-level: 20, inverse solution-level: 0, constraint-level: 159, model-level: 2
---------------------------------------------------------------------------------------------

Clues:
The person who had the port paid 1 dollar more than Kurt.
Of the person who paid $25 and the person who paid $24, one was Priscilla and the other had the shiraz.
Of the person who paid $27 and Priscilla, one had the chianti and the other had the port.
Isabel paid $25.

Entities:
wines: chianti, port, riesling, shiraz
prices: $24, $25, $26, $27
names: Isabel, Kurt, Priscilla, Robin
PARAM (41-42): 1
PARAM (92-94): 25
PARAM (121-123): 24
PARAM (200-202): 27
PARAM (282-284): 25
OBJ_NAME (341-347): prices
PARAM (352-354): 24
PARAM (359-361): 25
PARAM (366-368): 26
PARAM (373-375): 27

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Isabel == 1, and Chianti == 1, and Price25 == 1, then Isabel paid $25 for Chianti.

### Decision variables:
-   Names of the wines: Chianti, Port, Riesling, Shiraz (all different, 1 to 4)
-   Prices paid: $24, $25, $26, $27 (all different, 1 to 4)
-   Names of the persons: Isabel, Kurt, Priscilla, Robin (all different, 1 to 4)

### Constraints:
-   The person who had the port paid 1 dollar more than Kurt:
    For this, we will need to add a constraint for each possible assignment of prices for the person who had the port and Kurt, such that the person who had the port paid 1 dollar more than Kurt. So, the constraints will be of the form:
    p1 == Port and p2 == Kurt => p1_to_int == p2_to_int + 1, for all p1, p2 in prices.

-   Of the person who paid $25 and the person who paid $24, one was Priscilla and the other had the Shiraz:
    This is a constraint that states that one person paid $25 and the other paid $24, and one of them is Priscilla and the other had Shiraz. So, we need to add constraints to represent this:
    (Price25 == Priscilla and Price24 == Shiraz) or (Price24 == Priscilla and Price25 == Shiraz).

-   Of the person who paid $27 and Priscilla, one had the Chianti and the other had the Port:
    This is a constraint that states that one person paid $27 and the other is Priscilla, and one of them had Chianti and the other had Port. So, we need to add constraints to represent this:
    (Price27 == Chianti and Priscilla == Port) or (Priscilla == Chianti and Price27 == Port).

-   Isabel paid $25:
    This is a direct assignment constraint:
    Isabel == Price25.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Isabel == 1, and Chianti == 1, and Price25 == 1, then Isabel paid $25 for Chianti.

### Decision variables:
-   Names of the wines: Chianti, Port, Riesling, Shiraz (all different, 1 to 4)
-   Prices paid: $24, $25, $26, $27 (all different, 1 to 4)
-   Names of the persons: Isabel, Kurt, Priscilla, Robin (all different, 1 to 4)

### Constraints:
-   The person who had the port paid 1 dollar more than Kurt:
    For this, we will need to add a constraint for each possible assignment of prices for the person who had the port and Kurt, such that the person who had the port paid 1 dollar more than Kurt. So, the constraints will be of the form:
    p1 == Port and p2 == Kurt => p1_to_int == p2_to_int + 1, for all p1, p2 in prices.

-   Of the person who paid $25 and the person who paid $24, one was Priscilla and the other had the Shiraz:
    This is a constraint that states that one person paid $25 and the other paid $24, and one of them is Priscilla and the other had Shiraz. So, we need to add constraints to represent this:
    (Price25 == Priscilla and Price24 == Shiraz) or (Price24 == Priscilla and Price25 == Shiraz).

-   Of the person who paid $27 and Priscilla, one had the Chianti and the other had the Port:
    This is a constraint that states that one person paid $27 and the other is Priscilla, and one of them had Chianti and the other had Port. So, we need to add constraints to represent this:
    (Price27 == Chianti and Priscilla == Port) or (Priscilla == Chianti and Price27 == Port).

-   Isabel paid $25:
    This is a direct assignment constraint:
    Isabel == Price25.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of wine, price, and name)
# e.g. if isabel == 1 and chianti == 1 and price25 == 1, then Isabel paid $25 for Chianti
isabel, kurt, priscilla, robin = names = intvar(1, 4, shape=4)
chianti, port, riesling, shiraz = wines = intvar(1, 4, shape=4)
price24, price25, price26, price27 = prices = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
name_to_int = None  # N/A
wine_to_int = None  # N/A
price_to_int = {price24: 24, price25: 25, price26: 26, price27: 27}  # in dollars


# Helper functions (for formulating comparison constraints)
def paid_more_than(var1, var2):
    """
    Formulate the constraint that var1 paid 1 dollar more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] + 1)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(names)
m += AllDifferent(wines)
m += AllDifferent(prices)

# Clue 1: The person who had the port paid 1 dollar more than Kurt:
m += paid_more_than(port, kurt)

# Clue 2: Of the person who paid $25 and the person who paid $24, one was Priscilla and the other had the Shiraz:
m += ((price25 == priscilla) & (price24 == shiraz)) | ((price24 == priscilla) & (price25 == shiraz))

# Clue 3: Of the person who paid $27 and Priscilla, one had the Chianti and the other had the Port:
m += ((price27 == chianti) & (priscilla == port)) | ((priscilla == chianti) & (price27 == port))

# Clue 4: Isabel paid $25:
m += isabel == price25

```
True
True
True
Wrong: 2, Total: 7
---------------------------------------------------------------------------------------------

Clues:
Celia used the gluten-free diet.
The friend who lost 3 pounds used the low-fat diet.
Mandy lost 2 fewer pounds than Raymond.
Mandy lost 4 more pounds than Tom.
The dieter who used the vegan diet is either Mandy or the friend who lost 3 pounds.

Entities:
pounds lost: 3, 5, 7, 9
diets: dairy-free, gluten-free, low-fat, vegan
names: Celia, Mandy, Raymond, Tom
VAR (48-54): friend
PARAM (64-65): 3
VAR (99-104): Mandy
PARAM (110-111): 2
VAR (130-137): Raymond
VAR (140-145): Mandy
PARAM (151-152): 4
VAR (221-226): Mandy
VAR (234-240): friend
PARAM (250-251): 3
PARAM (286-287): 3
PARAM (290-291): 5
PARAM (294-295): 7
PARAM (298-299): 9
VAR (373-378): Mandy
VAR (391-394): Tom

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Celia == 1, and DairyFree == 1, and 3 == 1, then Celia used the dairy-free diet and lost 3 pounds.

### Decision variables:
-   Names of the dieters: Celia, Mandy, Raymond, Tom (all different, 1 to 4)
-   Pounds lost: 3, 5, 7, 9 (all different, 1 to 4)
-   Types of diets: DairyFree, GlutenFree, LowFat, Vegan (all different, 1 to 4)

### Constraints:
-   Celia used the gluten-free diet:
    This is a direct assignment constraint:
    Celia == GlutenFree.

-   The friend who lost 3 pounds used the low-fat diet:
    This is a direct assignment constraint:
    Friend == LowFat.

-   Mandy lost 2 fewer pounds than Raymond:
    For this, we will need to add a constraint for each possible assignment of pounds lost for Mandy and Raymond, such that Mandy's pounds lost is 2 less than Raymond's pounds lost. So, the constraints will be of the form:
    p1 == Mandy and p2 == Raymond => p1_to_int == p2_to_int - 2, for all p1, p2 in pounds lost.

-   Mandy lost 4 more pounds than Tom:
    For this, we will need to add a constraint for each possible assignment of pounds lost for Mandy and Tom, such that Mandy's pounds lost is 4 more than Tom's pounds lost. So, the constraints will be of the form:
    p1 == Mandy and p2 == Tom => p1_to_int == p2_to_int + 4, for all p1, p2 in pounds lost.

-   The dieter who used the vegan diet is either Mandy or the friend who lost 3 pounds:
    This is a constraint that states that the dieter who used the vegan diet is either Mandy or the friend who lost 3 pounds, but not both. So:
    Xor([Mandy == Vegan, Friend == Vegan]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Celia == 1, and DairyFree == 1, and 3 == 1, then Celia used the dairy-free diet and lost 3 pounds.

### Decision variables:
-   Names of the dieters: Celia, Mandy, Raymond, Tom (all different, 1 to 4)
-   Pounds lost: 3, 5, 7, 9 (all different, 1 to 4)
-   Types of diets: DairyFree, GlutenFree, LowFat, Vegan (all different, 1 to 4)

### Constraints:
-   Celia used the gluten-free diet:
    This is a direct assignment constraint:
    Celia == GlutenFree.

-   The friend who lost 3 pounds used the low-fat diet:
    This is a direct assignment constraint:
    Friend == LowFat.

-   Mandy lost 2 fewer pounds than Raymond:
    For this, we will need to add a constraint for each possible assignment of pounds lost for Mandy and Raymond, such that Mandy's pounds lost is 2 less than Raymond's pounds lost. So, the constraints will be of the form:
    p1 == Mandy and p2 == Raymond => p1_to_int == p2_to_int - 2, for all p1, p2 in pounds lost.

-   Mandy lost 4 more pounds than Tom:
    For this, we will need to add a constraint for each possible assignment of pounds lost for Mandy and Tom, such that Mandy's pounds lost is 4 more than Tom's pounds lost. So, the constraints will be of the form:
    p1 == Mandy and p2 == Tom => p1_to_int == p2_to_int + 4, for all p1, p2 in pounds lost.

-   The dieter who used the vegan diet is either Mandy or the friend who lost 3 pounds:
    This is a constraint that states that the dieter who used the vegan diet is either Mandy or the friend who lost 3 pounds, but not both. So:
    Xor([Mandy == Vegan, Friend == Vegan]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of name, pounds lost, and diet)
# e.g. if celia == 1 and pounds3 == 1 and gluten_free == 1, then Celia lost 3 pounds using the gluten-free diet
celia, mandy, raymond, tom = names = intvar(1, 4, shape=4)
pounds3, pounds5, pounds7, pounds9 = pounds = intvar(1, 4, shape=4)
dairy_free, gluten_free, low_fat, vegan = diets = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
name_to_int = None  # N/A
pounds_to_int = {pounds3: 3, pounds5: 5, pounds7: 7, pounds9: 9}  # in pounds
diet_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def lost_fewer_pounds(var1, var2, diff):
    """
    Formulate the constraint that var1 lost fewer pounds than var2 by diff.
    """
    return [((p1 == var1) & (p2 == var2)).implies(pounds_to_int[p1] == pounds_to_int[p2] - diff)
            for p1 in pounds for p2 in pounds]


def lost_more_pounds(var1, var2, diff):
    """
    Formulate the constraint that var1 lost more pounds than var2 by diff.
    """
    return [((p1 == var1) & (p2 == var2)).implies(pounds_to_int[p1] == pounds_to_int[p2] + diff)
            for p1 in pounds for p2 in pounds]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(names)
m += AllDifferent(pounds)
m += AllDifferent(diets)

# Clue 1: Celia used the gluten-free diet:
m += celia == gluten_free

# Clue 2: The friend who lost 3 pounds used the low-fat diet:
m += friend == low_fat

# Clue 3: Mandy lost 2 fewer pounds than Raymond:
m += lost_fewer_pounds(mandy, raymond, 2)

# Clue 4: Mandy lost 4 more pounds than Tom:
m += lost_more_pounds(mandy, tom, 4)

# Clue 5: The dieter who used the vegan diet is either Mandy or the friend who lost 3 pounds:
m += Xor([mandy == vegan, friend == vegan])

```
Error: invalid syntax (<string>, line 1)
False
False
Error: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
The four people were Shari, the performer who went fourth, the person who used batons and the performer who went third.
Of the performer who used bowling pins and the juggler who went fourth, one is Melissa and the other is Yolanda.
The juggler who used bowling pins was either Yolanda or the juggler who went second.
Trevor performed 2 spots before the performer who used chainsaws.

Entities:
orders: first, second, third, fourth
names: Melissa, Shari, Trevor, Yolanda
items: batons, bowling pins, chainsaws, rings
VAR (60-66): fourth
VAR (123-128): third
VAR (195-201): fourth
VAR (323-329): second
VAR (427-433): second
VAR (436-441): third
PARAM (444-450): fourth

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Melissa == 1, and Fourth == 1, and BowlingPins == 1, then Melissa is the performer who went fourth and used bowling pins.

### Decision variables:
-   Orders of performance: First, Second, Third, Fourth (all different, 1 to 4)
-   Names of the performers: Melissa, Shari, Trevor, Yolanda (all different, 1 to 4)
-   Items used by the performers: Batons, BowlingPins, Chainsaws, Rings (all different, 1 to 4)

### Constraints:
-   The four people were Shari, the performer who went fourth, the person who used batons, and the performer who went third:
    This is a constraint that states that all these entities are different, thus:
    AllDifferent([Shari, Fourth, Batons, Third]).

-   Of the performer who used bowling pins and the juggler who went fourth, one is Melissa and the other is Yolanda:
    This is a constraint that states that one performer used bowling pins and went fourth, and the other is Melissa or Yolanda. So:
    (BowlingPins == Melissa and Fourth == Yolanda) or (BowlingPins == Yolanda and Fourth == Melissa).

-   The juggler who used bowling pins was either Yolanda or the juggler who went second:
    This is a constraint that states that the juggler who used bowling pins is either Yolanda or the juggler who went second. So:
    (BowlingPins == Yolanda) or (BowlingPins == Second).

-   Trevor performed 2 spots before the performer who used chainsaws:
    For this, we will need to add a constraint for each possible assignment of the orders for Trevor and the performer who used chainsaws, such that Trevor's order is 2 less than the performer who used chainsaws. So, the constraints will be of the form:
    o1 == Trevor and o2 == Chainsaws => o1_to_int == o2_to_int - 2, for all o1, o2 in orders.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Melissa == 1, and Fourth == 1, and BowlingPins == 1, then Melissa is the performer who went fourth and used bowling pins.

### Decision variables:
-   Orders of performance: First, Second, Third, Fourth (all different, 1 to 4)
-   Names of the performers: Melissa, Shari, Trevor, Yolanda (all different, 1 to 4)
-   Items used by the performers: Batons, BowlingPins, Chainsaws, Rings (all different, 1 to 4)

### Constraints:
-   The four people were Shari, the performer who went fourth, the person who used batons, and the performer who went third:
    This is a constraint that states that all these entities are different, thus:
    AllDifferent([Shari, Fourth, Batons, Third]).

-   Of the performer who used bowling pins and the juggler who went fourth, one is Melissa and the other is Yolanda:
    This is a constraint that states that one performer used bowling pins and went fourth, and the other is Melissa or Yolanda. So:
    (BowlingPins == Melissa and Fourth == Yolanda) or (BowlingPins == Yolanda and Fourth == Melissa).

-   The juggler who used bowling pins was either Yolanda or the juggler who went second:
    This is a constraint that states that the juggler who used bowling pins is either Yolanda or the juggler who went second. So:
    (BowlingPins == Yolanda) or (BowlingPins == Second).

-   Trevor performed 2 spots before the performer who used chainsaws:
    For this, we will need to add a constraint for each possible assignment of the orders for Trevor and the performer who used chainsaws, such that Trevor's order is 2 less than the performer who used chainsaws. So, the constraints will be of the form:
    o1 == Trevor and o2 == Chainsaws => o1_to_int == o2_to_int - 2, for all o1, o2 in orders.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of name, order, and item)
# e.g. if melissa == 1 and fourth == 1 and bowling_pins == 1, then Melissa went fourth and used bowling pins
melissa, shari, trevor, yolanda = names = intvar(1, 4, shape=4)
first, second, third, fourth = orders = intvar(1, 4, shape=4)
batons, bowling_pins, chainsaws, rings = items = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
name_to_int = None  # N/A
order_to_int = {first: 1, second: 2, third: 3, fourth: 4}  # in spots
item_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def performed_before_than(var1, var2, diff):
    """
    Formulate the constraint that var1 performed diff spots before var2.
    """
    return [((o1 == var1) & (o2 == var2)).implies(order_to_int[o1] == order_to_int[o2] - diff)
            for o1 in orders for o2 in orders]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(names)
m += AllDifferent(orders)
m += AllDifferent(items)

# Clue 1: The four people were Shari, the performer who went fourth, the person who used batons, and the performer who went third:
m += AllDifferent([shari, fourth, batons, third])

# Clue 2: Of the performer who used bowling pins and the juggler who went fourth, one is Melissa and the other is Yolanda:
m += ((bowling_pins == melissa) & (fourth == yolanda)) | ((bowling_pins == yolanda) & (fourth == melissa))

# Clue 3: The juggler who used bowling pins was either Yolanda or the juggler who went second:
m += (bowling_pins == yolanda) | (bowling_pins == second)

# Clue 4: Trevor performed 2 spots before the performer who used chainsaws:
m += performed_before_than(trevor, chainsaws, 2)

```
True
True
True
Wrong: 2, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The woman with 2 losses has 3 more wins than the boxer with 8 losses.
Edna Easton has 6 more wins than Irma.
Of the boxer with 33 wins and the fighter with 27 wins, one is Sonia and the other has 12 losses.
The boxer with 12 losses is either the fighter with 33 wins or Jane.

Entities:
wins: 24, 27, 30, 33
boxers: Edna Easton, Irma, Jane, Sonia
losses: 2, 4, 8, 12
VAR (12-17): woman
PARAM (23-24): 2
OBJ_NAME (25-31): losses
PARAM (36-37): 3
VAR (57-62): boxer
PARAM (68-69): 8
OBJ_NAME (70-76): losses
PARAM (95-96): 6
VAR (126-136): boxer with
PARAM (137-139): 33
VAR (153-165): fighter with
PARAM (166-168): 27
VAR (183-188): Sonia
PARAM (207-209): 12
OBJ_NAME (210-216): losses
VAR (223-233): boxer with
PARAM (234-236): 12
OBJ_NAME (237-243): losses
VAR (258-270): fighter with
PARAM (271-273): 33
PARAM (307-309): 24
PARAM (312-314): 27
PARAM (317-319): 30
PARAM (322-324): 33
VAR (362-367): Sonia
OBJ_NAME (368-374): losses
PARAM (377-378): 2
PARAM (381-382): 4
PARAM (385-386): 8
PARAM (389-391): 12

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if EdnaEaston == 1, and 24 == 1, and 2 == 1, then Edna Easton has 24 wins and 2 losses.

### Decision variables:
-   Names of the boxers: EdnaEaston, Irma, Jane, Sonia (all different, 1 to 4)
-   Number of wins: 24, 27, 30, 33 (all different, 1 to 4)
-   Number of losses: 2, 4, 8, 12 (all different, 1 to 4)

### Constraints:
-   The woman with 2 losses has 3 more wins than the boxer with 8 losses:
    For this, we will need to add a constraint for each possible assignment of wins and losses for the woman with 2 losses and the boxer with 8 losses, such that the woman's wins are 3 more than the boxer's wins. So, the constraints will be of the form:
    w1 == 2 and l1 == 8 => w1_to_int == l1_to_int + 3, for all w1, l1 in wins and losses.

-   Edna Easton has 6 more wins than Irma:
    For this, we will need to add a constraint for each possible assignment of wins for Edna Easton and Irma, such that Edna Easton's wins are 6 more than Irma's wins. So, the constraints will be of the form:
    w1 == EdnaEaston and w2 == Irma => w1_to_int == w2_to_int + 6, for all w1, w2 in wins.

-   Of the boxer with 33 wins and the fighter with 27 wins, one is Sonia and the other has 12 losses:
    This is a constraint that states that one of the boxers has 33 wins and the other has 27 wins, and one of them is Sonia and the other has 12 losses. So, the constraints will be:
    (boxer33 == Sonia and fighter27 == 12) or (boxer33 == 12 and fighter27 == Sonia).

-   The boxer with 12 losses is either the fighter with 33 wins or Jane:
    This is a constraint that states that the boxer with 12 losses is either the fighter with 33 wins or Jane, but not both. So:
    Xor([boxer12 == fighter33, boxer12 == Jane]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if EdnaEaston == 1, and 24 == 1, and 2 == 1, then Edna Easton has 24 wins and 2 losses.

### Decision variables:
-   Names of the boxers: EdnaEaston, Irma, Jane, Sonia (all different, 1 to 4)
-   Number of wins: 24, 27, 30, 33 (all different, 1 to 4)
-   Number of losses: 2, 4, 8, 12 (all different, 1 to 4)

### Constraints:
-   The woman with 2 losses has 3 more wins than the boxer with 8 losses:
    For this, we will need to add a constraint for each possible assignment of wins and losses for the woman with 2 losses and the boxer with 8 losses, such that the woman's wins are 3 more than the boxer's wins. So, the constraints will be of the form:
    w1 == 2 and l1 == 8 => w1_to_int == l1_to_int + 3, for all w1, l1 in wins and losses.

-   Edna Easton has 6 more wins than Irma:
    For this, we will need to add a constraint for each possible assignment of wins for Edna Easton and Irma, such that Edna Easton's wins are 6 more than Irma's wins. So, the constraints will be of the form:
    w1 == EdnaEaston and w2 == Irma => w1_to_int == w2_to_int + 6, for all w1, w2 in wins.

-   Of the boxer with 33 wins and the fighter with 27 wins, one is Sonia and the other has 12 losses:
    This is a constraint that states that one of the boxers has 33 wins and the other has 27 wins, and one of them is Sonia and the other has 12 losses. So, the constraints will be:
    (boxer33 == Sonia and fighter27 == 12) or (boxer33 == 12 and fighter27 == Sonia).

-   The boxer with 12 losses is either the fighter with 33 wins or Jane:
    This is a constraint that states that the boxer with 12 losses is either the fighter with 33 wins or Jane, but not both. So:
    Xor([boxer12 == fighter33, boxer12 == Jane]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of boxer, wins, and losses)
# e.g. if edna == 1 and wins24 == 1 and losses2 == 1, then Edna Easton has 24 wins and 2 losses
edna, irma, jane, sonia = boxers = intvar(1, 4, shape=4)
wins24, wins27, wins30, wins33 = wins = intvar(1, 4, shape=4)
losses2, losses4, losses8, losses12 = losses = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
boxer_to_int = None  # N/A
wins_to_int = {wins24: 24, wins27: 27, wins30: 30, wins33: 33}  # in wins
losses_to_int = {losses2: 2, losses4: 4, losses8: 8, losses12: 12}  # in losses


# Helper functions (for formulating comparison constraints)
def wins_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 has diff more wins than var2.
    """
    return [((w1 == var1) & (w2 == var2)).implies(wins_to_int[w1] == wins_to_int[w2] + diff)
            for w1 in wins for w2 in wins]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(boxers)
m += AllDifferent(wins)
m += AllDifferent(losses)

# Clue 1: The woman with 2 losses has 3 more wins than the boxer with 8 losses:
m += wins_more_than(wins24, losses8, 3)

# Clue 2: Edna Easton has 6 more wins than Irma:
m += wins_more_than(edna, irma, 6)

# Clue 3: Of the boxer with 33 wins and the fighter with 27 wins, one is Sonia and the other has 12 losses:
m += ((wins33 == sonia) & (wins27 == losses12)) | ((wins33 == losses12) & (wins27 == sonia))

# Clue 4: The boxer with 12 losses is either the fighter with 33 wins or Jane:
m += Xor([losses12 == wins33, losses12 == jane])

```
False
False
False
Wrong: 2, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The person who will publish in January is either the person who has been studying the Cheer culture or Ira.
The person who has been studying the Xozix culture will publish 1 month before the person who has been studying the Haleyito culture.
Of the student who will publish in March and the person who has been studying the Xozix culture, one is Luther and the other is Yvette.
Vera will publish 1 month before Luther.

Entities:
months: January, February, March, April
names: Ira, Luther, Vera, Yvette
cultures: Cheer, Garyk, Haleyito, Xozix
VAR (94-107): Cheer culture
VAR (154-167): Xozix culture
PARAM (181-182): 1
VAR (233-249): Haleyito culture
VAR (334-347): Xozix culture
VAR (551-559): Haleyito
VAR (562-567): Xozix

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ira == 1, and January == 1, and Cheer == 1, then Ira will publish in January and has been studying the Cheer culture.

### Decision variables:
-   Names of the individuals: Ira, Luther, Vera, Yvette (all different, 1 to 4)
-   Months of publication: January, February, March, April (all different, 1 to 4)
-   Cultures studied: Cheer, Garyk, Haleyito, Xozix (all different, 1 to 4)

### Constraints:
-   The person who will publish in January is either the person who has been studying the Cheer culture or Ira:
    This is a constraint that states that the person publishing in January is either studying the Cheer culture or is Ira, but not both. So:
    Xor([January == Cheer, January == Ira]).

-   The person who has been studying the Xozix culture will publish 1 month before the person who has been studying the Haleyito culture:
    For this, we will need to add a constraint for each possible assignment of the individuals studying the Xozix and Haleyito cultures, such that the Xozix individual's month of publication is 1 less than the Haleyito individual's month of publication. So, the constraints will be of the form:
    c1 == Xozix and c2 == Haleyito => c1_to_int == c2_to_int - 1, for all c1, c2 in months of publication.

-   Of the student who will publish in March and the person who has been studying the Xozix culture, one is Luther and the other is Yvette:
    This is a constraint that states that one of Luther or Yvette will publish in March and the other will be studying the Xozix culture. So:
    (March == Luther and Xozix == Yvette) or (March == Yvette and Xozix == Luther).

-   Vera will publish 1 month before Luther:
    For this, we will need to add a constraint for each possible assignment of the months of publication for Vera and Luther, such that Vera's month of publication is 1 less than Luther's month of publication. So, the constraints will be of the form:
    m1 == Vera and m2 == Luther => m1_to_int == m2_to_int - 1, for all m1, m2 in months of publication.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ira == 1, and January == 1, and Cheer == 1, then Ira will publish in January and has been studying the Cheer culture.

### Decision variables:
-   Names of the individuals: Ira, Luther, Vera, Yvette (all different, 1 to 4)
-   Months of publication: January, February, March, April (all different, 1 to 4)
-   Cultures studied: Cheer, Garyk, Haleyito, Xozix (all different, 1 to 4)

### Constraints:
-   The person who will publish in January is either the person who has been studying the Cheer culture or Ira:
    This is a constraint that states that the person publishing in January is either studying the Cheer culture or is Ira, but not both. So:
    Xor([January == Cheer, January == Ira]).

-   The person who has been studying the Xozix culture will publish 1 month before the person who has been studying the Haleyito culture:
    For this, we will need to add a constraint for each possible assignment of the individuals studying the Xozix and Haleyito cultures, such that the Xozix individual's month of publication is 1 less than the Haleyito individual's month of publication. So, the constraints will be of the form:
    c1 == Xozix and c2 == Haleyito => c1_to_int == c2_to_int - 1, for all c1, c2 in months of publication.

-   Of the student who will publish in March and the person who has been studying the Xozix culture, one is Luther and the other is Yvette:
    This is a constraint that states that one of Luther or Yvette will publish in March and the other will be studying the Xozix culture. So:
    (March == Luther and Xozix == Yvette) or (March == Yvette and Xozix == Luther).

-   Vera will publish 1 month before Luther:
    For this, we will need to add a constraint for each possible assignment of the months of publication for Vera and Luther, such that Vera's month of publication is 1 less than Luther's month of publication. So, the constraints will be of the form:
    m1 == Vera and m2 == Luther => m1_to_int == m2_to_int - 1, for all m1, m2 in months of publication.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of name, month, and culture)
# e.g. if ira == 1 and january == 1 and cheer == 1, then Ira will publish in January and has been studying the Cheer culture
ira, luther, vera, yvette = names = intvar(1, 4, shape=4)
january, february, march, april = months = intvar(1, 4, shape=4)
cheer, garyk, haleyito, xozix = cultures = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
name_to_int = None  # N/A
month_to_int = {january: 1, february: 2, march: 3, april: 4}  # in months
culture_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def published_before_than(var1, var2):
    """
    Formulate the constraint that var1 published before var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] < month_to_int[m2])
            for m1 in months for m2 in months]


def published_exactly_before_than(var1, var2, diff):
    """
    Formulate the constraint that var1 published exactly diff months before var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] == month_to_int[m2] - diff)
            for m1 in months for m2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(names)
m += AllDifferent(months)
m += AllDifferent(cultures)

# Clue 1: The person who will publish in January is either the person who has been studying the Cheer culture or Ira:
m += Xor([january == cheer, january == ira])

# Clue 2: The person who has been studying the Xozix culture will publish 1 month before the person who has been studying the Haleyito culture:
m += published_exactly_before_than(xozix, haleyito, 1)

# Clue 3: Of the student who will publish in March and the person who has been studying the Xozix culture, one is Luther and the other is Yvette:
m += ((march == luther) & (xozix == yvette)) | ((march == yvette) & (xozix == luther))

# Clue 4: Vera will publish 1 month before Luther:
m += published_exactly_before_than(vera, luther, 1)

```
True
True
True
Wrong: 1, Total: 7
---------------------------------------------------------------------------------------------

Clues:
Francis will depart from Manson.
The conductor working on June 12 is either the conductor departing from Buttonwillow or Greg.
Ira will leave 1 day before the conductor departing from Manson.
The person departing from Buttonwillow will leave 1 day before the conductor departing from Indio.

Entities:
days: June 10, June 11, June 12, June 13
names: Francis, Greg, Ira, Oscar
departures: Buttonwillow, Coulterville, Indio, Manson
VAR (33-39): Manson
LIMIT (72-74): 12
VAR (114-126): Buttonwillow
PARAM (152-153): 1
VAR (194-200): Manson
VAR (229-241): Buttonwillow
PARAM (253-254): 1
VAR (295-300): Indio
PARAM (326-328): 10
PARAM (336-338): 11
PARAM (346-348): 12
LIMIT (356-358): 13
VAR (409-421): Buttonwillow
VAR (439-444): Indio
VAR (447-453): Manson

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Francis == 1, and June12 == 1, and Buttonwillow == 1, then Francis will depart from Buttonwillow on June 12.

### Decision variables:
-   Names of the individuals: Francis, Greg, Ira, Oscar (all different, 1 to 4)
-   Dates of departure: June10, June11, June12, June13 (all different, 1 to 4)
-   Locations of departure: Buttonwillow, Coulterville, Indio, Manson (all different, 1 to 4)

### Constraints:
-   Francis will depart from Manson:
    This is a direct assignment constraint:
    Francis == Manson.

-   The conductor working on June 12 is either the conductor departing from Buttonwillow or Greg:
    This is a constraint that states that the conductor working on June 12 is either from Buttonwillow or is Greg, but not both. So:
    Xor([June12 == Buttonwillow, June12 == Greg]).

-   Ira will leave 1 day before the conductor departing from Manson:
    For this, we will need to add a constraint for each possible assignment of the dates for Ira and the conductor departing from Manson, such that Ira's departure date is 1 less than the conductor's departure date from Manson. So, the constraints will be of the form:
    d1 == Ira and d2 == Manson => d1_to_int == d2_to_int - 1, for all d1, d2 in dates.

-   The person departing from Buttonwillow will leave 1 day before the conductor departing from Indio:
    For this, we will need to add a constraint for each possible assignment of the dates for the person departing from Buttonwillow and the conductor departing from Indio, such that the person from Buttonwillow's departure date is 1 less than the conductor's departure date from Indio. So, the constraints will be of the form:
    d1 == Buttonwillow and d2 == Indio => d1_to_int == d2_to_int - 1, for all d1, d2 in dates.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Francis == 1, and June12 == 1, and Buttonwillow == 1, then Francis will depart from Buttonwillow on June 12.

### Decision variables:
-   Names of the individuals: Francis, Greg, Ira, Oscar (all different, 1 to 4)
-   Dates of departure: June10, June11, June12, June13 (all different, 1 to 4)
-   Locations of departure: Buttonwillow, Coulterville, Indio, Manson (all different, 1 to 4)

### Constraints:
-   Francis will depart from Manson:
    This is a direct assignment constraint:
    Francis == Manson.

-   The conductor working on June 12 is either the conductor departing from Buttonwillow or Greg:
    This is a constraint that states that the conductor working on June 12 is either from Buttonwillow or is Greg, but not both. So:
    Xor([June12 == Buttonwillow, June12 == Greg]).

-   Ira will leave 1 day before the conductor departing from Manson:
    For this, we will need to add a constraint for each possible assignment of the dates for Ira and the conductor departing from Manson, such that Ira's departure date is 1 less than the conductor's departure date from Manson. So, the constraints will be of the form:
    d1 == Ira and d2 == Manson => d1_to_int == d2_to_int - 1, for all d1, d2 in dates.

-   The person departing from Buttonwillow will leave 1 day before the conductor departing from Indio:
    For this, we will need to add a constraint for each possible assignment of the dates for the person departing from Buttonwillow and the conductor departing from Indio, such that the person from Buttonwillow's departure date is 1 less than the conductor's departure date from Indio. So, the constraints will be of the form:
    d1 == Buttonwillow and d2 == Indio => d1_to_int == d2_to_int - 1, for all d1, d2 in dates.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of name, date, and departure location)
# e.g. if francis == 1 and june12 == 1 and buttonwillow == 1, then Francis will depart from Buttonwillow on June 12
francis, greg, ira, oscar = names = intvar(1, 4, shape=4)
june10, june11, june12, june13 = dates = intvar(1, 4, shape=4)
buttonwillow, coulterville, indio, manson = departures = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
name_to_int = None  # N/A
date_to_int = {june10: 10, june11: 11, june12: 12, june13: 13}  # in days
departure_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def leaves_before_than(var1, var2):
    """
    Formulate the constraint that var1 leaves before var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(date_to_int[d1] < date_to_int[d2])
            for d1 in dates for d2 in dates]


def leaves_exactly_before_than(var1, var2, diff):
    """
    Formulate the constraint that var1 leaves exactly diff days before var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(date_to_int[d1] == date_to_int[d2] - diff)
            for d1 in dates for d2 in dates]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(names)
m += AllDifferent(dates)
m += AllDifferent(departures)

# Clue 1: Francis will depart from Manson:
m += francis == manson

# Clue 2: The conductor working on June 12 is either the conductor departing from Buttonwillow or Greg:
m += Xor([june12 == buttonwillow, june12 == greg])

# Clue 3: Ira will leave 1 day before the conductor departing from Manson:
m += leaves_exactly_before_than(ira, manson, 1)

# Clue 4: The person departing from Buttonwillow will leave 1 day before the conductor departing from Indio:
m += leaves_exactly_before_than(buttonwillow, indio, 1)

```
True
True
True
Wrong: 0, Total: 7
---------------------------------------------------------------------------------------------

Clues:
Vicky Estes used the catamaran.
Debra Decker took 4 fewer days to finish than the sailor in the trimaran.
Wendell Orr finished in 278 days.
The competitor in the schooner took 4 more days to finish than Vicky Estes.

Entities:
days: 270, 274, 278, 282
boat types: catamaran, ketch, schooner, trimaran
sailors: Debra Decker, Gil Baxter, Vicky Estes, Wendell Orr
VAR (8-19): Vicky Estes
VAR (41-53): Debra Decker
PARAM (59-60): 4
VAR (105-113): trimaran
VAR (116-127): Wendell Orr
PARAM (140-143): 278
VAR (173-181): schooner
PARAM (187-188): 4
VAR (214-225): Vicky Estes
LIMIT (246-249): 270
LIMIT (252-255): 274
LIMIT (258-261): 278
LIMIT (264-267): 282
VAR (312-320): trimaran
VAR (331-343): Debra Decker
VAR (359-370): Vicky Estes
VAR (373-384): Wendell Orr

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if VickyEstes == 1, and Catamaran == 1, and 270 == 1, then Vicky Estes used the catamaran and finished in 270 days.

### Decision variables:
-   Names of the sailors: DebraDecker, GilBaxter, VickyEstes, WendellOrr (all different, 1 to 4)
-   Boat types: Catamaran, Ketch, Schooner, Trimaran (all different, 1 to 4)
-   Number of days taken to finish: 270, 274, 278, 282 (all different, 1 to 4)

### Constraints:
-   Vicky Estes used the catamaran:
    This is a direct assignment constraint:
    VickyEstes == Catamaran.

-   Debra Decker took 4 fewer days to finish than the sailor in the trimaran:
    For this, we will need to add a constraint for each possible assignment of the number of days taken to finish by Debra Decker and the sailor in the trimaran, such that Debra Decker took 4 fewer days. So, the constraints will be of the form:
    d1 == DebraDecker and d2 == Trimaran => d1_to_int == d2_to_int - 4, for all d1, d2 in days.

-   Wendell Orr finished in 278 days:
    This is a direct assignment constraint:
    WendellOrr == 278.

-   The competitor in the schooner took 4 more days to finish than Vicky Estes:
    For this, we will need to add a constraint for each possible assignment of the number of days taken to finish by the competitor in the schooner and Vicky Estes, such that the competitor in the schooner took 4 more days. So, the constraints will be of the form:
    d1 == Schooner and d2 == VickyEstes => d1_to_int == d2_to_int + 4, for all d1, d2 in days.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if VickyEstes == 1, and Catamaran == 1, and 270 == 1, then Vicky Estes used the catamaran and finished in 270 days.

### Decision variables:
-   Names of the sailors: DebraDecker, GilBaxter, VickyEstes, WendellOrr (all different, 1 to 4)
-   Boat types: Catamaran, Ketch, Schooner, Trimaran (all different, 1 to 4)
-   Number of days taken to finish: 270, 274, 278, 282 (all different, 1 to 4)

### Constraints:
-   Vicky Estes used the catamaran:
    This is a direct assignment constraint:
    VickyEstes == Catamaran.

-   Debra Decker took 4 fewer days to finish than the sailor in the trimaran:
    For this, we will need to add a constraint for each possible assignment of the number of days taken to finish by Debra Decker and the sailor in the trimaran, such that Debra Decker took 4 fewer days. So, the constraints will be of the form:
    d1 == DebraDecker and d2 == Trimaran => d1_to_int == d2_to_int - 4, for all d1, d2 in days.

-   Wendell Orr finished in 278 days:
    This is a direct assignment constraint:
    WendellOrr == 278.

-   The competitor in the schooner took 4 more days to finish than Vicky Estes:
    For this, we will need to add a constraint for each possible assignment of the number of days taken to finish by the competitor in the schooner and Vicky Estes, such that the competitor in the schooner took 4 more days. So, the constraints will be of the form:
    d1 == Schooner and d2 == VickyEstes => d1_to_int == d2_to_int + 4, for all d1, d2 in days.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of sailor, boat type, and number of days)
# e.g. if vicky == 1 and catamaran == 1 and days270 == 1, then Vicky Estes used the catamaran and finished in 270 days
vicky, debra, gil, wendell = sailors = intvar(1, 4, shape=4)
catamaran, ketch, schooner, trimaran = boats = intvar(1, 4, shape=4)
days270, days274, days278, days282 = days = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
sailor_to_int = None  # N/A
boat_to_int = None  # N/A
days_to_int = {days270: 270, days274: 274, days278: 278, days282: 282}  # in days


# Helper functions (for formulating comparison constraints)
def finished_fewer_days_than(var1, var2, diff):
    """
    Formulate the constraint that var1 finished diff days fewer than var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(days_to_int[d1] == days_to_int[d2] - diff)
            for d1 in days for d2 in days]


def finished_more_days_than(var1, var2, diff):
    """
    Formulate the constraint that var1 finished diff days more than var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(days_to_int[d1] == days_to_int[d2] + diff)
            for d1 in days for d2 in days]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(sailors)
m += AllDifferent(boats)
m += AllDifferent(days)

# Clue 1: Vicky Estes used the catamaran:
m += vicky == catamaran

# Clue 2: Debra Decker took 4 fewer days to finish than the sailor in the trimaran:
m += finished_fewer_days_than(debra, trimaran, 4)

# Clue 3: Wendell Orr finished in 278 days:
m += wendell == days278

# Clue 4: The competitor in the schooner took 4 more days to finish than Vicky Estes:
m += finished_more_days_than(schooner, vicky, 4

```
Error: invalid syntax (<string>, line 1)
False
False
Error: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
Jorge is either the skydiver who wears the red suit or the jumper who started in 1982.
The skydiver who wears the pink suit started skydiving 1 year before Otis.
The jumper who wears the yellow suit started skydiving sometime after Philip.
The jumper who wears the lime green suit started skydiving sometime after the jumper who wears the yellow suit.
The jumper who wears the pink suit started skydiving 2 years before Shaun.

Entities:
names: Jorge, Otis, Philip, Shaun
years: 1982, 1983, 1984, 1985
suit colors: lime green, pink, red, yellow
VAR (51-59): red suit
VAR (123-132): pink suit
PARAM (151-152): 1
VAR (197-208): yellow suit
VAR (276-291): lime green suit
VAR (350-361): yellow suit
VAR (389-398): pink suit
PARAM (417-418): 2
PARAM (497-501): 1982
PARAM (504-508): 1983
PARAM (511-515): 1984
PARAM (518-522): 1985

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Jorge == 1, and RedSuit == 1, and Year1982 == 1, then Jorge is the skydiver who wears the red suit and started skydiving in 1982.

### Decision variables:
-   Names of the skydivers: Jorge, Otis, Philip, Shaun (all different, 1 to 4)
-   Suit colors: LimeGreen, Pink, Red, Yellow (all different, 1 to 4)
-   Years of starting skydiving: 1982, 1983, 1984, 1985 (all different, 1 to 4)

### Constraints:
-   Jorge is either the skydiver who wears the red suit or the jumper who started in 1982:
    This is a constraint that states that Jorge's suit color is either red or he started skydiving in 1982, but not both. So:
    Xor([Jorge == RedSuit, Jorge == Year1982]).

-   The skydiver who wears the pink suit started skydiving 1 year before Otis:
    For this, we will need to add a constraint for each possible assignment of the years for the skydiver who wears the pink suit and Otis, such that the pink suit skydiver's year is 1 less than Otis's year. So, the constraints will be of the form:
    y1 == PinkSuit and y2 == Otis => y1_to_int == y2_to_int - 1, for all y1, y2 in years.

-   The jumper who wears the yellow suit started skydiving sometime after Philip:
    For this, we will need to add a constraint for each possible assignment of the years for the skydiver who wears the yellow suit and Philip, such that the yellow suit skydiver's year is greater than Philip's year. So, the constraints will be of the form:
    y1 == YellowSuit and y2 == Philip => y1_to_int > y2_to_int, for all y1, y2 in years.

-   The jumper who wears the lime green suit started skydiving sometime after the jumper who wears the yellow suit:
    For this, we will need to add a constraint for each possible assignment of the years for the skydiver who wears the lime green suit and the yellow suit, such that the lime green suit skydiver's year is greater than the yellow suit skydiver's year. So, the constraints will be of the form:
    y1 == LimeGreenSuit and y2 == YellowSuit => y1_to_int > y2_to_int, for all y1, y2 in years.

-   The jumper who wears the pink suit started skydiving 2 years before Shaun:
    For this, we will need to add a constraint for each possible assignment of the years for the skydiver who wears the pink suit and Shaun, such that the pink suit skydiver's year is 2 less than Shaun's year. So, the constraints will be of the form:
    y1 == PinkSuit and y2 == Shaun => y1_to_int == y2_to_int - 2, for all y1, y2 in years.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Jorge == 1, and RedSuit == 1, and Year1982 == 1, then Jorge is the skydiver who wears the red suit and started skydiving in 1982.

### Decision variables:
-   Names of the skydivers: Jorge, Otis, Philip, Shaun (all different, 1 to 4)
-   Suit colors: LimeGreen, Pink, Red, Yellow (all different, 1 to 4)
-   Years of starting skydiving: 1982, 1983, 1984, 1985 (all different, 1 to 4)

### Constraints:
-   Jorge is either the skydiver who wears the red suit or the jumper who started in 1982:
    This is a constraint that states that Jorge's suit color is either red or he started skydiving in 1982, but not both. So:
    Xor([Jorge == RedSuit, Jorge == Year1982]).

-   The skydiver who wears the pink suit started skydiving 1 year before Otis:
    For this, we will need to add a constraint for each possible assignment of the years for the skydiver who wears the pink suit and Otis, such that the pink suit skydiver's year is 1 less than Otis's year. So, the constraints will be of the form:
    y1 == PinkSuit and y2 == Otis => y1_to_int == y2_to_int - 1, for all y1, y2 in years.

-   The jumper who wears the yellow suit started skydiving sometime after Philip:
    For this, we will need to add a constraint for each possible assignment of the years for the skydiver who wears the yellow suit and Philip, such that the yellow suit skydiver's year is greater than Philip's year. So, the constraints will be of the form:
    y1 == YellowSuit and y2 == Philip => y1_to_int > y2_to_int, for all y1, y2 in years.

-   The jumper who wears the lime green suit started skydiving sometime after the jumper who wears the yellow suit:
    For this, we will need to add a constraint for each possible assignment of the years for the skydiver who wears the lime green suit and the yellow suit, such that the lime green suit skydiver's year is greater than the yellow suit skydiver's year. So, the constraints will be of the form:
    y1 == LimeGreenSuit and y2 == YellowSuit => y1_to_int > y2_to_int, for all y1, y2 in years.

-   The jumper who wears the pink suit started skydiving 2 years before Shaun:
    For this, we will need to add a constraint for each possible assignment of the years for the skydiver who wears the pink suit and Shaun, such that the pink suit skydiver's year is 2 less than Shaun's year. So, the constraints will be of the form:
    y1 == PinkSuit and y2 == Shaun => y1_to_int == y2_to_int - 2, for all y1, y2 in years.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of skydiver, suit color, and year)
# e.g. if jorge == 1 and red_suit == 1 and year1982 == 1, then Jorge wears the red suit and started skydiving in 1982
jorge, otis, philip, shaun = skydivers = intvar(1, 4, shape=4)
red_suit, pink_suit, lime_green_suit, yellow_suit = suits = intvar(1, 4, shape=4)
year1982, year1983, year1984, year1985 = years = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
skydiver_to_int = None  # N/A
suit_to_int = None  # N/A
year_to_int = {year1982: 1982, year1983: 1983, year1984: 1984, year1985: 1985}  # in years


# Helper functions (for formulating comparison constraints)
def started_after_than(var1, var2):
    """
    Formulate the constraint that var1 started after var2.
    """
    return [((y1 == var1) & (y2 == var2)).implies(year_to_int[y1] > year_to_int[y2])
            for y1 in years for y2 in years]


def started_exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 started exactly diff years after var2.
    """
    return [((y1 == var1) & (y2 == var2)).implies(year_to_int[y1] == year_to_int[y2] + diff)
            for y1 in years for y2 in years]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(skydivers)
m += AllDifferent(suits)
m += AllDifferent(years)

# Clue 1: Jorge is either the skydiver who wears the red suit or the jumper who started in 1982:
m += Xor([jorge == red_suit, jorge == year1982])

# Clue 2: The skydiver who wears the pink suit started skydiving 1 year before Otis:
m += started_exactly_after_than(pink_suit, otis, -1)

# Clue 3: The jumper who wears the yellow suit started skydiving sometime after Philip:
m += started_after_than(yellow_suit, philip)

# Clue 4: The jumper who wears the lime green suit started skydiving sometime after the jumper who wears the yellow suit:
m += started_after_than(lime_green_suit, yellow_suit)

# Clue 5: The jumper who wears the pink suit started skydiving 2 years before Shaun:
m += started_exactly_after_than(pink_suit, shaun, -2)

```
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The ambassador with the 9 day visit will leave sometime after Fitzgerald.
Quinn will leave 2 months after Bender.
The person leaving in January is either the ambassador with the 3 day visit or Fitzgerald.
Quinn will leave 1 month before the ambassador with the 7 day visit.

Entities:
diplomats: Bender, Fitzgerald, Owens, Quinn
months: January, February, March, April
durations: 2 day, 3 day, 7 day, 9 day
PARAM (32-33): 9
VAR (70-80): Fitzgerald
VAR (83-88): Quinn
PARAM (100-101): 2
VAR (115-121): Bender
PARAM (188-189): 3
VAR (203-213): Fitzgerald
VAR (216-221): Quinn
PARAM (233-234): 1
PARAM (272-273): 7
VAR (309-315): Bender
VAR (318-328): Fitzgerald
VAR (339-344): Quinn
PARAM (401-402): 2
PARAM (409-410): 3
PARAM (417-418): 7
PARAM (425-426): 9

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Bender == 1, and January == 1, and Day2 == 1, then Bender is the diplomat leaving in January with a 2-day visit.

### Decision variables:
-   Names of the diplomats: Bender, Fitzgerald, Owens, Quinn (all different, 1 to 4)
-   Months of departure: January, February, March, April (all different, 1 to 4)
-   Visit durations: Day2, Day3, Day7, Day9 (all different, 1 to 4)

### Constraints:
-   The ambassador with the 9-day visit will leave sometime after Fitzgerald:
    For this, we will need to add a constraint for each possible assignment of the months of departure for the ambassador with the 9-day visit and Fitzgerald, such that the ambassador with the 9-day visit's month of departure is greater than Fitzgerald's month of departure. So, the constraints will be of the form:
    m1 == Day9 and m2 == Fitzgerald => m1_to_int > m2_to_int, for all m1, m2 in months of departure.

-   Quinn will leave 2 months after Bender:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Quinn and Bender, such that Quinn's month of departure is 2 more than Bender's month of departure. So, the constraints will be of the form:
    m1 == Quinn and m2 == Bender => m1_to_int == m2_to_int + 2, for all m1, m2 in months of departure.

-   The person leaving in January is either the ambassador with the 3-day visit or Fitzgerald:
    This is a constraint that states that the person leaving in January is either the ambassador with the 3-day visit or Fitzgerald, but not both. So:
    Xor([January == Day3, January == Fitzgerald]).

-   Quinn will leave 1 month before the ambassador with the 7-day visit:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Quinn and the ambassador with the 7-day visit, such that Quinn's month of departure is 1 less than the ambassador's month of departure. So, the constraints will be of the form:
    m1 == Quinn and m2 == Day7 => m1_to_int == m2_to_int - 1, for all m1, m2 in months of departure.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Bender == 1, and January == 1, and Day2 == 1, then Bender is the diplomat leaving in January with a 2-day visit.

### Decision variables:
-   Names of the diplomats: Bender, Fitzgerald, Owens, Quinn (all different, 1 to 4)
-   Months of departure: January, February, March, April (all different, 1 to 4)
-   Visit durations: Day2, Day3, Day7, Day9 (all different, 1 to 4)

### Constraints:
-   The ambassador with the 9-day visit will leave sometime after Fitzgerald:
    For this, we will need to add a constraint for each possible assignment of the months of departure for the ambassador with the 9-day visit and Fitzgerald, such that the ambassador with the 9-day visit's month of departure is greater than Fitzgerald's month of departure. So, the constraints will be of the form:
    m1 == Day9 and m2 == Fitzgerald => m1_to_int > m2_to_int, for all m1, m2 in months of departure.

-   Quinn will leave 2 months after Bender:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Quinn and Bender, such that Quinn's month of departure is 2 more than Bender's month of departure. So, the constraints will be of the form:
    m1 == Quinn and m2 == Bender => m1_to_int == m2_to_int + 2, for all m1, m2 in months of departure.

-   The person leaving in January is either the ambassador with the 3-day visit or Fitzgerald:
    This is a constraint that states that the person leaving in January is either the ambassador with the 3-day visit or Fitzgerald, but not both. So:
    Xor([January == Day3, January == Fitzgerald]).

-   Quinn will leave 1 month before the ambassador with the 7-day visit:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Quinn and the ambassador with the 7-day visit, such that Quinn's month of departure is 1 less than the ambassador's month of departure. So, the constraints will be of the form:
    m1 == Quinn and m2 == Day7 => m1_to_int == m2_to_int - 1, for all m1, m2 in months of departure.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of diplomat, month, and duration)
# e.g. if bender == 1 and january == 1 and day2 == 1, then Bender will leave in January with a 2-day visit
bender, fitzgerald, owens, quinn = diplomats = intvar(1, 4, shape=4)
january, february, march, april = months = intvar(1, 4, shape=4)
day2, day3, day7, day9 = durations = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
diplomat_to_int = None  # N/A
month_to_int = {january: 1, february: 2, march: 3, april: 4}  # in months
duration_to_int = {day2: 2, day3: 3, day7: 7, day9: 9}  # in days


# Helper functions (for formulating comparison constraints)
def leave_after_than(var1, var2):
    """
    Formulate the constraint that var1 leaves after var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(month_to_int[d1] > month_to_int[d2])
            for d1 in months for d2 in months]


def leave_exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 leaves exactly diff months after var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(month_to_int[d1] == month_to_int[d2] + diff)
            for d1 in months for d2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(diplomats)
m += AllDifferent(months)
m += AllDifferent(durations)

# Clue 1: The ambassador with the 9-day visit will leave sometime after Fitzgerald:
m += leave_after_than(day9, fitzgerald)

# Clue 2: Quinn will leave 2 months after Bender:
m += leave_exactly_after_than(quinn, bender, 2)

# Clue 3: The person leaving in January is either the ambassador with the 3-day visit or Fitzgerald:
m += Xor([january == day3, january == fitzgerald])

# Clue 4: Quinn will leave 1 month before the ambassador with the 7-day visit:
m += leave_exactly_after_than(quinn, day7, -1)

```
True
True
True
Wrong: 0, Total: 7
---------------------------------------------------------------------------------------------

Clues:
Ultra Hex is Gabe Grant.
Criminal Bane is either the hero who started in 2007 or the superhero who started in 2009.
Peter Powers began sometime before Matt Minkle.
Gabe Grant began 1 year after Wonderman.
The four people are Deep Shadow, the superhero who started in 2007, the hero who started in 2009 and Matt Minkle.

Entities:
years: 2007, 2008, 2009, 2010
superheroes: Criminal Bane, Deep Shadow, Ultra Hex, Wonderman
names: Gabe Grant, Ivor Ingram, Matt Minkle, Peter Powers
VAR (21-25): Gabe
VAR (34-47): Criminal Bane
PARAM (82-86): 2007
PARAM (119-123): 2009
VAR (126-138): Peter Powers
VAR (175-185): Gabe Grant
PARAM (192-193): 1
PARAM (280-284): 2007
PARAM (311-315): 2009
PARAM (353-357): 2007
PARAM (360-364): 2008
PARAM (367-371): 2009
PARAM (374-378): 2010
VAR (393-406): Criminal Bane
VAR (453-457): Gabe
VAR (494-506): Peter Powers

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if GabeGrant == 1, and 2007 == 1, and PeterPowers == 1, then Gabe Grant started in 2007 before Peter Powers.

### Decision variables:
-   Names of the superheroes: CriminalBane, DeepShadow, UltraHex, Wonderman (all different, 1 to 4)
-   Names of the people: GabeGrant, IvorIngram, MattMinkle, PeterPowers (all different, 1 to 4)
-   Years of starting: 2007, 2008, 2009, 2010 (all different, 1 to 4)

### Constraints:
-   Ultra Hex is Gabe Grant:
    This is a direct assignment constraint:
    UltraHex == GabeGrant.

-   Criminal Bane is either the hero who started in 2007 or the superhero who started in 2009:
    This is a constraint that states that Criminal Bane's starting year is either 2007 or 2009, but not both. So:
    Xor([CriminalBane == 2007, CriminalBane == 2009]).

-   Peter Powers began sometime before Matt Minkle:
    For this, we will need to add a constraint for each possible assignment of the years for Peter Powers and Matt Minkle, such that Peter Powers's starting year is less than Matt Minkle's starting year. So, the constraints will be of the form:
    y1 == PeterPowers and y2 == MattMinkle => y1_to_int < y2_to_int, for all y1, y2 in years.

-   Gabe Grant began 1 year after Wonderman:
    For this, we will need to add a constraint for each possible assignment of the years for Gabe Grant and Wonderman, such that Gabe Grant's starting year is 1 more than Wonderman's starting year. So, the constraints will be of the form:
    y1 == GabeGrant and y2 == Wonderman => y1_to_int == y2_to_int + 1, for all y1, y2 in years.

-   The four people are Deep Shadow, the superhero who started in 2007, the hero who started in 2009, and Matt Minkle:
    This is a constraint that states that all these entities are different, thus:
    AllDifferent([DeepShadow, 2007, 2009, MattMinkle]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if GabeGrant == 1, and 2007 == 1, and PeterPowers == 1, then Gabe Grant started in 2007 before Peter Powers.

### Decision variables:
-   Names of the superheroes: CriminalBane, DeepShadow, UltraHex, Wonderman (all different, 1 to 4)
-   Names of the people: GabeGrant, IvorIngram, MattMinkle, PeterPowers (all different, 1 to 4)
-   Years of starting: 2007, 2008, 2009, 2010 (all different, 1 to 4)

### Constraints:
-   Ultra Hex is Gabe Grant:
    This is a direct assignment constraint:
    UltraHex == GabeGrant.

-   Criminal Bane is either the hero who started in 2007 or the superhero who started in 2009:
    This is a constraint that states that Criminal Bane's starting year is either 2007 or 2009, but not both. So:
    Xor([CriminalBane == 2007, CriminalBane == 2009]).

-   Peter Powers began sometime before Matt Minkle:
    For this, we will need to add a constraint for each possible assignment of the years for Peter Powers and Matt Minkle, such that Peter Powers's starting year is less than Matt Minkle's starting year. So, the constraints will be of the form:
    y1 == PeterPowers and y2 == MattMinkle => y1_to_int < y2_to_int, for all y1, y2 in years.

-   Gabe Grant began 1 year after Wonderman:
    For this, we will need to add a constraint for each possible assignment of the years for Gabe Grant and Wonderman, such that Gabe Grant's starting year is 1 more than Wonderman's starting year. So, the constraints will be of the form:
    y1 == GabeGrant and y2 == Wonderman => y1_to_int == y2_to_int + 1, for all y1, y2 in years.

-   The four people are Deep Shadow, the superhero who started in 2007, the hero who started in 2009, and Matt Minkle:
    This is a constraint that states that all these entities are different, thus:
    AllDifferent([DeepShadow, 2007, 2009, MattMinkle]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of superhero, person, and year)
# e.g. if ultra_hex == 1 and gabe_grant == 1 and year_2007 == 1, then Ultra Hex is Gabe Grant who started in 2007
ultra_hex, criminal_bane, deep_shadow, wonderman = superheroes = intvar(1, 4, shape=4)
gabe_grant, ivor_ingram, matt_minkle, peter_powers = people = intvar(1, 4, shape=4)
year_2007, year_2008, year_2009, year_2010 = years = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
superhero_to_int = None  # N/A
person_to_int = None  # N/A
year_to_int = {year_2007: 2007, year_2008: 2008, year_2009: 2009, year_2010: 2010}  # in years


# Helper functions (for formulating comparison constraints)
def started_before_than(var1, var2):
    """
    Formulate the constraint that var1 started before var2.
    """
    return [((y1 == var1) & (y2 == var2)).implies(year_to_int[y1] < year_to_int[y2])
            for y1 in years for y2 in years]


def started_exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 started exactly diff years after var2.
    """
    return [((y1 == var1) & (y2 == var2)).implies(year_to_int[y1] == year_to_int[y2] + diff)
            for y1 in years for y2 in years]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(superheroes)
m += AllDifferent(people)
m += AllDifferent(years)

# Clue 1: Ultra Hex is Gabe Grant:
m += ultra_hex == gabe_grant

# Clue 2: Criminal Bane is either the hero who started in 2007 or the superhero who started in 2009:
m += Xor([criminal_bane == year_2007, criminal_bane == year_2009])

# Clue 3: Peter Powers began sometime before Matt Minkle:
m += started_before_than(peter_powers, matt_minkle)

# Clue 4: Gabe Grant began 1 year after Wonderman:
m += started_exactly_after_than(gabe_grant, wonderman, 1)

# Clue 5: The four people are Deep Shadow, the superhero who started in 2007, the hero who started in 2009, and Matt Minkle:
m += AllDifferent([deep_shadow, year_2007, year_2009, matt_minkle])

```
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The Sancode interview is 1 day after the meeting for the copywriter position.
The Laneplex interview is on August 20th.
The meeting for the copywriter position is 2 days before the meeting for the web developer position.
The Haytouch interview is for the sales rep job.

Entities:
days: August 20th, August 21st, August 22nd, August 23rd
companies: Canway, Haytouch, Laneplex, Sancode
positions: copywriter, janitor, sales rep, web developer
PARAM (33-34): 1
VAR (65-84): copywriter position
VAR (91-99): Laneplex
PARAM (123-127): 20th
VAR (150-169): copywriter position
PARAM (173-174): 2
VAR (207-229): web developer position
PARAM (307-311): 20th
PARAM (321-325): 21st
PARAM (335-339): 22nd
PARAM (349-353): 23rd
VAR (386-394): Laneplex
VAR (452-465): web developer

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Canway == 1, and August20th == 1, and Copywriter == 1, then the meeting for the copywriter position at Canway is on August 20th.

### Decision variables:
-   Companies: Canway, Haytouch, Laneplex, Sancode (all different, 1 to 4)
-   Dates: August 20th, August 21st, August 22nd, August 23rd (all different, 1 to 4)
-   Positions: Copywriter, Janitor, Sales Rep, Web Developer (all different, 1 to 4)

### Constraints:
-   The Sancode interview is 1 day after the meeting for the copywriter position:
    For this, we will need to add a constraint for each possible assignment of the dates for the Sancode interview and the meeting for the copywriter position, such that the Sancode interview date is 1 more than the copywriter meeting date. So, the constraints will be of the form:
    d1 == Sancode and d2 == Copywriter => d1_to_int == d2_to_int + 1, for all d1, d2 in dates.

-   The Laneplex interview is on August 20th:
    This is a direct assignment constraint:
    Laneplex == August20th.

-   The meeting for the copywriter position is 2 days before the meeting for the web developer position:
    For this, we will need to add a constraint for each possible assignment of the dates for the copywriter meeting and the web developer meeting, such that the copywriter meeting date is 2 less than the web developer meeting date. So, the constraints will be of the form:
    d1 == Copywriter and d2 == WebDeveloper => d1_to_int == d2_to_int - 2, for all d1, d2 in dates.

-   The Haytouch interview is for the sales rep job:
    This is a direct assignment constraint:
    Haytouch == SalesRep.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Canway == 1, and August20th == 1, and Copywriter == 1, then the meeting for the copywriter position at Canway is on August 20th.

### Decision variables:
-   Companies: Canway, Haytouch, Laneplex, Sancode (all different, 1 to 4)
-   Dates: August 20th, August 21st, August 22nd, August 23rd (all different, 1 to 4)
-   Positions: Copywriter, Janitor, Sales Rep, Web Developer (all different, 1 to 4)

### Constraints:
-   The Sancode interview is 1 day after the meeting for the copywriter position:
    For this, we will need to add a constraint for each possible assignment of the dates for the Sancode interview and the meeting for the copywriter position, such that the Sancode interview date is 1 more than the copywriter meeting date. So, the constraints will be of the form:
    d1 == Sancode and d2 == Copywriter => d1_to_int == d2_to_int + 1, for all d1, d2 in dates.

-   The Laneplex interview is on August 20th:
    This is a direct assignment constraint:
    Laneplex == August20th.

-   The meeting for the copywriter position is 2 days before the meeting for the web developer position:
    For this, we will need to add a constraint for each possible assignment of the dates for the copywriter meeting and the web developer meeting, such that the copywriter meeting date is 2 less than the web developer meeting date. So, the constraints will be of the form:
    d1 == Copywriter and d2 == WebDeveloper => d1_to_int == d2_to_int - 2, for all d1, d2 in dates.

-   The Haytouch interview is for the sales rep job:
    This is a direct assignment constraint:
    Haytouch == SalesRep.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of company, date, and position)
# e.g. if canway == 1 and aug20 == 1 and copywriter == 1, then the meeting for the copywriter position at Canway is on August 20th
canway, haytouch, laneplex, sancode = companies = intvar(1, 4, shape=4)
aug20, aug21, aug22, aug23 = dates = intvar(1, 4, shape=4)
copywriter, janitor, sales_rep, web_developer = positions = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
company_to_int = None  # N/A
date_to_int = {aug20: 1, aug21: 2, aug22: 3, aug23: 4}  # in days
position_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def day_after_than(var1, var2):
    """
    Formulate the constraint that var1 is 1 day after var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(date_to_int[d1] == date_to_int[d2] + 1)
            for d1 in dates for d2 in dates]


def day_before_than(var1, var2):
    """
    Formulate the constraint that var1 is 1 day before var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(date_to_int[d1] == date_to_int[d2] - 1)
            for d1 in dates for d2 in dates]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(companies)
m += AllDifferent(dates)
m += AllDifferent(positions)

# Clue 1: The Sancode interview is 1 day after the meeting for the copywriter position:
m += day_after_than(sancode, copywriter)

# Clue 2: The Laneplex interview is on August 20th:
m += laneplex == aug20

# Clue 3: The meeting for the copywriter position is 2 days before the meeting for the web developer position:
m += day_before_than(copywriter, web_developer)

# Clue 4: The Haytouch interview is for the sales rep job:
m += haytouch == sales_rep

```
False
False
False
Wrong: 1, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The Quince Street project will be headed by Freda Fisher.
Of the job starting in May and the Oak Road project, one will be headed by Dawn Daniels and the other will be headed by Irma Ingram.
Of the job starting in July and the job starting in April, one will focus on Oak Road and the other will be headed by Freda Fisher.
The Aspen Court project starts in May.
The Aspen Court project begins sometime after Dawn Daniels's project.

Entities:
months: April, May, June, July
streets: Aspen Court, Norway Court, Oak Road, Quince Street
managers: Bill Bonner, Dawn Daniels, Freda Fisher, Irma Ingram
VAR (12-25): Quince Street
VAR (102-110): Oak Road
VAR (280-288): Oak Road
VAR (340-351): Aspen Court
VAR (379-390): Aspen Court

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if QuinceStreet == 1, and FredaFisher == 1, and May == 1, then the Quince Street project will be headed by Freda Fisher and will start in May.

### Decision variables:
-   Names of the projects: QuinceStreet, OakRoad, AspenCourt, NorwayCourt (all different, 1 to 4)
-   Months of starting: April, May, June, July (all different, 1 to 4)
-   Names of the managers: BillBonner, DawnDaniels, FredaFisher, IrmaIngram (all different, 1 to 4)

### Constraints:
-   The Quince Street project will be headed by Freda Fisher:
    This is a direct assignment constraint:
    QuinceStreet == FredaFisher.

-   Of the job starting in May and the Oak Road project, one will be headed by Dawn Daniels and the other will be headed by Irma Ingram:
    This is a constraint that states that one of the projects starting in May and Oak Road will be headed by Dawn Daniels, and the other will be headed by Irma Ingram. So, we can represent this as:
    Xor([May == DawnDaniels, OakRoad == DawnDaniels]) and Xor([May == IrmaIngram, OakRoad == IrmaIngram]).

-   Of the job starting in July and the job starting in April, one will focus on Oak Road and the other will be headed by Freda Fisher:
    This is a constraint that states that one of the projects starting in July and April will focus on Oak Road, and the other will be headed by Freda Fisher. So, we can represent this as:
    Xor([July == OakRoad, April == FredaFisher]) and Xor([July == FredaFisher, April == OakRoad]).

-   The Aspen Court project starts in May:
    This is a direct assignment constraint:
    AspenCourt == May.

-   The Aspen Court project begins sometime after Dawn Daniels's project:
    For this, we will need to add a constraint for each possible assignment of the starting months for Dawn Daniels's project and the Aspen Court project, such that Aspen Court's starting month is greater than Dawn Daniels's project starting month. So, the constraints will be of the form:
    m1 == DawnDaniels and m2 == AspenCourt => m1_to_int < m2_to_int, for all m1, m2 in months of starting.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if QuinceStreet == 1, and FredaFisher == 1, and May == 1, then the Quince Street project will be headed by Freda Fisher and will start in May.

### Decision variables:
-   Names of the projects: QuinceStreet, OakRoad, AspenCourt, NorwayCourt (all different, 1 to 4)
-   Months of starting: April, May, June, July (all different, 1 to 4)
-   Names of the managers: BillBonner, DawnDaniels, FredaFisher, IrmaIngram (all different, 1 to 4)

### Constraints:
-   The Quince Street project will be headed by Freda Fisher:
    This is a direct assignment constraint:
    QuinceStreet == FredaFisher.

-   Of the job starting in May and the Oak Road project, one will be headed by Dawn Daniels and the other will be headed by Irma Ingram:
    This is a constraint that states that one of the projects starting in May and Oak Road will be headed by Dawn Daniels, and the other will be headed by Irma Ingram. So, we can represent this as:
    Xor([May == DawnDaniels, OakRoad == DawnDaniels]) and Xor([May == IrmaIngram, OakRoad == IrmaIngram]).

-   Of the job starting in July and the job starting in April, one will focus on Oak Road and the other will be headed by Freda Fisher:
    This is a constraint that states that one of the projects starting in July and April will focus on Oak Road, and the other will be headed by Freda Fisher. So, we can represent this as:
    Xor([July == OakRoad, April == FredaFisher]) and Xor([July == FredaFisher, April == OakRoad]).

-   The Aspen Court project starts in May:
    This is a direct assignment constraint:
    AspenCourt == May.

-   The Aspen Court project begins sometime after Dawn Daniels's project:
    For this, we will need to add a constraint for each possible assignment of the starting months for Dawn Daniels's project and the Aspen Court project, such that Aspen Court's starting month is greater than Dawn Daniels's project starting month. So, the constraints will be of the form:
    m1 == DawnDaniels and m2 == AspenCourt => m1_to_int < m2_to_int, for all m1, m2 in months of starting.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of project, month, and manager)
# e.g. if quince == 1 and may == 1 and freda == 1, then the Quince Street project will start in May and be headed by Freda Fisher
quince, oak, aspen, norway = projects = intvar(1, 4, shape=4)
april, may, june, july = months = intvar(1, 4, shape=4)
bill, dawn, freda, irma = managers = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
project_to_int = None  # N/A
month_to_int = {april: 1, may: 2, june: 3, july: 4}  # in months
manager_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def headed_by(var1, var2):
    """
    Formulate the constraint that var1 is headed by var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(p1 == p2)
            for p1 in projects for p2 in managers]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(projects)
m += AllDifferent(months)
m += AllDifferent(managers)

# Clue 1: The Quince Street project will be headed by Freda Fisher:
m += headed_by(quince, freda)

# Clue 2: Of the job starting in May and the Oak Road project, one will be headed by Dawn Daniels and the other will be headed by Irma Ingram:
m += Xor([may == dawn, oak == dawn])  # May or Oak Road headed by Dawn Daniels
m += Xor([may == irma, oak == irma])  # May or Oak Road headed by Irma Ingram

# Clue 3: Of the job starting in July and the job starting in April, one will focus on Oak Road and the other will be headed by Freda Fisher:
m += Xor([july == oak, april == freda])  # July or April focused on Oak Road
m += Xor([july == freda, april == oak])  # July or April headed by Freda Fisher

# Clue 4: The Aspen Court project starts in May:
m += aspen == may

# Clue 5: The Aspen Court project begins sometime after Dawn Daniels's project:
m += dawn < aspen

```
False
False
False
Wrong: 5, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Of Sophie and Gwen, one will bring their rabbit's foot and the other will leave in January.
Sophie will leave sometime before Gwen.
The passenger with the lucky hat, Gwen and Sophie are all different fliers.
Florence will leave 2 months after the passenger with the lucky hat.
The passenger leaving in April is either Gwen or the passenger with the talisman.

Entities:
months: January, February, March, April
fliers: Florence, Gwen, Olive, Sophie
lucky charms: coin, lucky hat, rabbit's foot, talisman
VAR (11-17): Sophie
VAR (22-26): Gwen
VAR (103-109): Sophie
VAR (137-141): Gwen
VAR (188-194): Sophie
VAR (222-230): Florence
PARAM (242-243): 2
VAR (439-447): Florence
VAR (465-471): Sophie

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Sophie == 1, and January == 1, and RabbitFoot == 1, then Sophie will bring their rabbit's foot and leave in January.

### Decision variables:
-   Names of the fliers: Florence, Gwen, Olive, Sophie (all different, 1 to 4)
-   Months of departure: January, February, March, April (all different, 1 to 4)
-   Lucky charms: Coin, LuckyHat, RabbitFoot, Talisman (all different, 1 to 4)

### Constraints:
-   Of Sophie and Gwen, one will bring their rabbit's foot and the other will leave in January:
    This is a constraint that states that Sophie and Gwen have different lucky charms and different months of departure, and one will bring their rabbit's foot and the other will leave in January. So, the constraints will be of the form:
    (Sophie == RabbitFoot and Gwen == January) or (Gwen == RabbitFoot and Sophie == January).

-   Sophie will leave sometime before Gwen:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Sophie and Gwen, such that Sophie's month of departure is less than Gwen's month of departure. So, the constraints will be of the form:
    m1 == Sophie and m2 == Gwen => m1_to_int < m2_to_int, for all m1, m2 in months of departure.

-   The passenger with the lucky hat, Gwen, and Sophie are all different fliers:
    This is a constraint that states that all these entities are different, thus:
    AllDifferent([LuckyHat, Gwen, Sophie]).

-   Florence will leave 2 months after the passenger with the lucky hat:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Florence and the passenger with the lucky hat, such that Florence's month of departure is 2 more than the lucky hat passenger's month of departure. So, the constraints will be of the form:
    m1 == Florence and m2 == LuckyHat => m1_to_int == m2_to_int + 2, for all m1, m2 in months of departure.

-   The passenger leaving in April is either Gwen or the passenger with the talisman:
    This is a constraint that states that the passenger leaving in April is either Gwen or the passenger with the talisman, but not both. So:
    Xor([Gwen == April, Talisman == April]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Sophie == 1, and January == 1, and RabbitFoot == 1, then Sophie will bring their rabbit's foot and leave in January.

### Decision variables:
-   Names of the fliers: Florence, Gwen, Olive, Sophie (all different, 1 to 4)
-   Months of departure: January, February, March, April (all different, 1 to 4)
-   Lucky charms: Coin, LuckyHat, RabbitFoot, Talisman (all different, 1 to 4)

### Constraints:
-   Of Sophie and Gwen, one will bring their rabbit's foot and the other will leave in January:
    This is a constraint that states that Sophie and Gwen have different lucky charms and different months of departure, and one will bring their rabbit's foot and the other will leave in January. So, the constraints will be of the form:
    (Sophie == RabbitFoot and Gwen == January) or (Gwen == RabbitFoot and Sophie == January).

-   Sophie will leave sometime before Gwen:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Sophie and Gwen, such that Sophie's month of departure is less than Gwen's month of departure. So, the constraints will be of the form:
    m1 == Sophie and m2 == Gwen => m1_to_int < m2_to_int, for all m1, m2 in months of departure.

-   The passenger with the lucky hat, Gwen, and Sophie are all different fliers:
    This is a constraint that states that all these entities are different, thus:
    AllDifferent([LuckyHat, Gwen, Sophie]).

-   Florence will leave 2 months after the passenger with the lucky hat:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Florence and the passenger with the lucky hat, such that Florence's month of departure is 2 more than the lucky hat passenger's month of departure. So, the constraints will be of the form:
    m1 == Florence and m2 == LuckyHat => m1_to_int == m2_to_int + 2, for all m1, m2 in months of departure.

-   The passenger leaving in April is either Gwen or the passenger with the talisman:
    This is a constraint that states that the passenger leaving in April is either Gwen or the passenger with the talisman, but not both. So:
    Xor([Gwen == April, Talisman == April]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of flier, month, and lucky charm)
# e.g. if sophie == 1 and january == 1 and rabbit_foot == 1, then Sophie will bring their rabbit's foot and leave in January
sophie, gwen, florence, olive = fliers = intvar(1, 4, shape=4)
january, february, march, april = months = intvar(1, 4, shape=4)
coin, lucky_hat, rabbit_foot, talisman = lucky_charms = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
flier_to_int = None  # N/A
month_to_int = {january: 1, february: 2, march: 3, april: 4}  # in months
lucky_charm_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def leave_before_than(var1, var2):
    """
    Formulate the constraint that var1 leaves before var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] < month_to_int[m2])
            for m1 in months for m2 in months]


def leave_exactly_before_than(var1, var2, diff):
    """
    Formulate the constraint that var1 leaves exactly diff months before var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] == month_to_int[m2] - diff)
            for m1 in months for m2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(fliers)
m += AllDifferent(months)
m += AllDifferent(lucky_charms)

# Clue 1: Of Sophie and Gwen, one will bring their rabbit's foot and the other will leave in January:
m += ((sophie == rabbit_foot) & (gwen == january)) | ((gwen == rabbit_foot) & (sophie == january))

# Clue 2: Sophie will leave sometime before Gwen:
m += leave_before_than(sophie, gwen)

# Clue 3: The passenger with the lucky hat, Gwen, and Sophie are all different fliers:
m += AllDifferent([lucky_hat, gwen, sophie])

# Clue 4: Florence will leave 2 months after the passenger with the lucky hat:
m += leave_exactly_before_than(florence, lucky_hat, 2)

# Clue 5: The passenger leaving in April is either Gwen or the passenger with the talisman:
m += Xor([gwen == april, talisman == april])

```
False
False
False
Wrong: 2, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The Iunsel launched in February.
The Munei is going to Mars.
The Munei launched 1 month after the mission going to Pluto.
Of the mission going to Ganymede and the mission going to Pluto, one launched in March and the other is the Chano.

Entities:
months: January, February, March, April
probes: Ateyin, Chano, Iunsel, Munei
destinations: Ganymede, Mars, Pluto, Uranus
VAR (125-130): Pluto
VAR (157-165): Ganymede
VAR (191-196): Pluto
VAR (361-369): Ganymede
VAR (379-384): Pluto

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Iunsel == 1, and February == 1, and Mars == 1, then the Iunsel probe was launched in February and is going to Mars.

### Decision variables:
-   Months of launch: January, February, March, April (all different, 1 to 4)
-   Names of the probes: Ateyin, Chano, Iunsel, Munei (all different, 1 to 4)
-   Destinations: Ganymede, Mars, Pluto, Uranus (all different, 1 to 4)

### Constraints:
-   The Iunsel launched in February:
    This is a direct assignment constraint:
    Iunsel == February.

-   The Munei is going to Mars:
    This is a direct assignment constraint:
    Munei == Mars.

-   The Munei launched 1 month after the mission going to Pluto:
    For this, we will need to add a constraint for each possible assignment of the probes for Munei and the mission going to Pluto, such that Munei's launch month is 1 more than the Pluto mission's launch month. So, the constraints will be of the form:
    p1 == Munei and p2 == Pluto => p1_to_int == p2_to_int + 1, for all p1, p2 in months of launch.

-   Of the mission going to Ganymede and the mission going to Pluto, one launched in March and the other is the Chano:
    This is a constraint that states that one of the missions went to Ganymede and the other to Pluto, one launched in March, and the other is the Chano probe. So, we can represent this as:
    (Ganymede == March and Pluto == Chano) or (Pluto == March and Ganymede == Chano).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Iunsel == 1, and February == 1, and Mars == 1, then the Iunsel probe was launched in February and is going to Mars.

### Decision variables:
-   Months of launch: January, February, March, April (all different, 1 to 4)
-   Names of the probes: Ateyin, Chano, Iunsel, Munei (all different, 1 to 4)
-   Destinations: Ganymede, Mars, Pluto, Uranus (all different, 1 to 4)

### Constraints:
-   The Iunsel launched in February:
    This is a direct assignment constraint:
    Iunsel == February.

-   The Munei is going to Mars:
    This is a direct assignment constraint:
    Munei == Mars.

-   The Munei launched 1 month after the mission going to Pluto:
    For this, we will need to add a constraint for each possible assignment of the probes for Munei and the mission going to Pluto, such that Munei's launch month is 1 more than the Pluto mission's launch month. So, the constraints will be of the form:
    p1 == Munei and p2 == Pluto => p1_to_int == p2_to_int + 1, for all p1, p2 in months of launch.

-   Of the mission going to Ganymede and the mission going to Pluto, one launched in March and the other is the Chano:
    This is a constraint that states that one of the missions went to Ganymede and the other to Pluto, one launched in March, and the other is the Chano probe. So, we can represent this as:
    (Ganymede == March and Pluto == Chano) or (Pluto == March and Ganymede == Chano).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of probe, month, and destination)
# e.g. if iunsel == 1 and february == 1 and mars == 1, then the Iunsel probe was launched in February and is going to Mars
ateyin, chano, iunsel, munei = probes = intvar(1, 4, shape=4)
january, february, march, april = months = intvar(1, 4, shape=4)
ganymede, mars, pluto, uranus = destinations = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
probe_to_int = None  # N/A
month_to_int = {january: 1, february: 2, march: 3, april: 4}  # in months
destination_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def launched_after_than(var1, var2):
    """
    Formulate the constraint that var1 launched after var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(month_to_int[p1] > month_to_int[p2])
            for p1 in months for p2 in months]


def launched_exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 launched exactly diff months after var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(month_to_int[p1] == month_to_int[p2] + diff)
            for p1 in months for p2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(probes)
m += AllDifferent(months)
m += AllDifferent(destinations)

# Clue 1: The Iunsel launched in February:
m += iunsel == february

# Clue 2: The Munei is going to Mars:
m += munei == mars

# Clue 3: The Munei launched 1 month after the mission going to Pluto:
m += launched_exactly_after_than(munei, pluto, 1)

# Clue 4: Of the mission going to Ganymede and the mission going to Pluto, one launched in March and the other is the Chano:
m += ((ganymede == march) & (pluto == chano)) | ((pluto == march) & (ganymede == chano)

```
Error: invalid syntax (<string>, line 1)
False
False
Error: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
The blue topaz sold for 10 dollars more than the gem found in the Osborne claim.
The rhodolite went for $820.
The tourmaline is either the gem that sold for $810 or the gem found in the Underwood claim.
Of the gem found in the Collins claim and the aquamarine, one went for $790 and the other went for $800.

Entities:
prices: $790, $800, $810, $820
gems: aquamarine, blue topaz, rhodolite, tourmaline
claims: Collins, Knox, Osborne, Underwood
VAR (12-22): blue topaz
PARAM (32-34): 10
VAR (74-87): Osborne claim
VAR (94-103): rhodolite
PARAM (115-118): 820
OBJ_NAME (159-163): sold
PARAM (170-173): 810
VAR (198-213): Underwood claim
VAR (240-253): Collins claim
VAR (262-272): aquamarine
PARAM (290-293): 790
PARAM (319-322): 800
OBJ_NAME (336-342): prices
PARAM (347-350): 790
PARAM (355-358): 800
PARAM (363-366): 810
PARAM (371-374): 820
VAR (382-392): aquamarine
VAR (395-405): blue topaz
VAR (440-447): Collins
VAR (450-454): Knox
VAR (457-464): Osborne
VAR (467-476): Underwood

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Aquamarine == 1, and Collins == 1, and Price790 == 1, then the aquamarine found in the Collins claim went for $790.

### Decision variables:
-   Names of the gems: Aquamarine, BlueTopaz, Rhodolite, Tourmaline (all different, 1 to 4)
-   Prices of the gems: Price790, Price800, Price810, Price820 (all different, 1 to 4)
-   Claims where gems were found: Collins, Knox, Osborne, Underwood (all different, 1 to 4)

### Constraints:
-   The blue topaz sold for 10 dollars more than the gem found in the Osborne claim:
    For this, we will need to add a constraint for each possible assignment of prices for the blue topaz and the gem found in the Osborne claim, such that the blue topaz's price is $10 more than the Osborne claim gem's price. So, the constraints will be of the form:
    p1 == BlueTopaz and p2 == OsborneClaim => p1_to_int == p2_to_int + 10, for all p1, p2 in prices.

-   The rhodolite went for $820:
    This is a direct assignment constraint:
    Rhodolite == Price820.

-   The tourmaline is either the gem that sold for $810 or the gem found in the Underwood claim:
    This is a constraint that states that the tourmaline's price is either $810 or the gem found in the Underwood claim, but not both. So:
    Xor([Tourmaline == Price810, Tourmaline == UnderwoodClaim]).

-   Of the gem found in the Collins claim and the aquamarine, one went for $790 and the other went for $800:
    This is a constraint that states that the gem found in the Collins claim and the aquamarine have prices of $790 and $800, but not in the same order. So, we will need to add constraints to ensure this:
    (Collins == Price790 and Aquamarine == Price800) or (Collins == Price800 and Aquamarine == Price790).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Aquamarine == 1, and Collins == 1, and Price790 == 1, then the aquamarine found in the Collins claim went for $790.

### Decision variables:
-   Names of the gems: Aquamarine, BlueTopaz, Rhodolite, Tourmaline (all different, 1 to 4)
-   Prices of the gems: Price790, Price800, Price810, Price820 (all different, 1 to 4)
-   Claims where gems were found: Collins, Knox, Osborne, Underwood (all different, 1 to 4)

### Constraints:
-   The blue topaz sold for 10 dollars more than the gem found in the Osborne claim:
    For this, we will need to add a constraint for each possible assignment of prices for the blue topaz and the gem found in the Osborne claim, such that the blue topaz's price is $10 more than the Osborne claim gem's price. So, the constraints will be of the form:
    p1 == BlueTopaz and p2 == OsborneClaim => p1_to_int == p2_to_int + 10, for all p1, p2 in prices.

-   The rhodolite went for $820:
    This is a direct assignment constraint:
    Rhodolite == Price820.

-   The tourmaline is either the gem that sold for $810 or the gem found in the Underwood claim:
    This is a constraint that states that the tourmaline's price is either $810 or the gem found in the Underwood claim, but not both. So:
    Xor([Tourmaline == Price810, Tourmaline == UnderwoodClaim]).

-   Of the gem found in the Collins claim and the aquamarine, one went for $790 and the other went for $800:
    This is a constraint that states that the gem found in the Collins claim and the aquamarine have prices of $790 and $800, but not in the same order. So, we will need to add constraints to ensure this:
    (Collins == Price790 and Aquamarine == Price800) or (Collins == Price800 and Aquamarine == Price790).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of gem, price, and claim)
# e.g. if aquamarine == 1 and collins == 1 and price790 == 1, then the aquamarine found in the Collins claim went for $790
aquamarine, blue_topaz, rhodolite, tourmaline = gems = intvar(1, 4, shape=4)
price790, price800, price810, price820 = prices = intvar(1, 4, shape=4)
collins, knox, osborne, underwood = claims = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
gem_to_int = None  # N/A
price_to_int = {price790: 790, price800: 800, price810: 810, price820: 820}  # in dollars
claim_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def sold_for_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 sold for diff dollars more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] + diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(gems)
m += AllDifferent(prices)
m += AllDifferent(claims)

# Clue 1: The blue topaz sold for 10 dollars more than the gem found in the Osborne claim:
m += sold_for_more_than(blue_topaz, osborne, 10)

# Clue 2: The rhodolite went for $820:
m += rhodolite == price820

# Clue 3: The tourmaline is either the gem that sold for $810 or the gem found in the Underwood claim:
m += Xor([tourmaline == price810, tourmaline == underwood])

# Clue 4: Of the gem found in the Collins claim and the aquamarine, one went for $790 and the other went for $800:
m += ((collins == price790) & (aquamarine == price800)) | ((collins == price800) & (aquamarine == price790))

```
True
True
True
Wrong: 1, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The facility launching in March is the tokamak reactor.
The reactor launching in April is either the direct drive facility or the z-pinch facility.
Of the fusor reactor and the z-pinch facility, one will launch in February and the other is the Kuchiwa W10.
The Essita CBT will launch in February.
The Haramarui LV will launch 1 month before the fusor reactor.

Entities:
months: January, February, March, April
names: Essita CBT, Haramarui LV, Kuchiwa W10, Rodim-Rexit
types: direct drive, fusor, tokamak, z-pinch
VAR (259-270): Kuchiwa W10
VAR (277-287): Essita CBT
VAR (318-330): Haramarui LV
VAR (441-451): Essita CBT
VAR (454-466): Haramarui LV
VAR (469-480): Kuchiwa W10

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if EssitaCBT == 1, and February == 1, and Tokamak == 1, then Essita CBT is the tokamak reactor launching in February.

### Decision variables:
-   Names of the reactors: EssitaCBT, HaramaruiLV, KuchiwaW10, RodimRexit (all different, 1 to 4)
-   Months of launch: January, February, March, April (all different, 1 to 4)
-   Types of reactors: DirectDrive, Fusor, Tokamak, ZPinch (all different, 1 to 4)

### Constraints:
-   The facility launching in March is the tokamak reactor:
    This is a direct assignment constraint:
    March == Tokamak.

-   The reactor launching in April is either the direct drive facility or the z-pinch facility:
    This is a constraint that states that the reactor launching in April is either the direct drive facility or the z-pinch facility, but not both. So:
    Xor([April == DirectDrive, April == ZPinch]).

-   Of the fusor reactor and the z-pinch facility, one will launch in February and the other is the Kuchiwa W10:
    This is a constraint that states that one of the fusor reactor and the z-pinch facility will launch in February and the other is the Kuchiwa W10. So:
    (Xor([February == Fusor, February == ZPinch]) and KuchiwaW10 == ZPinch) or (Xor([February == Fusor, February == ZPinch]) and KuchiwaW10 == Fusor).

-   The Essita CBT will launch in February:
    This is a direct assignment constraint:
    EssitaCBT == February.

-   The Haramarui LV will launch 1 month before the fusor reactor:
    For this, we will need to add a constraint for each possible assignment of the months for Haramarui LV and the fusor reactor, such that Haramarui LV's launch month is 1 less than the fusor reactor's launch month. So, the constraints will be of the form:
    m1 == HaramaruiLV and m2 == Fusor => m1_to_int == m2_to_int - 1, for all m1, m2 in months.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if EssitaCBT == 1, and February == 1, and Tokamak == 1, then Essita CBT is the tokamak reactor launching in February.

### Decision variables:
-   Names of the reactors: EssitaCBT, HaramaruiLV, KuchiwaW10, RodimRexit (all different, 1 to 4)
-   Months of launch: January, February, March, April (all different, 1 to 4)
-   Types of reactors: DirectDrive, Fusor, Tokamak, ZPinch (all different, 1 to 4)

### Constraints:
-   The facility launching in March is the tokamak reactor:
    This is a direct assignment constraint:
    March == Tokamak.

-   The reactor launching in April is either the direct drive facility or the z-pinch facility:
    This is a constraint that states that the reactor launching in April is either the direct drive facility or the z-pinch facility, but not both. So:
    Xor([April == DirectDrive, April == ZPinch]).

-   Of the fusor reactor and the z-pinch facility, one will launch in February and the other is the Kuchiwa W10:
    This is a constraint that states that one of the fusor reactor and the z-pinch facility will launch in February and the other is the Kuchiwa W10. So:
    (Xor([February == Fusor, February == ZPinch]) and KuchiwaW10 == ZPinch) or (Xor([February == Fusor, February == ZPinch]) and KuchiwaW10 == Fusor).

-   The Essita CBT will launch in February:
    This is a direct assignment constraint:
    EssitaCBT == February.

-   The Haramarui LV will launch 1 month before the fusor reactor:
    For this, we will need to add a constraint for each possible assignment of the months for Haramarui LV and the fusor reactor, such that Haramarui LV's launch month is 1 less than the fusor reactor's launch month. So, the constraints will be of the form:
    m1 == HaramaruiLV and m2 == Fusor => m1_to_int == m2_to_int - 1, for all m1, m2 in months.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of name, month, and type)
# e.g. if essita == 1 and february == 1 and tokamak == 1, then Essita CBT is the tokamak reactor launching in February
essita, haramarui, kuchiwa, rodim = names = intvar(1, 4, shape=4)
january, february, march, april = months = intvar(1, 4, shape=4)
direct_drive, fusor, tokamak, z_pinch = types = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
name_to_int = None  # N/A
month_to_int = {january: 1, february: 2, march: 3, april: 4}  # in months
type_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def launched_in_month(var1, month):
    """
    Formulate the constraint that var1 is launched in a specific month.
    """
    return var1 == month


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(names)
m += AllDifferent(months)
m += AllDifferent(types)

# Clue 1: The facility launching in March is the tokamak reactor:
m += launched_in_month(tokamak, march)

# Clue 2: The reactor launching in April is either the direct drive facility or the z-pinch facility:
m += Xor([april == direct_drive, april == z_pinch])

# Clue 3: Of the fusor reactor and the z-pinch facility, one will launch in February and the other is the Kuchiwa W10:
m += ((Xor([february == fusor, february == z_pinch]) & (kuchiwa == z_pinch)) |
      (Xor([february == fusor, february == z_pinch]) & (kuchiwa == fusor)))

# Clue 4: The Essita CBT will launch in February:
m += launched_in_month(essita, february)

# Clue 5: The Haramarui LV will launch 1 month before the fusor reactor:
m += (haramarui == fusor - 1)

```
False
False
False
Wrong: 2, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Of the anniversary event and the event with 100 attendees, one will be handled by Joel and the other will be handled by Susan.
Herbert's assignment will involve 25 fewer people than Susan's assignment.
Of the assignment with 75 attendees and the assignment with 100 attendees, one will be handled by Susan and the other is the birthday.
Herbert's event is either the event with 50 attendees or the graduation job.

Entities:
people: 50, 75, 100, 125
planners: Herbert, Joel, Susan, Teresa
events: anniversary, birthday, graduation, wedding
VAR (15-32): anniversary event
VAR (41-51): event with
PARAM (52-55): 100
PARAM (172-174): 25
VAR (222-232): assignment
PARAM (238-240): 75
VAR (259-269): assignment
PARAM (275-278): 100
VAR (383-393): event with
PARAM (394-396): 50
PARAM (451-453): 50
PARAM (456-458): 75
PARAM (461-464): 100
PARAM (467-470): 125

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Herbert == 1, and 50 == 1, and anniversary == 1, then Herbert's assignment is the anniversary event with 50 attendees.

### Decision variables:
-   Types of events: Anniversary, Birthday, Graduation, Wedding (all different, 1 to 4)
-   People attending events: 50, 75, 100, 125 (all different, 1 to 4)
-   Planners: Herbert, Joel, Susan, Teresa (all different, 1 to 4)

### Constraints:
-   Of the anniversary event and the event with 100 attendees, one will be handled by Joel and the other will be handled by Susan:
    This is a constraint that states that the anniversary event and the event with 100 attendees will be handled by Joel and Susan, but not both. So:
    Xor([Anniversary == Joel, Anniversary == Susan], [Event100 == Joel, Event100 == Susan]).

-   Herbert's assignment will involve 25 fewer people than Susan's assignment:
    For this, we will need to add a constraint for each possible assignment of people attending events for Herbert and Susan, such that Herbert's event has 25 fewer people than Susan's event. So, the constraints will be of the form:
    p1 == Herbert and p2 == Susan => p1_to_int == p2_to_int - 25, for all p1, p2 in people attending events.

-   Of the assignment with 75 attendees and the assignment with 100 attendees, one will be handled by Susan and the other is the birthday:
    This is a constraint that states that the assignment with 75 attendees and the assignment with 100 attendees will be handled by Susan and the birthday event, but not both. So:
    Xor([Assignment75 == Susan, Assignment75 == Birthday], [Assignment100 == Susan, Assignment100 == Birthday]).

-   Herbert's event is either the event with 50 attendees or the graduation job:
    This is a constraint that states that Herbert's event is either the event with 50 attendees or the graduation event, but not both. So:
    Xor([Herbert == 50, Herbert == Graduation]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Herbert == 1, and 50 == 1, and anniversary == 1, then Herbert's assignment is the anniversary event with 50 attendees.

### Decision variables:
-   Types of events: Anniversary, Birthday, Graduation, Wedding (all different, 1 to 4)
-   People attending events: 50, 75, 100, 125 (all different, 1 to 4)
-   Planners: Herbert, Joel, Susan, Teresa (all different, 1 to 4)

### Constraints:
-   Of the anniversary event and the event with 100 attendees, one will be handled by Joel and the other will be handled by Susan:
    This is a constraint that states that the anniversary event and the event with 100 attendees will be handled by Joel and Susan, but not both. So:
    Xor([Anniversary == Joel, Anniversary == Susan], [Event100 == Joel, Event100 == Susan]).

-   Herbert's assignment will involve 25 fewer people than Susan's assignment:
    For this, we will need to add a constraint for each possible assignment of people attending events for Herbert and Susan, such that Herbert's event has 25 fewer people than Susan's event. So, the constraints will be of the form:
    p1 == Herbert and p2 == Susan => p1_to_int == p2_to_int - 25, for all p1, p2 in people attending events.

-   Of the assignment with 75 attendees and the assignment with 100 attendees, one will be handled by Susan and the other is the birthday:
    This is a constraint that states that the assignment with 75 attendees and the assignment with 100 attendees will be handled by Susan and the birthday event, but not both. So:
    Xor([Assignment75 == Susan, Assignment75 == Birthday], [Assignment100 == Susan, Assignment100 == Birthday]).

-   Herbert's event is either the event with 50 attendees or the graduation job:
    This is a constraint that states that Herbert's event is either the event with 50 attendees or the graduation event, but not both. So:
    Xor([Herbert == 50, Herbert == Graduation]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of event, people, and planner)
# e.g. if anniversary == 1 and 50 == 1 and herbert == 1, then the anniversary event with 50 attendees is handled by Herbert
anniversary, birthday, graduation, wedding = events = intvar(1, 4, shape=4)
people50, people75, people100, people125 = people = intvar(1, 4, shape=4)
herbert, joel, susan, teresa = planners = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
event_to_int = None  # N/A
people_to_int = {people50: 50, people75: 75, people100: 100, people125: 125}  # number of people
planner_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def fewer_people_than(var1, var2, diff):
    """
    Formulate the constraint that var1 involves diff fewer people than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(people_to_int[p1] == people_to_int[p2] - diff)
            for p1 in people for p2 in people]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(events)
m += AllDifferent(people)
m += AllDifferent(planners)

# Clue 1: Of the anniversary event and the event with 100 attendees, one will be handled by Joel and the other will be handled by Susan:
m += Xor([anniversary == joel, anniversary == susan], [people100 == joel, people100 == susan])

# Clue 2: Herbert's assignment will involve 25 fewer people than Susan's assignment:
m += fewer_people_than(herbert, susan, 25)

# Clue 3: Of the assignment with 75 attendees and the assignment with 100 attendees, one will be handled by Susan and the other is the birthday:
m += Xor([people75 == susan, people75 == birthday], [people100 == susan, people100 == birthday])

# Clue 4: Herbert's event is either the event with 50 attendees or the graduation job:
m += Xor([herbert == people50, herbert == graduation])

```
Error: invalid syntax (<string>, line 1)
False
False
Error: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
D. forcilitis has 500 genes.
B. mangeris was either the one sequenced by Dr. Ortiz or the organism with 750 genes.
The organism sequenced by Dr. Trujillo has 500 more genes than the bacteria sequenced by Dr. Nielsen.
Of the bacteria sequenced by Dr. Jordan and the bacteria sequenced by Dr. Trujillo, one has 1000 genes and the other is E. carolinus.

Entities:
genes: 250, 500, 750, 1000
bacteria: B. mangeris, D. forcilitis, E. carolinus, P. wellington
doctors: Jordan, Nielsen, Ortiz, Trujillo
PARAM (26-29): 500
VAR (38-49): B. mangeris
PARAM (113-116): 750
PARAM (168-171): 500
CONST_DIR (172-176): more
VAR (302-310): Trujillo
PARAM (321-325): 1000
PARAM (383-386): 250
PARAM (389-392): 500
PARAM (395-398): 750
PARAM (401-405): 1000
VAR (417-428): B. mangeris

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Dforcilitis == 1, and 500 == 1, and Jordan == 1, then D. forcilitis has 500 genes and was sequenced by Dr. Jordan.

### Decision variables:
-   Names of the bacteria: Bmangeris, Dforcilitis, Ecarolinus, Pwellington (all different, 1 to 4)
-   Number of genes: 250, 500, 750, 1000 (all different, 1 to 4)
-   Names of the doctors: Jordan, Nielsen, Ortiz, Trujillo (all different, 1 to 4)

### Constraints:
-   D. forcilitis has 500 genes:
    This is a direct assignment constraint:
    Dforcilitis == 500.

-   B. mangeris was either the one sequenced by Dr. Ortiz or the organism with 750 genes:
    This is a constraint that states that B. mangeris was either sequenced by Dr. Ortiz or has 750 genes, but not both. So:
    Xor([Bmangeris == Ortiz, Bmangeris == 750]).

-   The organism sequenced by Dr. Trujillo has 500 more genes than the bacteria sequenced by Dr. Nielsen:
    For this, we will need to add a constraint for each possible assignment of the number of genes for the organism sequenced by Dr. Trujillo and the bacteria sequenced by Dr. Nielsen, such that the organism sequenced by Dr. Trujillo has 500 more genes than the bacteria sequenced by Dr. Nielsen. So, the constraints will be of the form:
    g1 == Trujillo and g2 == Nielsen => g1_to_int == g2_to_int + 500, for all g1, g2 in number of genes.

-   Of the bacteria sequenced by Dr. Jordan and the bacteria sequenced by Dr. Trujillo, one has 1000 genes and the other is E. carolinus:
    This is a constraint that states that one of the bacteria sequenced by Dr. Jordan and Dr. Trujillo has 1000 genes, and the other is E. carolinus. So, we will need to add constraints to ensure this condition is met.

-   Additional constraints to ensure uniqueness and consistency of the assignments will be needed based on the given information.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Dforcilitis == 1, and 500 == 1, and Jordan == 1, then D. forcilitis has 500 genes and was sequenced by Dr. Jordan.

### Decision variables:
-   Names of the bacteria: Bmangeris, Dforcilitis, Ecarolinus, Pwellington (all different, 1 to 4)
-   Number of genes: 250, 500, 750, 1000 (all different, 1 to 4)
-   Names of the doctors: Jordan, Nielsen, Ortiz, Trujillo (all different, 1 to 4)

### Constraints:
-   D. forcilitis has 500 genes:
    This is a direct assignment constraint:
    Dforcilitis == 500.

-   B. mangeris was either the one sequenced by Dr. Ortiz or the organism with 750 genes:
    This is a constraint that states that B. mangeris was either sequenced by Dr. Ortiz or has 750 genes, but not both. So:
    Xor([Bmangeris == Ortiz, Bmangeris == 750]).

-   The organism sequenced by Dr. Trujillo has 500 more genes than the bacteria sequenced by Dr. Nielsen:
    For this, we will need to add a constraint for each possible assignment of the number of genes for the organism sequenced by Dr. Trujillo and the bacteria sequenced by Dr. Nielsen, such that the organism sequenced by Dr. Trujillo has 500 more genes than the bacteria sequenced by Dr. Nielsen. So, the constraints will be of the form:
    g1 == Trujillo and g2 == Nielsen => g1_to_int == g2_to_int + 500, for all g1, g2 in number of genes.

-   Of the bacteria sequenced by Dr. Jordan and the bacteria sequenced by Dr. Trujillo, one has 1000 genes and the other is E. carolinus:
    This is a constraint that states that one of the bacteria sequenced by Dr. Jordan and Dr. Trujillo has 1000 genes, and the other is E. carolinus. So, we will need to add constraints to ensure this condition is met.

-   Additional constraints to ensure uniqueness and consistency of the assignments will be needed based on the given information.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of bacteria, genes, and doctor)
# e.g. if bmangeris == 1 and genes500 == 1 and ortiz == 1, then B. mangeris has 500 genes and was sequenced by Dr. Ortiz
bmangeris, dforcilitis, ecarolinus, pwellington = bacteria = intvar(1, 4, shape=4)
genes250, genes500, genes750, genes1000 = genes = intvar(1, 4, shape=4)
jordan, nielsen, ortiz, trujillo = doctors = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
bacteria_to_int = None  # N/A
genes_to_int = {genes250: 250, genes500: 500, genes750: 750, genes1000: 1000}  # in number of genes
doctor_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def more_genes(var1, var2, diff):
    """
    Formulate the constraint that var1 has diff more genes than var2.
    """
    return [((g1 == var1) & (g2 == var2)).implies(genes_to_int[g1] == genes_to_int[g2] + diff)
            for g1 in genes for g2 in genes]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(bacteria)
m += AllDifferent(genes)
m += AllDifferent(doctors)

# Clue 1: D. forcilitis has 500 genes:
m += dforcilitis == genes500

# Clue 2: B. mangeris was either the one sequenced by Dr. Ortiz or the organism with 750 genes:
m += Xor([bmangeris == ortiz, bmangeris == genes750])

# Clue 3: The organism sequenced by Dr. Trujillo has 500 more genes than the bacteria sequenced by Dr. Nielsen:
m += more_genes(trujillo, nielsen, 500)

# Clue 4: Of the bacteria sequenced by Dr. Jordan and the bacteria sequenced by Dr. Trujillo,
# one has 1000 genes and the other is E. carolinus:
m += (jordan == genes1000) & (trujillo == ecarolinus) | (jordan == ecarolinus) & (trujillo == genes1000)

# Additional constraints to ensure uniqueness and consistency of the assignments will be needed based on the given information.

```
True
True
True
Wrong: 1, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The mountain that is 210 feet tall was climbed by Leonard Lara.
Of Mt. Brewer and Mt. Quinn, one was climbed by Ben Beasley and the other is 470 feet tall.
Mt. Brewer is either the mountain summited by Leonard Lara or the peak that is 600 feet tall.
Mt. York was climbed by Kermit Kramer.

Entities:
heights: 210, 340, 470, 600
mountains: Mt. Brewer, Mt. Gillespie, Mt. Quinn, Mt. York
climbers: Ben Beasley, Eddie English, Kermit Kramer, Leonard Lara
PARAM (29-32): 210
VAR (76-86): Mt. Brewer
VAR (91-100): Mt. Quinn
PARAM (151-154): 470
VAR (167-177): Mt. Brewer
PARAM (246-249): 600
VAR (262-270): Mt. York
PARAM (323-326): 210
PARAM (329-332): 340
PARAM (335-338): 470
PARAM (341-344): 600
VAR (357-367): Mt. Brewer
VAR (386-395): Mt. Quinn
VAR (398-406): Mt. York

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if BenBeasley == 1, and MtBrewer == 1, and Height470 == 1, then Ben Beasley climbed Mt. Brewer, which is 470 feet tall.

### Decision variables:
-   Heights of the mountains: Height210, Height340, Height470, Height600 (all different, 1 to 4)
-   Names of the mountains: MtBrewer, MtGillespie, MtQuinn, MtYork (all different, 1 to 4)
-   Names of the climbers: BenBeasley, EddieEnglish, KermitKramer, LeonardLara (all different, 1 to 4)

### Constraints:
-   The mountain that is 210 feet tall was climbed by Leonard Lara:
    This is a direct assignment constraint:
    Height210 == LeonardLara.

-   Of Mt. Brewer and Mt. Quinn, one was climbed by Ben Beasley and the other is 470 feet tall:
    This is a constraint that states that one of Mt. Brewer or Mt. Quinn was climbed by Ben Beasley and the other is 470 feet tall. So, we can represent this as:
    (MtBrewer == BenBeasley and Height470 == MtQuinn) or (MtQuinn == BenBeasley and Height470 == MtBrewer).

-   Mt. Brewer is either the mountain summited by Leonard Lara or the peak that is 600 feet tall:
    This is a constraint that states that Mt. Brewer is either climbed by Leonard Lara or is 600 feet tall, but not both. So:
    Xor([MtBrewer == LeonardLara, MtBrewer == Height600]).

-   Mt. York was climbed by Kermit Kramer:
    This is a direct assignment constraint:
    MtYork == KermitKramer.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if BenBeasley == 1, and MtBrewer == 1, and Height470 == 1, then Ben Beasley climbed Mt. Brewer, which is 470 feet tall.

### Decision variables:
-   Heights of the mountains: Height210, Height340, Height470, Height600 (all different, 1 to 4)
-   Names of the mountains: MtBrewer, MtGillespie, MtQuinn, MtYork (all different, 1 to 4)
-   Names of the climbers: BenBeasley, EddieEnglish, KermitKramer, LeonardLara (all different, 1 to 4)

### Constraints:
-   The mountain that is 210 feet tall was climbed by Leonard Lara:
    This is a direct assignment constraint:
    Height210 == LeonardLara.

-   Of Mt. Brewer and Mt. Quinn, one was climbed by Ben Beasley and the other is 470 feet tall:
    This is a constraint that states that one of Mt. Brewer or Mt. Quinn was climbed by Ben Beasley and the other is 470 feet tall. So, we can represent this as:
    (MtBrewer == BenBeasley and Height470 == MtQuinn) or (MtQuinn == BenBeasley and Height470 == MtBrewer).

-   Mt. Brewer is either the mountain summited by Leonard Lara or the peak that is 600 feet tall:
    This is a constraint that states that Mt. Brewer is either climbed by Leonard Lara or is 600 feet tall, but not both. So:
    Xor([MtBrewer == LeonardLara, MtBrewer == Height600]).

-   Mt. York was climbed by Kermit Kramer:
    This is a direct assignment constraint:
    MtYork == KermitKramer.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of height, mountain, and climber)
# e.g. if height210 == 1 and mtBrewer == 1 and leonard == 1, then Leonard Lara climbed Mt. Brewer, which is 210 feet tall
height210, height340, height470, height600 = heights = intvar(1, 4, shape=4)
mtBrewer, mtGillespie, mtQuinn, mtYork = mountains = intvar(1, 4, shape=4)
ben, eddie, kermit, leonard = climbers = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
height_to_int = {height210: 210, height340: 340, height470: 470, height600: 600}  # in feet
mountain_to_int = None  # N/A
climber_to_int = None  # N/A


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(heights)
m += AllDifferent(mountains)
m += AllDifferent(climbers)

# Clue 1: The mountain that is 210 feet tall was climbed by Leonard Lara:
m += height210 == leonard

# Clue 2: Of Mt. Brewer and Mt. Quinn, one was climbed by Ben Beasley and the other is 470 feet tall:
m += ((mtBrewer == ben) & (height470 == mtQuinn)) | ((mtQuinn == ben) & (height470 == mtBrewer))

# Clue 3: Mt. Brewer is either the mountain summited by Leonard Lara or the peak that is 600 feet tall:
m += Xor([mtBrewer == leonard, mtBrewer == height600])

# Clue 4: Mt. York was climbed by Kermit Kramer:
m += mtYork == kermit

```
True
True
True
Wrong: 1, Total: 7
---------------------------------------------------------------------------------------------

Clues:
Opie Oliver's card came out in 2012.
The piece that sold for $175 came out in 1999.
Of the 2012 card and the 1987 item, one featured Mike Morales and the other sold for $275.
Neddy Norris's item sold for 50 dollars more than the 1987 card.

Entities:
prices: $125, $175, $225, $275
players: Finn Freeman, Mike Morales, Neddy Norris, Opie Oliver
years: 1974, 1987, 1999, 2012
PARAM (40-44): 2012
PARAM (73-76): 175
PARAM (89-93): 1999
VAR (103-112): 2012 card
VAR (121-130): 1987 item
PARAM (184-187): 275
VAR (190-195): Neddy
PARAM (220-222): 50
CONST_DIR (231-235): more
VAR (245-254): 1987 card
OBJ_NAME (268-274): prices
PARAM (279-282): 125
PARAM (287-290): 175
PARAM (295-298): 225
PARAM (303-306): 275
PARAM (382-386): 1974
PARAM (389-393): 1987
PARAM (396-400): 1999
PARAM (403-407): 2012

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if FinnFreeman == 1, and 1974 == 1, and Price125 == 1, then Finn Freeman's item from 1974 was sold for $125.

### Decision variables:
-   Prices of the items: $125, $175, $225, $275 (all different, 1 to 4)
-   Players associated with the items: FinnFreeman, MikeMorales, NeddyNorris, OpieOliver (all different, 1 to 4)
-   Years of the items: 1974, 1987, 1999, 2012 (all different, 1 to 4)
-   Types of the items: 1974 card, 1987 item, 1999 piece, 2012 card (all different, 1 to 4)

### Constraints:
-   Opie Oliver's card came out in 2012:
    This is a direct assignment constraint:
    OpieOliver == 2012 card.

-   The piece that sold for $175 came out in 1999:
    This is a direct assignment constraint:
    Price175 == 1999 piece.

-   Of the 2012 card and the 1987 item, one featured Mike Morales and the other sold for $275:
    This is a constraint that states that one of the items is associated with Mike Morales and sold for $275, while the other is not. So:
    Xor([2012 card == MikeMorales and Price275 == 1987 item, 2012 card == Price275 and 1987 item == MikeMorales]).

-   Neddy Norris's item sold for 50 dollars more than the 1987 card:
    For this, we will need to add a constraint for each possible assignment of prices for Neddy Norris's item and the 1987 card, such that Neddy Norris's item price is 50 more than the 1987 card's price. So, the constraints will be of the form:
    p1 == Neddy and p2 == 1987 card => p1_to_int == p2_to_int + 50, for all p1, p2 in prices.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if FinnFreeman == 1, and 1974 == 1, and Price125 == 1, then Finn Freeman's item from 1974 was sold for $125.

### Decision variables:
-   Prices of the items: $125, $175, $225, $275 (all different, 1 to 4)
-   Players associated with the items: FinnFreeman, MikeMorales, NeddyNorris, OpieOliver (all different, 1 to 4)
-   Years of the items: 1974, 1987, 1999, 2012 (all different, 1 to 4)
-   Types of the items: 1974 card, 1987 item, 1999 piece, 2012 card (all different, 1 to 4)

### Constraints:
-   Opie Oliver's card came out in 2012:
    This is a direct assignment constraint:
    OpieOliver == 2012 card.

-   The piece that sold for $175 came out in 1999:
    This is a direct assignment constraint:
    Price175 == 1999 piece.

-   Of the 2012 card and the 1987 item, one featured Mike Morales and the other sold for $275:
    This is a constraint that states that one of the items is associated with Mike Morales and sold for $275, while the other is not. So:
    Xor([2012 card == MikeMorales and Price275 == 1987 item, 2012 card == Price275 and 1987 item == MikeMorales]).

-   Neddy Norris's item sold for 50 dollars more than the 1987 card:
    For this, we will need to add a constraint for each possible assignment of prices for Neddy Norris's item and the 1987 card, such that Neddy Norris's item price is 50 more than the 1987 card's price. So, the constraints will be of the form:
    p1 == Neddy and p2 == 1987 card => p1_to_int == p2_to_int + 50, for all p1, p2 in prices.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of player, year, and price)
# e.g. if finn == 1 and year1974 == 1 and price125 == 1, then Finn Freeman's item from 1974 was sold for $125
finn, mike, neddy, opie = players = intvar(1, 4, shape=4)
year1974, year1987, year1999, year2012 = years = intvar(1, 4, shape=4)
price125, price175, price225, price275 = prices = intvar(1, 4, shape=4)
card1974, item1987, piece1999, card2012 = types = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
player_to_int = None  # N/A
year_to_int = {year1974: 1974, year1987: 1987, year1999: 1999, year2012: 2012}  # in years
price_to_int = {price125: 125, price175: 175, price225: 225, price275: 275}  # in dollars
type_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def sold_more_than(var1, var2):
    """
    Formulate the constraint that var1 sold for more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] > price_to_int[p2])
            for p1 in prices for p2 in prices]


def sold_exactly_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 sold for exactly diff dollars more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] + diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(players)
m += AllDifferent(years)
m += AllDifferent(prices)
m += AllDifferent(types)

# Clue 1: Opie Oliver's card came out in 2012:
m += opie == card2012

# Clue 2: The piece that sold for $175 came out in 1999:
m += price175 == piece1999

# Clue 3: Of the 2012 card and the 1987 item, one featured Mike Morales and the other sold for $275:
m += Xor([card2012 == mike and price275 == item1987, card2012 == price275 and item1987 == mike])

# Clue 4: Neddy Norris's item sold for 50 dollars more than the 1987 card:
m += sold_exactly_more_than(neddy, item1987, 50)

```
False
True
False
Wrong: 7, Total: 7
---------------------------------------------------------------------------------------------

Clues:
Of Nelson and the cook who scored 63 points, one made the lemon snapper and the other made the cajun chili.
Of the chef who scored 42 points and the cook who scored 63 points, one made the cashew tofu and the other was Rosalie.
Karl scored 7 more points than the person who made the lemon snapper.

Entities:
scores: 42, 49, 56, 63
chefs: Karl, Nelson, Peggy, Rosalie
dishes: cajun chili, cashew tofu, lemon snapper, smoked pork
VAR (26-30): cook
PARAM (42-44): 63
OBJ_NAME (45-51): points
VAR (67-80): lemon snapper
VAR (125-129): chef
PARAM (141-143): 42
OBJ_NAME (144-150): points
VAR (159-163): cook
PARAM (175-177): 63
OBJ_NAME (178-184): points
PARAM (252-253): 7
OBJ_NAME (259-265): points
VAR (295-308): lemon snapper
PARAM (331-333): 42
PARAM (336-338): 49
PARAM (341-343): 56
PARAM (346-348): 63

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Karl == 1, and 42 == 1, and LemonSnapper == 1, then Karl scored 42 points for making the lemon snapper.

### Decision variables:
-   Names of the chefs: Karl, Nelson, Peggy, Rosalie (all different, 1 to 4)
-   Scores: 42, 49, 56, 63 (all different, 1 to 4)
-   Dishes: CajunChili, CashewTofu, LemonSnapper, SmokedPork (all different, 1 to 4)

### Constraints:
-   Of Nelson and the cook who scored 63 points, one made the lemon snapper and the other made the cajun chili:
    This is a constraint that states that one of Nelson and the cook who scored 63 points made the lemon snapper and the other made the cajun chili. So, we need to add constraints to ensure this:
    (Nelson == LemonSnapper and Cook63 == CajunChili) or (Nelson == CajunChili and Cook63 == LemonSnapper).

-   Of the chef who scored 42 points and the cook who scored 63 points, one made the cashew tofu and the other was Rosalie:
    This is a constraint that states that one of the chef who scored 42 points made the cashew tofu and the other was Rosalie. So, we need to add constraints to ensure this:
    (Chef42 == CashewTofu and Cook63 == Rosalie) or (Chef42 == Rosalie and Cook63 == CashewTofu).

-   Karl scored 7 more points than the person who made the lemon snapper:
    For this, we will need to add a constraint for each possible assignment of scores for Karl and the person who made the lemon snapper, such that Karl's score is 7 more than the lemon snapper maker's score. So, the constraints will be of the form:
    s1 == Karl and s2 == LemonSnapper => s1_to_int == s2_to_int + 7, for all s1, s2 in scores.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Karl == 1, and 42 == 1, and LemonSnapper == 1, then Karl scored 42 points for making the lemon snapper.

### Decision variables:
-   Names of the chefs: Karl, Nelson, Peggy, Rosalie (all different, 1 to 4)
-   Scores: 42, 49, 56, 63 (all different, 1 to 4)
-   Dishes: CajunChili, CashewTofu, LemonSnapper, SmokedPork (all different, 1 to 4)

### Constraints:
-   Of Nelson and the cook who scored 63 points, one made the lemon snapper and the other made the cajun chili:
    This is a constraint that states that one of Nelson and the cook who scored 63 points made the lemon snapper and the other made the cajun chili. So, we need to add constraints to ensure this:
    (Nelson == LemonSnapper and Cook63 == CajunChili) or (Nelson == CajunChili and Cook63 == LemonSnapper).

-   Of the chef who scored 42 points and the cook who scored 63 points, one made the cashew tofu and the other was Rosalie:
    This is a constraint that states that one of the chef who scored 42 points made the cashew tofu and the other was Rosalie. So, we need to add constraints to ensure this:
    (Chef42 == CashewTofu and Cook63 == Rosalie) or (Chef42 == Rosalie and Cook63 == CashewTofu).

-   Karl scored 7 more points than the person who made the lemon snapper:
    For this, we will need to add a constraint for each possible assignment of scores for Karl and the person who made the lemon snapper, such that Karl's score is 7 more than the lemon snapper maker's score. So, the constraints will be of the form:
    s1 == Karl and s2 == LemonSnapper => s1_to_int == s2_to_int + 7, for all s1, s2 in scores.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of chef, score, and dish)
# e.g. if karl == 1 and 42 == 1 and lemon_snapper == 1, then Karl scored 42 points for making the lemon snapper
karl, nelson, peggy, rosalie = chefs = intvar(1, 4, shape=4)
score42, score49, score56, score63 = scores = intvar(1, 4, shape=4)
cajun_chili, cashew_tofu, lemon_snapper, smoked_pork = dishes = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
chef_to_int = None  # N/A
score_to_int = {score42: 42, score49: 49, score56: 56, score63: 63}  # in points
dish_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def made_different_dishes(var1, var2, dish1, dish2):
    """
    Formulate the constraint that var1 and var2 made different dishes.
    """
    return [(var1 == dish1) & (var2 == dish2) | (var1 == dish2) & (var2 == dish1)
            for dish1 in dishes for dish2 in dishes]


def made_different_people(var1, var2, person1, person2):
    """
    Formulate the constraint that var1 and var2 were made by different people.
    """
    return [(var1 == person1) & (var2 == person2) | (var1 == person2) & (var2 == person1)
            for person1 in chefs for person2 in chefs]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(chefs)
m += AllDifferent(scores)
m += AllDifferent(dishes)

# Clue 1: Of Nelson and the cook who scored 63 points, one made the lemon snapper and the other made the cajun chili:
m += made_different_dishes(nelson, score63, lemon_snapper, cajun_chili)

# Clue 2: Of the chef who scored 42 points and the cook who scored 63 points, one made the cashew tofu and the other was Rosalie:
m += made_different_people(score42, score63, cashew_tofu, rosalie)

# Clue 3: Karl scored 7 more points than the person who made the lemon snapper:
m += [(karl == lemon_snapper) & (score_to_int[karl] == score_to_int[lemon_snapper] + 7)]

```
Error: name 'IV1480' is not defined
False
False
Error: name 'IV1504' is not defined
---------------------------------------------------------------------------------------------

Clues:
Alejandro's purchase cost less than Irma's purchase.
The insect that sold for $90 was either the atlas butterfly or the emperor butterfly.
The peacock butterfly cost more than Irma's purchase.
Of Alejandro's purchase and Irma's purchase, one was the emperor butterfly and the other sold for $45.
The four butterflies were Phillip's purchase, the insect that sold for $60, the butterfly that sold for $45 and the butterfly that sold for $90.

Entities:
prices: $45, $60, $75, $90
winners: Alejandro, Faye, Irma, Phillip
butterflies: atlas, emperor, grayling, peacock
VAR (8-29): Alejandro 's purchase
VAR (45-49): Irma
VAR (53-61): purchase
VAR (68-74): insect
OBJ_NAME (80-84): sold
PARAM (91-93): 90
VAR (109-124): atlas butterfly
VAR (132-149): emperor butterfly
VAR (156-173): peacock butterfly
PARAM (179-183): more
VAR (189-205): Irma 's purchase
VAR (211-220): Alejandro
VAR (224-232): purchase
VAR (237-253): Irma 's purchase
VAR (268-285): emperor butterfly
OBJ_NAME (300-304): sold
PARAM (311-313): 45
VAR (342-349): Phillip
VAR (368-374): insect
OBJ_NAME (380-384): sold
PARAM (391-393): 60
VAR (400-409): butterfly
OBJ_NAME (415-419): sold
PARAM (426-428): 45
VAR (437-446): butterfly
OBJ_NAME (452-456): sold
PARAM (463-465): 90
PARAM (490-492): 45
PARAM (497-499): 60
PARAM (504-506): 75
PARAM (511-513): 90
OBJ_NAME (514-521): winners
VAR (524-533): Alejandro
VAR (550-569): Phillip butterflies
VAR (601-608): peacock

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Alejandro == 1, and $45 == 1, and atlas == 1, then Alejandro's purchase was the atlas butterfly that sold for $45.

### Decision variables:
-   Names of the winners: Alejandro, Faye, Irma, Phillip (all different, 1 to 4)
-   Prices of the purchases: $45, $60, $75, $90 (all different, 1 to 4)
-   Types of butterflies: atlas, emperor, grayling, peacock (all different, 1 to 4)

### Constraints:
-   Alejandro's purchase cost less than Irma's purchase:
    For this, we will need to add a constraint for each possible assignment of prices for Alejandro's and Irma's purchases, such that Alejandro's purchase price is less than Irma's purchase price. So, the constraints will be of the form:
    p1 == Alejandro and p2 == Irma => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   The insect that sold for $90 was either the atlas butterfly or the emperor butterfly:
    This is a constraint that states that the insect that sold for $90 is either the atlas butterfly or the emperor butterfly, but not both. So:
    Xor([atlas == $90, emperor == $90]).

-   The peacock butterfly cost more than Irma's purchase:
    For this, we will need to add a constraint for each possible assignment of prices for the peacock butterfly and Irma's purchase, such that the peacock butterfly's price is greater than Irma's purchase price. So, the constraints will be of the form:
    p1 == peacock and p2 == Irma => p1_to_int > p2_to_int, for all p1, p2 in prices.

-   Of Alejandro's purchase and Irma's purchase, one was the emperor butterfly and the other sold for $45:
    This is a constraint that states that one of Alejandro's purchase and Irma's purchase is the emperor butterfly and the other sold for $45. So:
    Xor([Alejandro == emperor and $45 == Irma, Alejandro == $45 and emperor == Irma]).

-   The four butterflies were Phillip's purchase, the insect that sold for $60, the butterfly that sold for $45, and the butterfly that sold for $90:
    This is a constraint that states that the four butterflies are Phillip's purchase, the insect that sold for $60, the butterfly that sold for $45, and the butterfly that sold for $90. So:
    AllDifferent([Phillip, $60, $45, $90]).

-   Additional constraints:
    -   Alejandro's purchase is the atlas butterfly: Alejandro == atlas.
    -   Phillip's purchases are the butterflies: Phillip == butterflies.
    -   The peacock butterfly is the peacock type: peacock == peacock.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Alejandro == 1, and $45 == 1, and atlas == 1, then Alejandro's purchase was the atlas butterfly that sold for $45.

### Decision variables:
-   Names of the winners: Alejandro, Faye, Irma, Phillip (all different, 1 to 4)
-   Prices of the purchases: $45, $60, $75, $90 (all different, 1 to 4)
-   Types of butterflies: atlas, emperor, grayling, peacock (all different, 1 to 4)

### Constraints:
-   Alejandro's purchase cost less than Irma's purchase:
    For this, we will need to add a constraint for each possible assignment of prices for Alejandro's and Irma's purchases, such that Alejandro's purchase price is less than Irma's purchase price. So, the constraints will be of the form:
    p1 == Alejandro and p2 == Irma => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   The insect that sold for $90 was either the atlas butterfly or the emperor butterfly:
    This is a constraint that states that the insect that sold for $90 is either the atlas butterfly or the emperor butterfly, but not both. So:
    Xor([atlas == $90, emperor == $90]).

-   The peacock butterfly cost more than Irma's purchase:
    For this, we will need to add a constraint for each possible assignment of prices for the peacock butterfly and Irma's purchase, such that the peacock butterfly's price is greater than Irma's purchase price. So, the constraints will be of the form:
    p1 == peacock and p2 == Irma => p1_to_int > p2_to_int, for all p1, p2 in prices.

-   Of Alejandro's purchase and Irma's purchase, one was the emperor butterfly and the other sold for $45:
    This is a constraint that states that one of Alejandro's purchase and Irma's purchase is the emperor butterfly and the other sold for $45. So:
    Xor([Alejandro == emperor and $45 == Irma, Alejandro == $45 and emperor == Irma]).

-   The four butterflies were Phillip's purchase, the insect that sold for $60, the butterfly that sold for $45, and the butterfly that sold for $90:
    This is a constraint that states that the four butterflies are Phillip's purchase, the insect that sold for $60, the butterfly that sold for $45, and the butterfly that sold for $90. So:
    AllDifferent([Phillip, $60, $45, $90]).

-   Additional constraints:
    -   Alejandro's purchase is the atlas butterfly: Alejandro == atlas.
    -   Phillip's purchases are the butterflies: Phillip == butterflies.
    -   The peacock butterfly is the peacock type: peacock == peacock.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of winner, price, and butterfly)
# e.g. if alejandro == 1 and price45 == 1 and atlas == 1, then Alejandro's purchase was the atlas butterfly that sold for $45
alejandro, faye, irma, phillip = winners = intvar(1, 4, shape=4)
price45, price60, price75, price90 = prices = intvar(1, 4, shape=4)
atlas, emperor, grayling, peacock = butterflies = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
winner_to_int = None  # N/A
price_to_int = {price45: 45, price60: 60, price75: 75, price90: 90}  # in dollars
butterfly_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def cost_less_than(var1, var2):
    """
    Formulate the constraint that var1 cost less than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] < price_to_int[p2])
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(winners)
m += AllDifferent(prices)
m += AllDifferent(butterflies)

# Clue 1: Alejandro's purchase cost less than Irma's purchase:
m += cost_less_than(alejandro, irma)

# Clue 2: The insect that sold for $90 was either the atlas butterfly or the emperor butterfly:
m += Xor([atlas == price90, emperor == price90])

# Clue 3: The peacock butterfly cost more than Irma's purchase:
m += cost_less_than(peacock, irma)

# Clue 4: Of Alejandro's purchase and Irma's purchase, one was the emperor butterfly and the other sold for $45:
m += Xor([alejandro == emperor, irma == price45])

# Clue 5: The four butterflies were Phillip's purchase, the insect that sold for $60, the butterfly that sold for $45, and the butterfly that sold for $90:
m += AllDifferent([phillip, price60, price45, price90])

# Additional constraints
m += alejandro == atlas
m += phillip == butterflies
m += peacock == peacock

```
Error: invalid syntax (<string>, line 1)
False
False
Error: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
The athlete who traveled for 195 days started from Pescadero.
Of Dana and the athlete who traveled for 184 days, one started from Cayucos and the other started from Bodega Bay .
Hilda finished in 217 days .
Walter finished 11 days before the athlete who started from Cayucos.

Entities:
durations: 184 days, 195 days, 206 days, 217 days
rowers: Antonio, Dana, Hilda, Walter
start points: Bodega Bay, Cayucos, Pescadero, Pismo Beach
LIMIT (37-40): 195
VAR (59-68): Pescadero
LIMIT (112-115): 184
VAR (140-147): Cayucos
VAR (175-185): Bodega Bay
PARAM (206-209): 217
PARAM (233-235): 11
VAR (277-284): Cayucos
PARAM (310-313): 184
PARAM (321-324): 195
PARAM (332-335): 206
PARAM (343-346): 217
VAR (408-418): Bodega Bay
VAR (421-428): Cayucos
VAR (431-440): Pescadero
OBJ_NAME (443-448): Pismo

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Antonio == 1, and 184Days == 1, and Pescadero == 1, then Antonio traveled for 184 days starting from Pescadero.

### Decision variables:
-   Durations of travel: 184 days, 195 days, 206 days, 217 days (all different, 1 to 4)
-   Names of the rowers: Antonio, Dana, Hilda, Walter (all different, 1 to 4)
-   Starting points: Bodega Bay, Cayucos, Pescadero, Pismo Beach (all different, 1 to 4)

### Constraints:
-   The athlete who traveled for 195 days started from Pescadero:
    This is a direct assignment constraint:
    195Days == Pescadero.

-   Of Dana and the athlete who traveled for 184 days, one started from Cayucos and the other started from Bodega Bay:
    This is a constraint that states that Dana and the athlete who traveled for 184 days started from different locations. So:
    Xor([Dana == Cayucos, Dana == BodegaBay]).

-   Hilda finished in 217 days:
    This is a direct assignment constraint:
    Hilda == 217Days.

-   Walter finished 11 days before the athlete who started from Cayucos:
    For this, we will need to add a constraint for each possible assignment of durations for Walter and the athlete who started from Cayucos, such that Walter's duration is 11 less than the Cayucos athlete's duration. So, the constraints will be of the form:
    d1 == Walter and d2 == Cayucos => d1_to_int == d2_to_int - 11, for all d1, d2 in durations.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Antonio == 1, and 184Days == 1, and Pescadero == 1, then Antonio traveled for 184 days starting from Pescadero.

### Decision variables:
-   Durations of travel: 184 days, 195 days, 206 days, 217 days (all different, 1 to 4)
-   Names of the rowers: Antonio, Dana, Hilda, Walter (all different, 1 to 4)
-   Starting points: Bodega Bay, Cayucos, Pescadero, Pismo Beach (all different, 1 to 4)

### Constraints:
-   The athlete who traveled for 195 days started from Pescadero:
    This is a direct assignment constraint:
    195Days == Pescadero.

-   Of Dana and the athlete who traveled for 184 days, one started from Cayucos and the other started from Bodega Bay:
    This is a constraint that states that Dana and the athlete who traveled for 184 days started from different locations. So:
    Xor([Dana == Cayucos, Dana == BodegaBay]).

-   Hilda finished in 217 days:
    This is a direct assignment constraint:
    Hilda == 217Days.

-   Walter finished 11 days before the athlete who started from Cayucos:
    For this, we will need to add a constraint for each possible assignment of durations for Walter and the athlete who started from Cayucos, such that Walter's duration is 11 less than the Cayucos athlete's duration. So, the constraints will be of the form:
    d1 == Walter and d2 == Cayucos => d1_to_int == d2_to_int - 11, for all d1, d2 in durations.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of duration, rower, and start point)
# e.g. if antonio == 1 and days184 == 1 and pescadero == 1, then Antonio traveled for 184 days starting from Pescadero
antonio, dana, hilda, walter = rowers = intvar(1, 4, shape=4)
days184, days195, days206, days217 = durations = intvar(1, 4, shape=4)
bodega_bay, cayucos, pescadero, pismo_beach = start_points = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
rower_to_int = None  # N/A
duration_to_int = {days184: 184, days195: 195, days206: 206, days217: 217}  # in days
start_point_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def finished_before_than(var1, var2, diff):
    """
    Formulate the constraint that var1 finished diff days before var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(duration_to_int[d1] == duration_to_int[d2] - diff)
            for d1 in durations for d2 in durations]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(rowers)
m += AllDifferent(durations)
m += AllDifferent(start_points)

# Clue 1: The athlete who traveled for 195 days started from Pescadero:
m += days195 == pescadero

# Clue 2: Of Dana and the athlete who traveled for 184 days, one started from Cayucos and the other started from Bodega Bay:
m += Xor([dana == cayucos, dana == bodega_bay])

# Clue 3: Hilda finished in 217 days:
m += hilda == days217

# Clue 4: Walter finished 11 days before the athlete who started from Cayucos:
m += finished_before_than(walter, cayucos, 11)

```
False
True
False
Wrong: 1, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The movie that grossed 5 million was directed by Kenneth Key.
Of What a World and Amerigo, one made 2 million and the other was directed by Jim Johnson.
The film directed by Kenneth Key made 3 million less than Amerigo.
Fast and Dead was directed by Kenneth Key.
Let Me Out is either the movie directed by Linda Lynch or the movie that grossed 5 million.

Entities:
earnings: 2 million, 5 million, 8 million, 11 million
movies: Amerigo, Fast and Dead, Let Me Out, What a World
directors: Jim Johnson, Kenneth Key, Linda Lynch, Micah Moreno
OBJ_NAME (23-30): grossed
PARAM (31-32): 5
VAR (91-98): Amerigo
PARAM (110-111): 2
PARAM (202-203): 3
CONST_DIR (212-216): less
VAR (222-229): Amerigo
VAR (232-245): Fast and Dead
VAR (276-286): Let Me Out
OBJ_NAME (349-356): grossed
PARAM (357-358): 5
OBJ_NAME (380-388): earnings
PARAM (391-392): 2
PARAM (403-404): 5
PARAM (415-416): 8
PARAM (427-429): 11
VAR (447-454): Amerigo
VAR (457-465): Fast and
VAR (473-476): Let

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Amerigo == 1, and 2M == 1, and JimJohnson == 1, then the movie Amerigo grossed 2 million and was directed by Jim Johnson.

### Decision variables:
-   Movies: Amerigo, FastAndDead, LetMeOut, WhatAWorld (all different, 1 to 4)
-   Earnings: 2 million, 5 million, 8 million, 11 million (all different, 1 to 4)
-   Directors: JimJohnson, KennethKey, LindaLynch, MicahMoreno (all different, 1 to 4)

### Constraints:
-   The movie that grossed 5 million was directed by Kenneth Key:
    This is a direct assignment constraint:
    KennethKey == 5M.

-   Of What a World and Amerigo, one made 2 million and the other was directed by Jim Johnson:
    This is a constraint that states that one of the movies made 2 million and the other was directed by Jim Johnson. So, we can represent this as:
    Xor([WhatAWorld == 2M, WhatAWorld == JimJohnson]).

-   The film directed by Kenneth Key made 3 million less than Amerigo:
    For this, we will need to add a constraint for each possible assignment of earnings for the film directed by Kenneth Key and Amerigo, such that Kenneth Key's film's earnings is 3 million less than Amerigo's earnings. So, the constraints will be of the form:
    e1 == KennethKey and e2 == Amerigo => e1_to_int == e2_to_int - 3, for all e1, e2 in earnings.

-   Fast and Dead was directed by Kenneth Key:
    This is a direct assignment constraint:
    KennethKey == FastAndDead.

-   Let Me Out is either the movie directed by Linda Lynch or the movie that grossed 5 million:
    This is a constraint that states that Let Me Out is either directed by Linda Lynch or grossed 5 million, but not both. So:
    Xor([LetMeOut == LindaLynch, LetMeOut == 5M]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Amerigo == 1, and 2M == 1, and JimJohnson == 1, then the movie Amerigo grossed 2 million and was directed by Jim Johnson.

### Decision variables:
-   Movies: Amerigo, FastAndDead, LetMeOut, WhatAWorld (all different, 1 to 4)
-   Earnings: 2 million, 5 million, 8 million, 11 million (all different, 1 to 4)
-   Directors: JimJohnson, KennethKey, LindaLynch, MicahMoreno (all different, 1 to 4)

### Constraints:
-   The movie that grossed 5 million was directed by Kenneth Key:
    This is a direct assignment constraint:
    KennethKey == 5M.

-   Of What a World and Amerigo, one made 2 million and the other was directed by Jim Johnson:
    This is a constraint that states that one of the movies made 2 million and the other was directed by Jim Johnson. So, we can represent this as:
    Xor([WhatAWorld == 2M, WhatAWorld == JimJohnson]).

-   The film directed by Kenneth Key made 3 million less than Amerigo:
    For this, we will need to add a constraint for each possible assignment of earnings for the film directed by Kenneth Key and Amerigo, such that Kenneth Key's film's earnings is 3 million less than Amerigo's earnings. So, the constraints will be of the form:
    e1 == KennethKey and e2 == Amerigo => e1_to_int == e2_to_int - 3, for all e1, e2 in earnings.

-   Fast and Dead was directed by Kenneth Key:
    This is a direct assignment constraint:
    KennethKey == FastAndDead.

-   Let Me Out is either the movie directed by Linda Lynch or the movie that grossed 5 million:
    This is a constraint that states that Let Me Out is either directed by Linda Lynch or grossed 5 million, but not both. So:
    Xor([LetMeOut == LindaLynch, LetMeOut == 5M]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of movie, earnings, and director)
# e.g. if amerigo == 1 and earnings2 == 1 and jim == 1, then the movie Amerigo grossed 2 million and was directed by Jim Johnson
amerigo, fast_and_dead, let_me_out, what_a_world = movies = intvar(1, 4, shape=4)
earnings2, earnings5, earnings8, earnings11 = earnings = intvar(1, 4, shape=4)
jim, kenneth, linda, micah = directors = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
movie_to_int = None  # N/A
earnings_to_int = {earnings2: 2, earnings5: 5, earnings8: 8, earnings11: 11}  # in millions
director_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def made_less_than(var1, var2, diff):
    """
    Formulate the constraint that var1 made diff million less than var2.
    """
    return [((e1 == var1) & (e2 == var2)).implies(earnings_to_int[e1] == earnings_to_int[e2] - diff)
            for e1 in earnings for e2 in earnings]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(movies)
m += AllDifferent(earnings)
m += AllDifferent(directors)

# Clue 1: The movie that grossed 5 million was directed by Kenneth Key:
m += kenneth == earnings5

# Clue 2: Of What a World and Amerigo, one made 2 million and the other was directed by Jim Johnson:
m += Xor([what_a_world == earnings2, what_a_world == jim])

# Clue 3: The film directed by Kenneth Key made 3 million less than Amerigo:
m += made_less_than(kenneth, amerigo, 3)

# Clue 4: Fast and Dead was directed by Kenneth Key:
m += kenneth == fast_and_dead

# Clue 5: Let Me Out is either the movie directed by Linda Lynch or the movie that grossed 5 million:
m += Xor([let_me_out == linda, let_me_out == earnings5])

```
False
True
False
Wrong: 1, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The person who is 110 years old is a native of Connecticut.
Of Arlene and the Texas native, one is 110 years old and the other is 109 years old.
Herbert is 1 year younger than Doris.
The person who is 112 years old is either Herbert or the New Mexico native.

Entities:
ages: 109 years, 110 years, 111 years, 112 years
names: Arlene, Doris, Floyd, Herbert
states: Connecticut, Missouri, New Mexico, Texas
PARAM (26-29): 110
VAR (72-78): Arlene
VAR (87-92): Texas
PARAM (109-112): 110
PARAM (140-143): 109
PARAM (167-168): 1
PARAM (213-216): 112
VAR (256-262): Mexico
OBJ_NAME (283-287): ages
PARAM (290-293): 109
PARAM (302-305): 110
PARAM (314-317): 111
PARAM (326-329): 112

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Arlene == 1, and Connecticut == 1, and Age110 == 1, then Arlene, a native of Connecticut, is 110 years old.

### Decision variables:
-   Ages: Age109, Age110, Age111, Age112 (all different, 1 to 4)
-   Names: Arlene, Doris, Floyd, Herbert (all different, 1 to 4)
-   States: Connecticut, Missouri, New Mexico, Texas (all different, 1 to 4)

### Constraints:
-   The person who is 110 years old is a native of Connecticut:
    This is a direct assignment constraint:
    Age110 == Connecticut.

-   Of Arlene and the Texas native, one is 110 years old and the other is 109 years old:
    This is a constraint that states that one of Arlene and the Texas native is 110 years old and the other is 109 years old. So, we can represent this as:
    (Arlene == Age110 and Texas == Age109) or (Arlene == Age109 and Texas == Age110).

-   Herbert is 1 year younger than Doris:
    For this, we will need to add a constraint that Herbert's age is 1 less than Doris's age. So, the constraint will be of the form:
    Herbert_to_int == Doris_to_int - 1.

-   The person who is 112 years old is either Herbert or the New Mexico native:
    This is a constraint that states that the person who is 112 years old is either Herbert or the New Mexico native, but not both. So:
    Xor([Herbert == Age112, Mexico == Age112]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Arlene == 1, and Connecticut == 1, and Age110 == 1, then Arlene, a native of Connecticut, is 110 years old.

### Decision variables:
-   Ages: Age109, Age110, Age111, Age112 (all different, 1 to 4)
-   Names: Arlene, Doris, Floyd, Herbert (all different, 1 to 4)
-   States: Connecticut, Missouri, New Mexico, Texas (all different, 1 to 4)

### Constraints:
-   The person who is 110 years old is a native of Connecticut:
    This is a direct assignment constraint:
    Age110 == Connecticut.

-   Of Arlene and the Texas native, one is 110 years old and the other is 109 years old:
    This is a constraint that states that one of Arlene and the Texas native is 110 years old and the other is 109 years old. So, we can represent this as:
    (Arlene == Age110 and Texas == Age109) or (Arlene == Age109 and Texas == Age110).

-   Herbert is 1 year younger than Doris:
    For this, we will need to add a constraint that Herbert's age is 1 less than Doris's age. So, the constraint will be of the form:
    Herbert_to_int == Doris_to_int - 1.

-   The person who is 112 years old is either Herbert or the New Mexico native:
    This is a constraint that states that the person who is 112 years old is either Herbert or the New Mexico native, but not both. So:
    Xor([Herbert == Age112, Mexico == Age112]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of name, age, and state)
# e.g. if arlene == 1 and age110 == 1 and connecticut == 1, then Arlene, a native of Connecticut, is 110 years old
arlene, doris, floyd, herbert = names = intvar(1, 4, shape=4)
age109, age110, age111, age112 = ages = intvar(1, 4, shape=4)
connecticut, missouri, new_mexico, texas = states = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
name_to_int = None  # N/A
age_to_int = {age109: 109, age110: 110, age111: 111, age112: 112}  # in years
state_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def one_is_110_and_other_is_109(var1, var2):
    """
    Formulate the constraint that one variable is 110 years old and the other is 109 years old.
    """
    return [(var1 == age110) & (var2 == age109) | (var1 == age109) & (var2 == age110)]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(names)
m += AllDifferent(ages)
m += AllDifferent(states)

# Clue 1: The person who is 110 years old is a native of Connecticut:
m += age110 == connecticut

# Clue 2: Of Arlene and the Texas native, one is 110 years old and the other is 109 years old:
m += one_is_110_and_other_is_109(arlene, texas)

# Clue 3: Herbert is 1 year younger than Doris:
m += herbert == doris - 1

# Clue 4: The person who is 112 years old is either Herbert or the New Mexico native:
m += Xor([herbert == age112, new_mexico == age112])

```
False
False
False
Wrong: 2, Total: 7
---------------------------------------------------------------------------------------------

Clues:
Of Frances and Olga, one paid $25 and the other had the shiraz.
The one who had the port paid 2 dollars more than Kurt.
Olga had the merlot.

Entities:
prices: $24, $25, $26, $27
names: Frances, Hannah, Kurt, Olga
wines: merlot, port, riesling, shiraz
VAR (23-27): Olga
PARAM (41-43): 25
PARAM (105-106): 2
PARAM (176-178): 24
PARAM (183-185): 25
PARAM (190-192): 26
PARAM (197-199): 27

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Frances == 1, and $24 == 1, and Shiraz == 1, then Frances paid $24 for the shiraz.

### Decision variables:
-   Names of the individuals: Frances, Hannah, Kurt, Olga (all different, 1 to 4)
-   Prices paid: $24, $25, $26, $27 (all different, 1 to 4)
-   Types of wines: Merlot, Port, Riesling, Shiraz (all different, 1 to 4)

### Constraints:
-   Of Frances and Olga, one paid $25 and the other had the shiraz:
    This is a constraint that states that one of Frances or Olga paid $25 and the other had the shiraz. So, the constraints will be of the form:
    (Frances == $25 and Olga == Shiraz) or (Frances == Shiraz and Olga == $25).

-   The one who had the port paid 2 dollars more than Kurt:
    For this, we will need to add a constraint for each possible assignment of prices for the one who had the port and Kurt, such that the price of the one who had the port is $2 more than Kurt's price. So, the constraints will be of the form:
    (Port == Olga and Kurt == p) or (Port == p and Kurt == Olga) => abs(p_to_int - Olga_to_int) == 2, for all p in prices.

-   Olga had the merlot:
    This is a direct assignment constraint:
    Olga == Merlot.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Frances == 1, and $24 == 1, and Shiraz == 1, then Frances paid $24 for the shiraz.

### Decision variables:
-   Names of the individuals: Frances, Hannah, Kurt, Olga (all different, 1 to 4)
-   Prices paid: $24, $25, $26, $27 (all different, 1 to 4)
-   Types of wines: Merlot, Port, Riesling, Shiraz (all different, 1 to 4)

### Constraints:
-   Of Frances and Olga, one paid $25 and the other had the shiraz:
    This is a constraint that states that one of Frances or Olga paid $25 and the other had the shiraz. So, the constraints will be of the form:
    (Frances == $25 and Olga == Shiraz) or (Frances == Shiraz and Olga == $25).

-   The one who had the port paid 2 dollars more than Kurt:
    For this, we will need to add a constraint for each possible assignment of prices for the one who had the port and Kurt, such that the price of the one who had the port is $2 more than Kurt's price. So, the constraints will be of the form:
    (Port == Olga and Kurt == p) or (Port == p and Kurt == Olga) => abs(p_to_int - Olga_to_int) == 2, for all p in prices.

-   Olga had the merlot:
    This is a direct assignment constraint:
    Olga == Merlot.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of name, price, and wine)
# e.g. if frances == 1 and price24 == 1 and shiraz == 1, then Frances paid $24 for the shiraz
frances, hannah, kurt, olga = names = intvar(1, 4, shape=4)
price24, price25, price26, price27 = prices = intvar(1, 4, shape=4)
merlot, port, riesling, shiraz = wines = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
name_to_int = None  # N/A
price_to_int = {price24: 24, price25: 25, price26: 26, price27: 27}  # in dollars
wine_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def paid_and_wine(var1, var2, price, wine):
    """
    Formulate the constraint that var1 paid the given price and var2 had the given wine.
    """
    return [(var1 == price) & (var2 == wine), (var1 == wine) & (var2 == price)]


def paid_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 paid more than var2 by the given difference.
    """
    return [((p1 == var1) & (p2 == var2)).implies(abs(price_to_int[p1] - price_to_int[p2]) == diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(names)
m += AllDifferent(prices)
m += AllDifferent(wines)

# Clue 1: Of Frances and Olga, one paid $25 and the other had the shiraz:
m += paid_and_wine(frances, olga, price25, shiraz)

# Clue 2: The one who had the port paid 2 dollars more than Kurt:
m += paid_more_than(port, kurt, 2)

# Clue 3: Olga had the merlot:
m += olga == merlot

```
False
False
False
Wrong: 2, Total: 6
---------------------------------------------------------------------------------------------

Clues:
Regal Park is on Barbados.
Grand Echo costs 40 dollars more per night than the resort on Barbados.
Of El Pacifico and Regal Park, one is on Martinique and the other costs $175 per night.
The hotel that costs $215 per night is either the hotel on St. Barts or Emerald View.
Grand Echo costs 20 dollars less per night than Emerald View.

Entities:
prices: $175, $195, $215, $235
resorts: El Pacifico, Emerald View, Grand Echo, Regal Park
islands: Anguilla, Barbados, Martinique, St. Barts
VAR (8-18): Regal Park
VAR (25-33): Barbados
VAR (36-46): Grand Echo
PARAM (53-55): 40
VAR (98-106): Barbados
VAR (112-123): El Pacifico
VAR (128-138): Regal Park
VAR (151-161): Martinique
PARAM (184-187): 175
PARAM (223-226): 215
VAR (260-269): St. Barts
VAR (273-285): Emerald View
VAR (288-298): Grand Echo
PARAM (305-307): 20
VAR (336-348): Emerald View
PARAM (373-376): 175
PARAM (381-384): 195
PARAM (389-392): 215
PARAM (397-400): 235
VAR (411-422): El Pacifico
VAR (425-437): Emerald View
VAR (440-450): Grand Echo
VAR (453-458): Regal

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if RegalPark == 1, and Barbados == 1, and $175 == 1, then Regal Park is on Barbados and costs $175 per night.

### Decision variables:
-   Names of the resorts: ElPacifico, EmeraldView, GrandEcho, RegalPark (all different, 1 to 4)
-   Islands where the resorts are located: Anguilla, Barbados, Martinique, StBarts (all different, 1 to 4)
-   Prices per night: $175, $195, $215, $235 (all different, 1 to 4)

### Constraints:
-   Regal Park is on Barbados:
    This is a direct assignment constraint:
    RegalPark == Barbados.

-   Grand Echo costs 40 dollars more per night than the resort on Barbados:
    For this, we will need to add a constraint for each possible assignment of prices for Grand Echo and the resort on Barbados, such that Grand Echo's price is 40 dollars more than the resort on Barbados. So, the constraints will be of the form:
    p1 == GrandEcho and p2 == Barbados => p1_to_int == p2_to_int + 40, for all p1, p2 in prices.

-   Of El Pacifico and Regal Park, one is on Martinique and the other costs $175 per night:
    This is a constraint that states that one of El Pacifico and Regal Park is on Martinique and the other costs $175 per night. So:
    (ElPacifico == Martinique and RegalPark == $175) or (ElPacifico == $175 and RegalPark == Martinique).

-   The hotel that costs $215 per night is either the hotel on St. Barts or Emerald View:
    This is a constraint that states that the hotel that costs $215 per night is either on St. Barts or is Emerald View. So:
    ($215 == StBarts or $215 == EmeraldView).

-   Grand Echo costs 20 dollars less per night than Emerald View:
    For this, we will need to add a constraint for each possible assignment of prices for Grand Echo and Emerald View, such that Grand Echo's price is 20 dollars less than Emerald View's price. So, the constraints will be of the form:
    p1 == GrandEcho and p2 == EmeraldView => p1_to_int == p2_to_int - 20, for all p1, p2 in prices.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if RegalPark == 1, and Barbados == 1, and $175 == 1, then Regal Park is on Barbados and costs $175 per night.

### Decision variables:
-   Names of the resorts: ElPacifico, EmeraldView, GrandEcho, RegalPark (all different, 1 to 4)
-   Islands where the resorts are located: Anguilla, Barbados, Martinique, StBarts (all different, 1 to 4)
-   Prices per night: $175, $195, $215, $235 (all different, 1 to 4)

### Constraints:
-   Regal Park is on Barbados:
    This is a direct assignment constraint:
    RegalPark == Barbados.

-   Grand Echo costs 40 dollars more per night than the resort on Barbados:
    For this, we will need to add a constraint for each possible assignment of prices for Grand Echo and the resort on Barbados, such that Grand Echo's price is 40 dollars more than the resort on Barbados. So, the constraints will be of the form:
    p1 == GrandEcho and p2 == Barbados => p1_to_int == p2_to_int + 40, for all p1, p2 in prices.

-   Of El Pacifico and Regal Park, one is on Martinique and the other costs $175 per night:
    This is a constraint that states that one of El Pacifico and Regal Park is on Martinique and the other costs $175 per night. So:
    (ElPacifico == Martinique and RegalPark == $175) or (ElPacifico == $175 and RegalPark == Martinique).

-   The hotel that costs $215 per night is either the hotel on St. Barts or Emerald View:
    This is a constraint that states that the hotel that costs $215 per night is either on St. Barts or is Emerald View. So:
    ($215 == StBarts or $215 == EmeraldView).

-   Grand Echo costs 20 dollars less per night than Emerald View:
    For this, we will need to add a constraint for each possible assignment of prices for Grand Echo and Emerald View, such that Grand Echo's price is 20 dollars less than Emerald View's price. So, the constraints will be of the form:
    p1 == GrandEcho and p2 == EmeraldView => p1_to_int == p2_to_int - 20, for all p1, p2 in prices.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of resort, island, and price)
# e.g. if regal_park == 1 and barbados == 1 and price175 == 1, then Regal Park is on Barbados and costs $175 per night
el_pacifico, emerald_view, grand_echo, regal_park = resorts = intvar(1, 4, shape=4)
anguilla, barbados, martinique, st_barts = islands = intvar(1, 4, shape=4)
price175, price195, price215, price235 = prices = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
resort_to_int = None  # N/A
island_to_int = None  # N/A
price_to_int = {price175: 175, price195: 195, price215: 215, price235: 235}  # in dollars


# Helper functions (for formulating comparison constraints)
def costs_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 costs more than var2 by diff dollars.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] + diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(resorts)
m += AllDifferent(islands)
m += AllDifferent(prices)

# Clue 1: Regal Park is on Barbados:
m += regal_park == barbados

# Clue 2: Grand Echo costs 40 dollars more per night than the resort on Barbados:
m += costs_more_than(grand_echo, barbados, 40)

# Clue 3: Of El Pacifico and Regal Park, one is on Martinique and the other costs $175 per night:
m += ((el_pacifico == martinique) & (regal_park == price175)) | ((el_pacifico == price175) & (regal_park == martinique))

# Clue 4: The hotel that costs $215 per night is either the hotel on St. Barts or Emerald View:
m += (price215 == st_barts) | (price215 == emerald_view)

# Clue 5: Grand Echo costs 20 dollars less per night than Emerald View:
m += costs_more_than(emerald_view, grand_echo, 20)

```
True
True
True
Wrong: 2, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Snappy is 18 years younger than the swoopbacked tortoise.
The 68 year old animal is the horned tortoise.
Chewie is 32 years old.
Of Snappy and Toredo, one is 14 years old and the other is the horned tortoise.
The pitch belly tortoise is younger than Chewie.

Entities:
ages: 14, 32, 50, 68
tortoises: Chewie, Snappy, Speedy, Toredo
species: black neck, horned, pitch belly, swoopbacked
VAR (8-14): Snappy
PARAM (18-20): 18
LIMIT (71-73): 68
VAR (115-121): Chewie
PARAM (125-127): 32
VAR (143-149): Snappy
PARAM (170-172): 14
VAR (263-269): Chewie
PARAM (290-292): 14
PARAM (295-297): 32
PARAM (300-302): 50
LIMIT (305-307): 68
VAR (320-326): Chewie
VAR (329-335): Snappy

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Chewie == 1, and 32 == 1, and horned == 1, then Chewie is the 32-year-old horned tortoise.

### Decision variables:
-   Names of the tortoises: Chewie, Snappy, Speedy, Toredo (all different, 1 to 4)
-   Ages of the tortoises: 14, 32, 50, 68 (all different, 1 to 4)
-   Species of the tortoises: black neck, horned, pitch belly, swoopbacked (all different, 1 to 4)

### Constraints:
-   Snappy is 18 years younger than the swoopbacked tortoise:
    For this, we will need to add a constraint for each possible assignment of ages for Snappy and the swoopbacked tortoise, such that Snappy's age is 18 less than the swoopbacked tortoise's age. So, the constraints will be of the form:
    a1 == Snappy and a2 == swoopbacked => a1_to_int == a2_to_int - 18, for all a1, a2 in ages.

-   The 68-year-old animal is the horned tortoise:
    This is a direct assignment constraint:
    horned == 68.

-   Chewie is 32 years old:
    This is a direct assignment constraint:
    Chewie == 32.

-   Of Snappy and Toredo, one is 14 years old and the other is the horned tortoise:
    This is a constraint that states that one of Snappy and Toredo is 14 years old and the other is the horned tortoise, but not both. So:
    Xor([Snappy == 14 and Toredo == horned, Snappy == horned and Toredo == 14]).

-   The pitch belly tortoise is younger than Chewie:
    For this, we will need to add a constraint for each possible assignment of ages for the pitch belly tortoise and Chewie, such that the pitch belly tortoise's age is less than Chewie's age. So, the constraints will be of the form:
    a1 == pitch belly and a2 == Chewie => a1_to_int < a2_to_int, for all a1, a2 in ages.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Chewie == 1, and 32 == 1, and horned == 1, then Chewie is the 32-year-old horned tortoise.

### Decision variables:
-   Names of the tortoises: Chewie, Snappy, Speedy, Toredo (all different, 1 to 4)
-   Ages of the tortoises: 14, 32, 50, 68 (all different, 1 to 4)
-   Species of the tortoises: black neck, horned, pitch belly, swoopbacked (all different, 1 to 4)

### Constraints:
-   Snappy is 18 years younger than the swoopbacked tortoise:
    For this, we will need to add a constraint for each possible assignment of ages for Snappy and the swoopbacked tortoise, such that Snappy's age is 18 less than the swoopbacked tortoise's age. So, the constraints will be of the form:
    a1 == Snappy and a2 == swoopbacked => a1_to_int == a2_to_int - 18, for all a1, a2 in ages.

-   The 68-year-old animal is the horned tortoise:
    This is a direct assignment constraint:
    horned == 68.

-   Chewie is 32 years old:
    This is a direct assignment constraint:
    Chewie == 32.

-   Of Snappy and Toredo, one is 14 years old and the other is the horned tortoise:
    This is a constraint that states that one of Snappy and Toredo is 14 years old and the other is the horned tortoise, but not both. So:
    Xor([Snappy == 14 and Toredo == horned, Snappy == horned and Toredo == 14]).

-   The pitch belly tortoise is younger than Chewie:
    For this, we will need to add a constraint for each possible assignment of ages for the pitch belly tortoise and Chewie, such that the pitch belly tortoise's age is less than Chewie's age. So, the constraints will be of the form:
    a1 == pitch belly and a2 == Chewie => a1_to_int < a2_to_int, for all a1, a2 in ages.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of tortoise, age, and species)
# e.g. if chewie == 1 and 32 == 1 and horned == 1, then Chewie is the 32-year-old horned tortoise
chewie, snappy, speedy, toredo = tortoises = intvar(1, 4, shape=4)
age14, age32, age50, age68 = ages = intvar(1, 4, shape=4)
black_neck, horned, pitch_belly, swoopbacked = species = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
tortoise_to_int = None  # N/A
age_to_int = {age14: 14, age32: 32, age50: 50, age68: 68}  # in years
species_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def younger_than(var1, var2, diff):
    """
    Formulate the constraint that var1 is diff years younger than var2.
    """
    return [((a1 == var1) & (a2 == var2)).implies(age_to_int[a1] == age_to_int[a2] - diff)
            for a1 in ages for a2 in ages]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(tortoises)
m += AllDifferent(ages)
m += AllDifferent(species)

# Clue 1: Snappy is 18 years younger than the swoopbacked tortoise:
m += younger_than(snappy, swoopbacked, 18)

# Clue 2: The 68-year-old animal is the horned tortoise:
m += horned == age68

# Clue 3: Chewie is 32 years old:
m += chewie == age32

# Clue 4: Of Snappy and Toredo, one is 14 years old and the other is the horned tortoise:
m += Xor([snappy == age14, snappy == horned, toredo == age14, toredo == horned])

# Clue 5: The pitch belly tortoise is younger than Chewie:
m += age_to_int[pitch_belly] < age_to_int[chewie]

```
Error: name 'IV2042' is not defined
False
False
Error: name 'IV2066' is not defined
---------------------------------------------------------------------------------------------

Clues:
Of the parrot and the lorikeet, one was bought in April and the other is Roberta's.
Natalie's pet was bought sometime before Roberta's pet.
Laura's pet is the lovebird.
The bird bought in February is either the lorikeet or the lovebird.
Of the bird bought in February and the macaw, one is Natalie's and the other is Roberta's.

Entities:
months: January, February, March, April
names: Celia, Laura, Natalie, Roberta
birds: lorikeet, lovebird, macaw, parrot
VAR (30-38): lorikeet
VAR (82-89): Roberta
VAR (95-105): Natalie 's
VAR (137-147): Roberta 's
VAR (227-235): lorikeet
VAR (308-318): Natalie 's
VAR (336-346): Roberta 's
VAR (438-445): Roberta
VAR (484-490): parrot

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Celia == 1, and January == 1, and Lorikeet == 1, then Celia bought a lorikeet in January.

### Decision variables:
-   Names of the owners: Celia, Laura, Natalie, Roberta (all different, 1 to 4)
-   Months of purchase: January, February, March, April (all different, 1 to 4)
-   Types of birds: Lorikeet, Lovebird, Macaw, Parrot (all different, 1 to 4)

### Constraints:
-   Of the parrot and the lorikeet, one was bought in April and the other is Roberta's:
    This is a constraint that states that one of the birds (parrot or lorikeet) was bought in April and the other bird is Roberta's. So, we have:
    (Parrot == April and Lorikeet == Roberta) or (Lorikeet == April and Parrot == Roberta).

-   Natalie's pet was bought sometime before Roberta's pet:
    For this, we will need to add a constraint for each possible assignment of the months of purchase for Natalie's pet and Roberta's pet, such that Natalie's pet's month of purchase is less than Roberta's pet's month of purchase. So, the constraints will be of the form:
    m1 == Natalie and m2 == Roberta => m1_to_int < m2_to_int, for all m1, m2 in months of purchase.

-   Laura's pet is the lovebird:
    This is a direct assignment constraint:
    Laura == Lovebird.

-   The bird bought in February is either the lorikeet or the lovebird:
    This is a constraint that states that the bird bought in February is either the lorikeet or the lovebird, but not both. So:
    Xor([February == Lorikeet, February == Lovebird]).

-   Of the bird bought in February and the macaw, one is Natalie's and the other is Roberta's:
    This is a constraint that states that the bird bought in February and the macaw are owned by Natalie and Roberta, but not in the same combination. So:
    (February == Natalie and Macaw == Roberta) or (February == Roberta and Macaw == Natalie).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Celia == 1, and January == 1, and Lorikeet == 1, then Celia bought a lorikeet in January.

### Decision variables:
-   Names of the owners: Celia, Laura, Natalie, Roberta (all different, 1 to 4)
-   Months of purchase: January, February, March, April (all different, 1 to 4)
-   Types of birds: Lorikeet, Lovebird, Macaw, Parrot (all different, 1 to 4)

### Constraints:
-   Of the parrot and the lorikeet, one was bought in April and the other is Roberta's:
    This is a constraint that states that one of the birds (parrot or lorikeet) was bought in April and the other bird is Roberta's. So, we have:
    (Parrot == April and Lorikeet == Roberta) or (Lorikeet == April and Parrot == Roberta).

-   Natalie's pet was bought sometime before Roberta's pet:
    For this, we will need to add a constraint for each possible assignment of the months of purchase for Natalie's pet and Roberta's pet, such that Natalie's pet's month of purchase is less than Roberta's pet's month of purchase. So, the constraints will be of the form:
    m1 == Natalie and m2 == Roberta => m1_to_int < m2_to_int, for all m1, m2 in months of purchase.

-   Laura's pet is the lovebird:
    This is a direct assignment constraint:
    Laura == Lovebird.

-   The bird bought in February is either the lorikeet or the lovebird:
    This is a constraint that states that the bird bought in February is either the lorikeet or the lovebird, but not both. So:
    Xor([February == Lorikeet, February == Lovebird]).

-   Of the bird bought in February and the macaw, one is Natalie's and the other is Roberta's:
    This is a constraint that states that the bird bought in February and the macaw are owned by Natalie and Roberta, but not in the same combination. So:
    (February == Natalie and Macaw == Roberta) or (February == Roberta and Macaw == Natalie).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of owner, month, and bird)
# e.g. if celia == 1 and january == 1 and lorikeet == 1, then Celia bought a lorikeet in January
celia, laura, natalie, roberta = owners = intvar(1, 4, shape=4)
january, february, march, april = months = intvar(1, 4, shape=4)
lorikeet, lovebird, macaw, parrot = birds = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
owner_to_int = None  # N/A
month_to_int = {january: 1, february: 2, march: 3, april: 4}  # in months
bird_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def bought_in_month(var1, var2, month):
    """
    Formulate the constraint that var1 and var2 were bought in the specified month.
    """
    return [(var1 == month) & (var2 == month)]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(owners)
m += AllDifferent(months)
m += AllDifferent(birds)

# Clue 1: Of the parrot and the lorikeet, one was bought in April and the other is Roberta's:
m += ((parrot == april) & (lorikeet == roberta)) | ((lorikeet == april) & (parrot == roberta))

# Clue 2: Natalie's pet was bought sometime before Roberta's pet:
m += [(natalie == m1) & (roberta == m2) for m1 in months for m2 in months if month_to_int[m1] < month_to_int[m2]]

# Clue 3: Laura's pet is the lovebird:
m += laura == lovebird

# Clue 4: The bird bought in February is either the lorikeet or the lovebird:
m += Xor([february == lorikeet, february == lovebird])

# Clue 5: Of the bird bought in February and the macaw, one is Natalie's and the other is Roberta's:
m += ((february == natalie) & (macaw == roberta)) | ((february == roberta) & (macaw == natalie))

```
False
False
False
Wrong: 3, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Suzanne paid less than Margie.
Margie paid $7.
The competitor who ordered spaghetti paid 2 dollars more than the competitor who ordered taglioni.
Of the runner who paid $9 and the contestant who ordered fettuccine, one was Margie and the other was Velma.

Entities:
prices: $6, $7, $8, $9
runners: Florence, Margie, Suzanne, Velma
pastas: fettuccine, fusilli, spaghetti, taglioni
VAR (8-15): Suzanne
CONST_DIR (21-25): less
VAR (31-37): Margie
VAR (40-46): Margie
PARAM (54-55): 7
VAR (85-94): spaghetti
PARAM (100-101): 2
VAR (147-155): taglioni
PARAM (183-184): 9
VAR (216-226): fettuccine
VAR (237-243): Margie
VAR (262-267): Velma
OBJ_NAME (281-287): prices
PARAM (292-293): 6
PARAM (298-299): 7
PARAM (304-305): 8
PARAM (310-311): 9
VAR (333-339): Margie
VAR (342-349): Suzanne
VAR (367-377): fettuccine
VAR (390-399): spaghetti
VAR (402-410): taglioni

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Florence == 1, and Fettuccine == 1, and Price6 == 1, then Florence paid $6 for fettuccine.

### Decision variables:
-   Names of the runners: Florence, Margie, Suzanne, Velma (all different, 1 to 4)
-   Prices paid: Price6, Price7, Price8, Price9 (all different, 1 to 4)
-   Types of pastas ordered: Fettuccine, Fusilli, Spaghetti, Taglioni (all different, 1 to 4)

### Constraints:
-   Suzanne paid less than Margie:
    For this, we will need to add a constraint for each possible assignment of prices to Suzanne and Margie, such that Suzanne's price is less than Margie's price. So, the constraints will be of the form:
    p1 == Suzanne and p2 == Margie => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   Margie paid $7:
    This is a direct assignment constraint:
    Margie == Price7.

-   The competitor who ordered spaghetti paid 2 dollars more than the competitor who ordered taglioni:
    For this, we will need to add a constraint for each possible assignment of prices to spaghetti and taglioni, such that the price of spaghetti is 2 more than the price of taglioni. So, the constraints will be of the form:
    p1 == Spaghetti and p2 == Taglioni => p1_to_int == p2_to_int + 2, for all p1, p2 in prices.

-   Of the runner who paid $9 and the contestant who ordered fettuccine, one was Margie and the other was Velma:
    This is a constraint that states that one of the runners who paid $9 and the contestant who ordered fettuccine is Margie, and the other is Velma. So:
    (Price9 == Margie and Fettuccine == Velma) or (Price9 == Velma and Fettuccine == Margie).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Florence == 1, and Fettuccine == 1, and Price6 == 1, then Florence paid $6 for fettuccine.

### Decision variables:
-   Names of the runners: Florence, Margie, Suzanne, Velma (all different, 1 to 4)
-   Prices paid: Price6, Price7, Price8, Price9 (all different, 1 to 4)
-   Types of pastas ordered: Fettuccine, Fusilli, Spaghetti, Taglioni (all different, 1 to 4)

### Constraints:
-   Suzanne paid less than Margie:
    For this, we will need to add a constraint for each possible assignment of prices to Suzanne and Margie, such that Suzanne's price is less than Margie's price. So, the constraints will be of the form:
    p1 == Suzanne and p2 == Margie => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   Margie paid $7:
    This is a direct assignment constraint:
    Margie == Price7.

-   The competitor who ordered spaghetti paid 2 dollars more than the competitor who ordered taglioni:
    For this, we will need to add a constraint for each possible assignment of prices to spaghetti and taglioni, such that the price of spaghetti is 2 more than the price of taglioni. So, the constraints will be of the form:
    p1 == Spaghetti and p2 == Taglioni => p1_to_int == p2_to_int + 2, for all p1, p2 in prices.

-   Of the runner who paid $9 and the contestant who ordered fettuccine, one was Margie and the other was Velma:
    This is a constraint that states that one of the runners who paid $9 and the contestant who ordered fettuccine is Margie, and the other is Velma. So:
    (Price9 == Margie and Fettuccine == Velma) or (Price9 == Velma and Fettuccine == Margie).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of runner, price, and pasta)
# e.g. if florence == 1 and price6 == 1 and fettuccine == 1, then Florence paid $6 for fettuccine
florence, margie, suzanne, velma = runners = intvar(1, 4, shape=4)
price6, price7, price8, price9 = prices = intvar(1, 4, shape=4)
fettuccine, fusilli, spaghetti, taglioni = pastas = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
runner_to_int = None  # N/A
price_to_int = {price6: 6, price7: 7, price8: 8, price9: 9}  # in dollars
pasta_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def paid_less_than(var1, var2):
    """
    Formulate the constraint that var1 paid less than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] < price_to_int[p2])
            for p1 in prices for p2 in prices]


def paid_exactly_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 paid exactly diff dollars more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] + diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(runners)
m += AllDifferent(prices)
m += AllDifferent(pastas)

# Clue 1: Suzanne paid less than Margie:
m += paid_less_than(suzanne, margie)

# Clue 2: Margie paid $7:
m += margie == price7

# Clue 3: The competitor who ordered spaghetti paid 2 dollars more than the competitor who ordered taglioni:
m += paid_exactly_more_than(spaghetti, taglioni, 2)

# Clue 4: Of the runner who paid $9 and the contestant who ordered fettuccine, one was Margie and the other was Velma:
m += ((price9 == margie) & (fettuccine == velma)) | ((price9 == velma) & (fettuccine == margie))

```
True
True
True
Wrong: 1, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The Luzagueil is a chardonnay.
The Annata Branco is either the 1992 wine or the syrah.
The Friambliss is a syrah.
Of the pinot gris and the 1984 bottle, one is the Luzagueil and the other is the Zifennwein.
The pinot gris was bottled 4 years after the merlot.

Entities:
vintages: 1984, 1988, 1992, 1996
wines: Annata Branco, Friambliss, Luzagueil, Zifennwein
types: chardonnay, merlot, pinot gris, syrah
VAR (12-21): Luzagueil
VAR (44-57): Annata Branco
VAR (101-111): Friambliss
VAR (176-185): Luzagueil
VAR (207-217): Zifennwein
PARAM (247-248): 4
PARAM (296-300): 1984
PARAM (303-307): 1988
PARAM (310-314): 1992
PARAM (317-321): 1996
VAR (330-343): Annata Branco
VAR (346-356): Friambliss
VAR (359-368): Luzagueil
VAR (371-381): Zifennwein

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if 1984 == 1, and AnnataBranco == 1, and Chardonnay == 1, then the 1984 vintage of Annata Branco is a chardonnay.

### Decision variables:
-   Vintages: 1984, 1988, 1992, 1996 (all different, 1 to 4)
-   Wines: AnnataBranco, Friambliss, Luzagueil, Zifennwein (all different, 1 to 4)
-   Types of wines: Chardonnay, Merlot, PinotGris, Syrah (all different, 1 to 4)

### Constraints:
-   The Luzagueil is a chardonnay:
    This is a direct assignment constraint:
    Luzagueil == Chardonnay.

-   The Annata Branco is either the 1992 wine or the syrah:
    This is a constraint that states that Annata Branco is either the 1992 vintage or the syrah type, but not both. So:
    Xor([AnnataBranco == 1992, AnnataBranco == Syrah]).

-   The Friambliss is a syrah:
    This is a direct assignment constraint:
    Friambliss == Syrah.

-   Of the pinot gris and the 1984 bottle, one is the Luzagueil and the other is the Zifennwein:
    This is a constraint that states that one of the pinot gris and the 1984 bottle is the Luzagueil and the other is the Zifennwein. So:
    (PinotGris == Luzagueil and 1984 == Zifennwein) or (PinotGris == Zifennwein and 1984 == Luzagueil).

-   The pinot gris was bottled 4 years after the merlot:
    For this, we will need to add a constraint for each possible assignment of vintages for the pinot gris and the merlot, such that the pinot gris vintage is 4 greater than the merlot vintage. So, the constraints will be of the form:
    v1 == PinotGris and v2 == Merlot => v1_to_int == v2_to_int + 4, for all v1, v2 in vintages.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if 1984 == 1, and AnnataBranco == 1, and Chardonnay == 1, then the 1984 vintage of Annata Branco is a chardonnay.

### Decision variables:
-   Vintages: 1984, 1988, 1992, 1996 (all different, 1 to 4)
-   Wines: AnnataBranco, Friambliss, Luzagueil, Zifennwein (all different, 1 to 4)
-   Types of wines: Chardonnay, Merlot, PinotGris, Syrah (all different, 1 to 4)

### Constraints:
-   The Luzagueil is a chardonnay:
    This is a direct assignment constraint:
    Luzagueil == Chardonnay.

-   The Annata Branco is either the 1992 wine or the syrah:
    This is a constraint that states that Annata Branco is either the 1992 vintage or the syrah type, but not both. So:
    Xor([AnnataBranco == 1992, AnnataBranco == Syrah]).

-   The Friambliss is a syrah:
    This is a direct assignment constraint:
    Friambliss == Syrah.

-   Of the pinot gris and the 1984 bottle, one is the Luzagueil and the other is the Zifennwein:
    This is a constraint that states that one of the pinot gris and the 1984 bottle is the Luzagueil and the other is the Zifennwein. So:
    (PinotGris == Luzagueil and 1984 == Zifennwein) or (PinotGris == Zifennwein and 1984 == Luzagueil).

-   The pinot gris was bottled 4 years after the merlot:
    For this, we will need to add a constraint for each possible assignment of vintages for the pinot gris and the merlot, such that the pinot gris vintage is 4 greater than the merlot vintage. So, the constraints will be of the form:
    v1 == PinotGris and v2 == Merlot => v1_to_int == v2_to_int + 4, for all v1, v2 in vintages.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of vintage, wine, and type)
# e.g. if vintage1984 == 1 and annata_branco == 1 and chardonnay == 1, then the 1984 vintage of Annata Branco is a chardonnay
vintage1984, vintage1988, vintage1992, vintage1996 = vintages = intvar(1, 4, shape=4)
annata_branco, friambliss, luzagueil, zifennwein = wines = intvar(1, 4, shape=4)
chardonnay, merlot, pinot_gris, syrah = types = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
vintage_to_int = None  # N/A
wine_to_int = None  # N/A
type_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def is_either(var1, var2, var3):
    """
    Formulate the constraint that var1 is either var2 or var3.
    """
    return [((v1 == var1) & (v2 == var2) & (v3 == var3)).implies((v1 == v2) | (v1 == v3))
            for v1 in wines for v2 in wines for v3 in wines]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(vintages)
m += AllDifferent(wines)
m += AllDifferent(types)

# Clue 1: The Luzagueil is a chardonnay:
m += luzagueil == chardonnay

# Clue 2: The Annata Branco is either the 1992 wine or the syrah:
m += is_either(annata_branco, vintage1992, syrah)

# Clue 3: The Friambliss is a syrah:
m += friambliss == syrah

# Clue 4: Of the pinot gris and the 1984 bottle, one is the Luzagueil and the other is the Zifennwein:
m += ((pinot_gris == luzagueil) & (vintage1984 == zifennwein)) | ((pinot_gris == zifennwein) & (vintage1984 == luzagueil))

# Clue 5: The pinot gris was bottled 4 years after the merlot:
m += vintage1984 == merlot + 4

```
False
False
False
Wrong: 3, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Hannah paid more than Teri's client.
Freda paid 20 dollars more than Lynda's client.
Hannah paid 10 dollars less than Nancy's client.
Nancy's client, Hannah and Ginger were all different clients.
Hannah was either the person who paid $180 or Lynda's client.

Entities:
Clients: Aimee, Ginger, Freda, Hannah
Prices: $150, $160, $170, $180
Masseuses: Lynda, Nancy, Teri, Whitney
VAR (8-14): Hannah
CONST_DIR (20-24): more
VAR (30-34): Teri
VAR (47-52): Freda
PARAM (58-60): 20
VAR (79-84): Lynda
VAR (97-103): Hannah
PARAM (109-111): 10
VAR (130-135): Nancy
VAR (148-153): Nancy
VAR (166-172): Hannah
VAR (177-183): Ginger
VAR (213-219): Hannah
PARAM (253-256): 180
VAR (260-265): Lynda
VAR (307-313): Ginger
VAR (316-321): Freda
VAR (324-330): Hannah
OBJ_NAME (331-337): Prices
PARAM (342-345): 150
PARAM (350-353): 160
PARAM (358-361): 170
PARAM (366-369): 180
VAR (390-395): Nancy

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Aimee == 1, and Price150 == 1, and Lynda == 1, then Aimee paid $150 to Lynda.

### Decision variables:
-   Clients: Aimee, Ginger, Freda, Hannah (all different, 1 to 4)
-   Prices: $150, $160, $170, $180 (all different, 1 to 4)
-   Masseuses: Lynda, Nancy, Teri, Whitney (all different, 1 to 4)

### Constraints:
-   Hannah paid more than Teri's client:
    For each possible assignment of prices to Hannah and Teri's client, ensure that Hannah's price is greater than Teri's client's price:
    For all prices p1, p2: (p1 == Hannah and p2 == Teri) => p1_to_int > p2_to_int.

-   Freda paid 20 dollars more than Lynda's client:
    For each possible assignment of prices to Freda and Lynda's client, ensure that Freda's price is $20 greater than Lynda's client's price:
    For all prices p1, p2: (p1 == Freda and p2 == Lynda) => p1_to_int == p2_to_int + 20.

-   Hannah paid 10 dollars less than Nancy's client:
    For each possible assignment of prices to Hannah and Nancy's client, ensure that Hannah's price is $10 less than Nancy's client's price:
    For all prices p1, p2: (p1 == Hannah and p2 == Nancy) => p1_to_int == p2_to_int - 10.

-   Nancy's client, Hannah, and Ginger were all different clients:
    Ensure that Nancy, Hannah, and Ginger are all different clients:
    AllDifferent([Nancy, Hannah, Ginger]).

-   Hannah was either the person who paid $180 or Lynda's client:
    Ensure that Hannah is either the person who paid $180 or Lynda's client, but not both:
    Xor([Hannah == Price180, Hannah == Lynda]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Aimee == 1, and Price150 == 1, and Lynda == 1, then Aimee paid $150 to Lynda.

### Decision variables:
-   Clients: Aimee, Ginger, Freda, Hannah (all different, 1 to 4)
-   Prices: $150, $160, $170, $180 (all different, 1 to 4)
-   Masseuses: Lynda, Nancy, Teri, Whitney (all different, 1 to 4)

### Constraints:
-   Hannah paid more than Teri's client:
    For each possible assignment of prices to Hannah and Teri's client, ensure that Hannah's price is greater than Teri's client's price:
    For all prices p1, p2: (p1 == Hannah and p2 == Teri) => p1_to_int > p2_to_int.

-   Freda paid 20 dollars more than Lynda's client:
    For each possible assignment of prices to Freda and Lynda's client, ensure that Freda's price is $20 greater than Lynda's client's price:
    For all prices p1, p2: (p1 == Freda and p2 == Lynda) => p1_to_int == p2_to_int + 20.

-   Hannah paid 10 dollars less than Nancy's client:
    For each possible assignment of prices to Hannah and Nancy's client, ensure that Hannah's price is $10 less than Nancy's client's price:
    For all prices p1, p2: (p1 == Hannah and p2 == Nancy) => p1_to_int == p2_to_int - 10.

-   Nancy's client, Hannah, and Ginger were all different clients:
    Ensure that Nancy, Hannah, and Ginger are all different clients:
    AllDifferent([Nancy, Hannah, Ginger]).

-   Hannah was either the person who paid $180 or Lynda's client:
    Ensure that Hannah is either the person who paid $180 or Lynda's client, but not both:
    Xor([Hannah == Price180, Hannah == Lynda]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of client, masseuse, and price)
# e.g. if aimee == 1 and ginger == 1 and price150 == 1, then Aimee paid $150 to Ginger
aimee, ginger, freda, hannah = clients = intvar(1, 4, shape=4)
price150, price160, price170, price180 = prices = intvar(1, 4, shape=4)
lynda, nancy, teri, whitney = masseuses = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
client_to_int = None  # N/A
masseuse_to_int = None  # N/A
price_to_int = {price150: 150, price160: 160, price170: 170, price180: 180}  # in dollars


# Helper functions (for formulating comparison constraints)
def paid_more_than(var1, var2):
    """
    Formulate the constraint that var1 paid more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] > price_to_int[p2])
            for p1 in prices for p2 in prices]


def paid_exactly_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 paid exactly $diff more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] + diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(clients)
m += AllDifferent(prices)
m += AllDifferent(masseuses)

# Clue 1: Hannah paid more than Teri's client
m += paid_more_than(hannah, teri)

# Clue 2: Freda paid 20 dollars more than Lynda's client
m += paid_exactly_more_than(freda, lynda, 20)

# Clue 3: Hannah paid 10 dollars less than Nancy's client
m += paid_exactly_more_than(hannah, nancy, -10)

# Clue 4: Nancy's client, Hannah, and Ginger were all different clients
m += AllDifferent([nancy, hannah, ginger])

# Clue 5: Hannah was either the person who paid $180 or Lynda's client
m += Xor([hannah == price180, hannah == lynda])

```
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The 115 ft tall waterfall is either the waterfall in Nigeria or the waterfall located in Tibet.
Inawatai is 100 ft tall.
Nyalt is 10 ft taller than Rhoqua.
The waterfall in Brazil is somewhat shorter than Rhoqua.
The waterfall in Brazil is 10 ft shorter than the waterfall located in Nigeria.

Entities:
waterfalls: Sihat, Rhoqua, Nyalt, Inawatai
heights: 100 ft, 105 ft, 110 ft, 115 ft
countries: Brazil, Nigeria, Tibet, Switzerland
LIMIT (12-15): 115
VAR (61-68): Nigeria
VAR (97-102): Tibet
PARAM (117-120): 100
PARAM (140-142): 10
VAR (184-190): Brazil
VAR (242-248): Brazil
PARAM (252-254): 10
VAR (296-303): Nigeria
PARAM (374-377): 100
PARAM (383-386): 105
PARAM (392-395): 110
PARAM (401-404): 115
VAR (420-426): Brazil
VAR (429-436): Nigeria
VAR (439-444): Tibet

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Sihat == 1, and Brazil == 1, and Height100 == 1, then Sihat is the 100 ft tall waterfall located in Brazil.

### Decision variables:
-   Names of the waterfalls: Sihat, Rhoqua, Nyalt, Inawatai (all different, 1 to 4)
-   Heights of the waterfalls: Height100, Height105, Height110, Height115 (all different, 1 to 4)
-   Countries where the waterfalls are located: Brazil, Nigeria, Tibet, Switzerland (all different, 1 to 4)

### Constraints:
-   The 115 ft tall waterfall is either the waterfall in Nigeria or the waterfall located in Tibet:
    This is a constraint that states that the 115 ft tall waterfall is either in Nigeria or Tibet, but not both. So:
    Xor([Height115 == Nigeria, Height115 == Tibet]).

-   Inawatai is 100 ft tall:
    This is a direct assignment constraint:
    Inawatai == Height100.

-   Nyalt is 10 ft taller than Rhoqua:
    For this, we will need to add a constraint for each possible assignment of heights for Nyalt and Rhoqua, such that Nyalt's height is 10 greater than Rhoqua's height. So, the constraints will be of the form:
    h1 == Nyalt and h2 == Rhoqua => h1_to_int == h2_to_int + 10, for all h1, h2 in heights.

-   The waterfall in Brazil is somewhat shorter than Rhoqua:
    This is a constraint that states that the waterfall in Brazil is shorter than Rhoqua, thus:
    Rhoqua_to_int > Brazil_to_int.

-   The waterfall in Brazil is 10 ft shorter than the waterfall located in Nigeria:
    For this, we will need to add a constraint for each possible assignment of heights for the waterfalls in Brazil and Nigeria, such that the waterfall in Brazil is 10 ft shorter than the waterfall in Nigeria. So, the constraints will be of the form:
    h1 == Brazil and h2 == Nigeria => h1_to_int == h2_to_int - 10, for all h1, h2 in heights.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Sihat == 1, and Brazil == 1, and Height100 == 1, then Sihat is the 100 ft tall waterfall located in Brazil.

### Decision variables:
-   Names of the waterfalls: Sihat, Rhoqua, Nyalt, Inawatai (all different, 1 to 4)
-   Heights of the waterfalls: Height100, Height105, Height110, Height115 (all different, 1 to 4)
-   Countries where the waterfalls are located: Brazil, Nigeria, Tibet, Switzerland (all different, 1 to 4)

### Constraints:
-   The 115 ft tall waterfall is either the waterfall in Nigeria or the waterfall located in Tibet:
    This is a constraint that states that the 115 ft tall waterfall is either in Nigeria or Tibet, but not both. So:
    Xor([Height115 == Nigeria, Height115 == Tibet]).

-   Inawatai is 100 ft tall:
    This is a direct assignment constraint:
    Inawatai == Height100.

-   Nyalt is 10 ft taller than Rhoqua:
    For this, we will need to add a constraint for each possible assignment of heights for Nyalt and Rhoqua, such that Nyalt's height is 10 greater than Rhoqua's height. So, the constraints will be of the form:
    h1 == Nyalt and h2 == Rhoqua => h1_to_int == h2_to_int + 10, for all h1, h2 in heights.

-   The waterfall in Brazil is somewhat shorter than Rhoqua:
    This is a constraint that states that the waterfall in Brazil is shorter than Rhoqua, thus:
    Rhoqua_to_int > Brazil_to_int.

-   The waterfall in Brazil is 10 ft shorter than the waterfall located in Nigeria:
    For this, we will need to add a constraint for each possible assignment of heights for the waterfalls in Brazil and Nigeria, such that the waterfall in Brazil is 10 ft shorter than the waterfall in Nigeria. So, the constraints will be of the form:
    h1 == Brazil and h2 == Nigeria => h1_to_int == h2_to_int - 10, for all h1, h2 in heights.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of waterfall, height, and country)
# e.g. if sihat == 1 and height100 == 1 and brazil == 1, then Sihat is the 100 ft tall waterfall located in Brazil
sihat, rhoqua, nyalt, inawatai = waterfalls = intvar(1, 4, shape=4)
height100, height105, height110, height115 = heights = intvar(1, 4, shape=4)
brazil, nigeria, tibet, switzerland = countries = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
waterfall_to_int = None  # N/A
height_to_int = {height100: 100, height105: 105, height110: 110, height115: 115}  # in feet
country_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def taller_than(var1, var2, diff):
    """
    Formulate the constraint that var1 is diff feet taller than var2.
    """
    return [((h1 == var1) & (h2 == var2)).implies(height_to_int[h1] == height_to_int[h2] + diff)
            for h1 in heights for h2 in heights]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(waterfalls)
m += AllDifferent(heights)
m += AllDifferent(countries)

# Clue 1: The 115 ft tall waterfall is either the waterfall in Nigeria or the waterfall located in Tibet:
m += Xor([height115 == nigeria, height115 == tibet])

# Clue 2: Inawatai is 100 ft tall:
m += inawatai == height100

# Clue 3: Nyalt is 10 ft taller than Rhoqua:
m += taller_than(nyalt, rhoqua, 10)

# Clue 4: The waterfall in Brazil is somewhat shorter than Rhoqua:
m += rhoqua > brazil

# Clue 5: The waterfall in Brazil is 10 ft shorter than the waterfall located in Nigeria:
m += [((h1 == brazil) & (h2 == nigeria)).implies(height_to_int[h1] == height_to_int[h2] - 10)
      for h1 in heights for h2 in heights]

```
True
False
False
Wrong: 1, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Evan played 9 games.
Vincent played first base.
The player who played third base played 2 more games than the person who played center field.
Charles played 2 more games than the player who played center field.
Charles was either the boy who played 9 games or the person who played 10 games.

Entities:
players: Charles, Evan, Karl, Vincent
games: 8, 9, 10, 11
positions: center field, first base, shortstop, third base
PARAM (20-21): 9
VAR (80-90): third base
PARAM (98-99): 2
VAR (138-150): center field
PARAM (168-169): 2
VAR (208-220): center field
PARAM (261-262): 9
PARAM (294-296): 10
PARAM (366-367): 8
PARAM (370-371): 9
PARAM (374-376): 10
PARAM (379-381): 11
VAR (434-439): third

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Charles == 1, and Evan == 1, and Karl == 1, then Charles is the player who played 9 games.

### Decision variables:
-   Names of the players: Charles, Evan, Karl, Vincent (all different, 1 to 4)
-   Number of games played: 8, 9, 10, 11 (all different, 1 to 4)
-   Positions played: CenterField, FirstBase, Shortstop, ThirdBase (all different, 1 to 4)

### Constraints:
-   Evan played 9 games:
    This is a direct assignment constraint:
    Evan == 9.

-   Vincent played first base:
    This is a direct assignment constraint:
    Vincent == FirstBase.

-   The player who played third base played 2 more games than the person who played center field:
    For this, we will need to add a constraint for each possible assignment of the number of games played by the player who played third base and the person who played center field, such that the player who played third base played 2 more games than the person who played center field. So, the constraints will be of the form:
    g1 == ThirdBase and g2 == CenterField => g1_to_int == g2_to_int + 2, for all g1, g2 in games played.

-   Charles played 2 more games than the player who played center field:
    For this, we will need to add a constraint for each possible assignment of the number of games played by Charles and the person who played center field, such that Charles played 2 more games than the person who played center field. So, the constraints will be of the form:
    g1 == Charles and g2 == CenterField => g1_to_int == g2_to_int + 2, for all g1, g2 in games played.

-   Charles was either the boy who played 9 games or the person who played 10 games:
    This is a constraint that states that Charles played either 9 or 10 games, but not both. So:
    Xor([Charles == 9, Charles == 10]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Charles == 1, and Evan == 1, and Karl == 1, then Charles is the player who played 9 games.

### Decision variables:
-   Names of the players: Charles, Evan, Karl, Vincent (all different, 1 to 4)
-   Number of games played: 8, 9, 10, 11 (all different, 1 to 4)
-   Positions played: CenterField, FirstBase, Shortstop, ThirdBase (all different, 1 to 4)

### Constraints:
-   Evan played 9 games:
    This is a direct assignment constraint:
    Evan == 9.

-   Vincent played first base:
    This is a direct assignment constraint:
    Vincent == FirstBase.

-   The player who played third base played 2 more games than the person who played center field:
    For this, we will need to add a constraint for each possible assignment of the number of games played by the player who played third base and the person who played center field, such that the player who played third base played 2 more games than the person who played center field. So, the constraints will be of the form:
    g1 == ThirdBase and g2 == CenterField => g1_to_int == g2_to_int + 2, for all g1, g2 in games played.

-   Charles played 2 more games than the player who played center field:
    For this, we will need to add a constraint for each possible assignment of the number of games played by Charles and the person who played center field, such that Charles played 2 more games than the person who played center field. So, the constraints will be of the form:
    g1 == Charles and g2 == CenterField => g1_to_int == g2_to_int + 2, for all g1, g2 in games played.

-   Charles was either the boy who played 9 games or the person who played 10 games:
    This is a constraint that states that Charles played either 9 or 10 games, but not both. So:
    Xor([Charles == 9, Charles == 10]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of player, game, and position)
# e.g. if charles == 1 and evan == 1 and karl == 1, then Charles is the player who played 9 games
charles, evan, karl, vincent = players = intvar(1, 4, shape=4)
games8, games9, games10, games11 = games = intvar(1, 4, shape=4)
center_field, first_base, shortstop, third_base = positions = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
player_to_int = None  # N/A
game_to_int = {games8: 8, games9: 9, games10: 10, games11: 11}  # number of games
position_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def played_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 played more games than var2 by diff.
    """
    return [((v1 == var1) & (v2 == var2)).implies(game_to_int[v1] == game_to_int[v2] + diff)
            for v1 in games for v2 in games]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(players)
m += AllDifferent(games)
m += AllDifferent(positions)

# Clue 1: Evan played 9 games
m += evan == games9

# Clue 2: Vincent played first base
m += vincent == first_base

# Clue 3: The player who played third base played 2 more games than the person who played center field
m += played_more_than(third_base, center_field, 2)

# Clue 4: Charles played 2 more games than the player who played center field
m += played_more_than(charles, center_field, 2)

# Clue 5: Charles was either the boy who played 9 games or the person who played 10 games
m += Xor([charles == games9, charles == games10])

```
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Edmund paid 1 dollar less than the one who got the water.
The diner who paid $4 had the iced tea.
Angela paid more than the one who got the cream soda.
The diner who paid $5 was either the one who got the cream soda or the one who got the iced tea.
The four diners were the diner who paid $5, the one who got the iced tea, the one who got the root beer and Irene.

Entities:
names: Angela, Edmund, Homer, Irene
prices: $4, $5, $6, $7
drinks: cream soda, iced tea, root beer, water
VAR (8-14): Edmund
PARAM (20-21): 1
PARAM (88-89): 4
PARAM (185-186): 5
PARAM (305-306): 5
VAR (401-407): Angela
OBJ_NAME (433-439): prices
PARAM (444-445): 4
PARAM (450-451): 5
PARAM (456-457): 6
PARAM (462-463): 7

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Angela == 1, and $4 == 1, and CreamSoda == 1, then Angela paid $4 for the cream soda.

### Decision variables:
-   Names of the diners: Angela, Edmund, Homer, Irene (all different, 1 to 4)
-   Prices paid: $4, $5, $6, $7 (all different, 1 to 4)
-   Drinks ordered: CreamSoda, IcedTea, RootBeer, Water (all different, 1 to 4)

### Constraints:
-   Edmund paid 1 dollar less than the one who got the water:
    For this, we will need to add a constraint for each possible assignment of prices for Edmund and the water, such that Edmund's price is 1 less than the water's price. So, the constraints will be of the form:
    p1 == Edmund and p2 == Water => p1_to_int == p2_to_int - 1, for all p1, p2 in prices.

-   The diner who paid $4 had the iced tea:
    This is a direct assignment constraint:
    $4 == IcedTea.

-   Angela paid more than the one who got the cream soda:
    For this, we will need to add a constraint for each possible assignment of prices for Angela and the cream soda, such that Angela's price is greater than the cream soda's price. So, the constraints will be of the form:
    p1 == Angela and p2 == CreamSoda => p1_to_int > p2_to_int, for all p1, p2 in prices.

-   The diner who paid $5 was either the one who got the cream soda or the one who got the iced tea:
    This is a constraint that states that the diner who paid $5 is either the one who got the cream soda or the one who got the iced tea, but not both. So:
    Xor([$5 == CreamSoda, $5 == IcedTea]).

-   The four diners were the diner who paid $5, the one who got the iced tea, the one who got the root beer, and Irene:
    This is a constraint that states that all these entities are different, thus:
    AllDifferent([$5, IcedTea, RootBeer, Irene]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Angela == 1, and $4 == 1, and CreamSoda == 1, then Angela paid $4 for the cream soda.

### Decision variables:
-   Names of the diners: Angela, Edmund, Homer, Irene (all different, 1 to 4)
-   Prices paid: $4, $5, $6, $7 (all different, 1 to 4)
-   Drinks ordered: CreamSoda, IcedTea, RootBeer, Water (all different, 1 to 4)

### Constraints:
-   Edmund paid 1 dollar less than the one who got the water:
    For this, we will need to add a constraint for each possible assignment of prices for Edmund and the water, such that Edmund's price is 1 less than the water's price. So, the constraints will be of the form:
    p1 == Edmund and p2 == Water => p1_to_int == p2_to_int - 1, for all p1, p2 in prices.

-   The diner who paid $4 had the iced tea:
    This is a direct assignment constraint:
    $4 == IcedTea.

-   Angela paid more than the one who got the cream soda:
    For this, we will need to add a constraint for each possible assignment of prices for Angela and the cream soda, such that Angela's price is greater than the cream soda's price. So, the constraints will be of the form:
    p1 == Angela and p2 == CreamSoda => p1_to_int > p2_to_int, for all p1, p2 in prices.

-   The diner who paid $5 was either the one who got the cream soda or the one who got the iced tea:
    This is a constraint that states that the diner who paid $5 is either the one who got the cream soda or the one who got the iced tea, but not both. So:
    Xor([$5 == CreamSoda, $5 == IcedTea]).

-   The four diners were the diner who paid $5, the one who got the iced tea, the one who got the root beer, and Irene:
    This is a constraint that states that all these entities are different, thus:
    AllDifferent([$5, IcedTea, RootBeer, Irene]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of diner, price, and drink)
# e.g. if angela == 1 and price4 == 1 and cream_soda == 1, then Angela paid $4 for the cream soda
angela, edmund, homer, irene = diners = intvar(1, 4, shape=4)
price4, price5, price6, price7 = prices = intvar(1, 4, shape=4)
cream_soda, iced_tea, root_beer, water = drinks = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
diner_to_int = None  # N/A
price_to_int = {price4: 4, price5: 5, price6: 6, price7: 7}  # in dollars
drink_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def paid_less_than(var1, var2):
    """
    Formulate the constraint that var1 paid 1 dollar less than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] - 1)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(diners)
m += AllDifferent(prices)
m += AllDifferent(drinks)

# Clue 1: Edmund paid 1 dollar less than the one who got the water:
m += paid_less_than(edmund, water)

# Clue 2: The diner who paid $4 had the iced tea:
m += price4 == iced_tea

# Clue 3: Angela paid more than the one who got the cream soda:
m += [((p1 == angela) & (p2 == cream_soda)).implies(price_to_int[p1] > price_to_int[p2)
      for p1 in prices for p2 in prices]

# Clue 4: The diner who paid $5 was either the one who got the cream soda or the one who got the iced tea:
m += Xor([price5 == cream_soda, price5 == iced_tea])

# Clue 5: The four diners were the diner who paid $5, the one who got the iced tea, the one who got the root beer, and Irene:
m += AllDifferent([price5, iced_tea, root_beer, irene])

```
Error: invalid syntax (<string>, line 1)
False
False
Error: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
Ingram had 7 goals this season.
The four players are Underwood, the player from the Ice Hogs, the player from the Monsters and the player from the Checkers.
Parrish scored 1 goal more than Quinn.
The player with 9 goals is from the Ice Hogs.
Ingram is either the player from the Checkers or the player with 6 goals.

Entities:
players: Ingram, Parrish, Quinn, Underwood
goals: 6, 7, 8, 9
teams: Checkers, Comets, Ice Hogs, Monsters
LIMIT (19-20): 7
VAR (94-102): Ice Hogs
VAR (125-133): Monsters
VAR (158-166): Checkers
VAR (169-176): Parrish
PARAM (184-185): 1
PARAM (225-226): 9
VAR (245-253): Ice Hogs
VAR (293-301): Checkers
PARAM (321-322): 6
VAR (361-368): Parrish
PARAM (397-398): 6
PARAM (401-402): 7
PARAM (405-406): 8
PARAM (409-410): 9
VAR (419-427): Checkers
VAR (430-436): Comets
VAR (439-447): Ice Hogs
VAR (450-458): Monsters

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ingram == 1, and Checkers == 1, and SixGoals == 1, then Ingram is the player from the Checkers with 6 goals.

### Decision variables:
-   Names of the players: Ingram, Parrish, Quinn, Underwood (all different, 1 to 4)
-   Number of goals: SixGoals, SevenGoals, EightGoals, NineGoals (all different, 1 to 4)
-   Teams: Checkers, Comets, Ice Hogs, Monsters (all different, 1 to 4)

### Constraints:
-   Ingram had 7 goals this season:
    This is a direct assignment constraint:
    Ingram == SevenGoals.

-   The four players are Underwood, the player from the Ice Hogs, the player from the Monsters, and the player from the Checkers:
    This is a constraint that states that all these entities are different, thus:
    AllDifferent([Underwood, IceHogs, Monsters, Checkers]).

-   Parrish scored 1 goal more than Quinn:
    For this, we will need to add a constraint for each possible assignment of goals for Parrish and Quinn, such that Parrish's goals are 1 more than Quinn's goals. So, the constraints will be of the form:
    g1 == Parrish and g2 == Quinn => g1_to_int == g2_to_int + 1, for all g1, g2 in goals.

-   The player with 9 goals is from the Ice Hogs:
    This is a direct assignment constraint:
    IceHogs == NineGoals.

-   Ingram is either the player from the Checkers or the player with 6 goals:
    This is a constraint that states that Ingram is either the player from the Checkers or the player with 6 goals, but not both. So:
    Xor([Ingram == Checkers, Ingram == SixGoals]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ingram == 1, and Checkers == 1, and SixGoals == 1, then Ingram is the player from the Checkers with 6 goals.

### Decision variables:
-   Names of the players: Ingram, Parrish, Quinn, Underwood (all different, 1 to 4)
-   Number of goals: SixGoals, SevenGoals, EightGoals, NineGoals (all different, 1 to 4)
-   Teams: Checkers, Comets, Ice Hogs, Monsters (all different, 1 to 4)

### Constraints:
-   Ingram had 7 goals this season:
    This is a direct assignment constraint:
    Ingram == SevenGoals.

-   The four players are Underwood, the player from the Ice Hogs, the player from the Monsters, and the player from the Checkers:
    This is a constraint that states that all these entities are different, thus:
    AllDifferent([Underwood, IceHogs, Monsters, Checkers]).

-   Parrish scored 1 goal more than Quinn:
    For this, we will need to add a constraint for each possible assignment of goals for Parrish and Quinn, such that Parrish's goals are 1 more than Quinn's goals. So, the constraints will be of the form:
    g1 == Parrish and g2 == Quinn => g1_to_int == g2_to_int + 1, for all g1, g2 in goals.

-   The player with 9 goals is from the Ice Hogs:
    This is a direct assignment constraint:
    IceHogs == NineGoals.

-   Ingram is either the player from the Checkers or the player with 6 goals:
    This is a constraint that states that Ingram is either the player from the Checkers or the player with 6 goals, but not both. So:
    Xor([Ingram == Checkers, Ingram == SixGoals]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of player, goals, and team)
# e.g. if ingram == 1 and checkers == 1 and six_goals == 1, then Ingram is the player from the Checkers with 6 goals
ingram, parrish, quinn, underwood = players = intvar(1, 4, shape=4)
six_goals, seven_goals, eight_goals, nine_goals = goals = intvar(1, 4, shape=4)
checkers, comets, ice_hogs, monsters = teams = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
player_to_int = None  # N/A
goals_to_int = {six_goals: 6, seven_goals: 7, eight_goals: 8, nine_goals: 9}  # in goals
team_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def scored_more_than(var1, var2):
    """
    Formulate the constraint that var1 scored more goals than var2.
    """
    return [((g1 == var1) & (g2 == var2)).implies(goals_to_int[g1] > goals_to_int[g2])
            for g1 in goals for g2 in goals]


def scored_exactly_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 scored exactly diff more goals than var2.
    """
    return [((g1 == var1) & (g2 == var2)).implies(goals_to_int[g1] == goals_to_int[g2] + diff)
            for g1 in goals for g2 in goals]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(players)
m += AllDifferent(goals)
m += AllDifferent(teams)

# Clue 1: Ingram had 7 goals this season:
m += ingram == seven_goals

# Clue 2: The four players are Underwood, the player from the Ice Hogs, the player from the Monsters, and the player from the Checkers:
m += AllDifferent([underwood, ice_hogs, monsters, checkers])

# Clue 3: Parrish scored 1 goal more than Quinn:
m += scored_exactly_more_than(parrish, quinn, 1)

# Clue 4: The player with 9 goals is from the Ice Hogs:
m += ice_hogs == nine_goals

# Clue 5: Ingram is either the player from the Checkers or the player with 6 goals:
m += Xor([ingram == checkers, ingram == six_goals])

```
False
False
True
Error: list.remove(x): x not in list
---------------------------------------------------------------------------------------------

Clues:
Jorge is either the skydiver who wears the red suit or the jumper who started in 1982.
The skydiver who wears the pink suit started skydiving 1 year before Otis.
The jumper who wears the yellow suit started skydiving sometime after Philip.
The jumper who wears the lime green suit started skydiving sometime after the jumper who wears the yellow suit.
The jumper who wears the pink suit started skydiving 2 years before Shaun.

Entities:
names: Jorge, Otis, Philip, Shaun
years: 1982, 1983, 1984, 1985
suit colors: lime green, pink, red, yellow
VAR (51-59): red suit
VAR (123-132): pink suit
PARAM (151-152): 1
VAR (197-208): yellow suit
VAR (276-291): lime green suit
VAR (350-361): yellow suit
VAR (389-398): pink suit
PARAM (417-418): 2
PARAM (497-501): 1982
PARAM (504-508): 1983
PARAM (511-515): 1984
PARAM (518-522): 1985

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Jorge == 1, and RedSuit == 1, and Year1982 == 1, then Jorge is the skydiver who wears the red suit and started in 1982.

### Decision variables:
-   Names of the skydivers: Jorge, Otis, Philip, Shaun (all different, 1 to 4)
-   Suit colors: LimeGreen, Pink, Red, Yellow (all different, 1 to 4)
-   Years of starting skydiving: 1982, 1983, 1984, 1985 (all different, 1 to 4)

### Constraints:
-   Jorge is either the skydiver who wears the red suit or the jumper who started in 1982:
    This is a constraint that states that Jorge is either the skydiver who wears the red suit or the jumper who started in 1982, but not both. So:
    Xor([Jorge == RedSuit, Jorge == Year1982]).

-   The skydiver who wears the pink suit started skydiving 1 year before Otis:
    For this, we will need to add a constraint for each possible assignment of the years for the skydivers wearing the pink suit and Otis, such that the skydiver wearing the pink suit's year is 1 less than Otis's year. So, the constraints will be of the form:
    y1 == PinkSuit and y2 == Otis => y1_to_int == y2_to_int - 1, for all y1, y2 in years.

-   The jumper who wears the yellow suit started skydiving sometime after Philip:
    For this, we will need to add a constraint for each possible assignment of the years for the skydivers wearing the yellow suit and Philip, such that the skydiver wearing the yellow suit's year is greater than Philip's year. So, the constraints will be of the form:
    y1 == YellowSuit and y2 == Philip => y1_to_int > y2_to_int, for all y1, y2 in years.

-   The jumper who wears the lime green suit started skydiving sometime after the jumper who wears the yellow suit:
    For this, we will need to add a constraint for each possible assignment of the years for the skydivers wearing the lime green suit and the yellow suit, such that the skydiver wearing the lime green suit's year is greater than the skydiver wearing the yellow suit's year. So, the constraints will be of the form:
    y1 == LimeGreenSuit and y2 == YellowSuit => y1_to_int > y2_to_int, for all y1, y2 in years.

-   The jumper who wears the pink suit started skydiving 2 years before Shaun:
    For this, we will need to add a constraint for each possible assignment of the years for the skydivers wearing the pink suit and Shaun, such that the skydiver wearing the pink suit's year is 2 less than Shaun's year. So, the constraints will be of the form:
    y1 == PinkSuit and y2 == Shaun => y1_to_int == y2_to_int - 2, for all y1, y2 in years.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Jorge == 1, and RedSuit == 1, and Year1982 == 1, then Jorge is the skydiver who wears the red suit and started in 1982.

### Decision variables:
-   Names of the skydivers: Jorge, Otis, Philip, Shaun (all different, 1 to 4)
-   Suit colors: LimeGreen, Pink, Red, Yellow (all different, 1 to 4)
-   Years of starting skydiving: 1982, 1983, 1984, 1985 (all different, 1 to 4)

### Constraints:
-   Jorge is either the skydiver who wears the red suit or the jumper who started in 1982:
    This is a constraint that states that Jorge is either the skydiver who wears the red suit or the jumper who started in 1982, but not both. So:
    Xor([Jorge == RedSuit, Jorge == Year1982]).

-   The skydiver who wears the pink suit started skydiving 1 year before Otis:
    For this, we will need to add a constraint for each possible assignment of the years for the skydivers wearing the pink suit and Otis, such that the skydiver wearing the pink suit's year is 1 less than Otis's year. So, the constraints will be of the form:
    y1 == PinkSuit and y2 == Otis => y1_to_int == y2_to_int - 1, for all y1, y2 in years.

-   The jumper who wears the yellow suit started skydiving sometime after Philip:
    For this, we will need to add a constraint for each possible assignment of the years for the skydivers wearing the yellow suit and Philip, such that the skydiver wearing the yellow suit's year is greater than Philip's year. So, the constraints will be of the form:
    y1 == YellowSuit and y2 == Philip => y1_to_int > y2_to_int, for all y1, y2 in years.

-   The jumper who wears the lime green suit started skydiving sometime after the jumper who wears the yellow suit:
    For this, we will need to add a constraint for each possible assignment of the years for the skydivers wearing the lime green suit and the yellow suit, such that the skydiver wearing the lime green suit's year is greater than the skydiver wearing the yellow suit's year. So, the constraints will be of the form:
    y1 == LimeGreenSuit and y2 == YellowSuit => y1_to_int > y2_to_int, for all y1, y2 in years.

-   The jumper who wears the pink suit started skydiving 2 years before Shaun:
    For this, we will need to add a constraint for each possible assignment of the years for the skydivers wearing the pink suit and Shaun, such that the skydiver wearing the pink suit's year is 2 less than Shaun's year. So, the constraints will be of the form:
    y1 == PinkSuit and y2 == Shaun => y1_to_int == y2_to_int - 2, for all y1, y2 in years.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of skydiver, suit color, and year)
# e.g. if jorge == 1 and red_suit == 1 and year1982 == 1, then Jorge wears the red suit and started skydiving in 1982
jorge, otis, philip, shaun = skydivers = intvar(1, 4, shape=4)
red_suit, pink_suit, lime_green_suit, yellow_suit = suits = intvar(1, 4, shape=4)
year1982, year1983, year1984, year1985 = years = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
skydiver_to_int = None  # N/A
suit_to_int = None  # N/A
year_to_int = {year1982: 1982, year1983: 1983, year1984: 1984, year1985: 1985}  # in years


# Helper functions (for formulating comparison constraints)
def started_after_than(var1, var2):
    """
    Formulate the constraint that var1 started after var2.
    """
    return [((y1 == var1) & (y2 == var2)).implies(year_to_int[y1] > year_to_int[y2])
            for y1 in years for y2 in years]


def started_exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 started exactly diff years after var2.
    """
    return [((y1 == var1) & (y2 == var2)).implies(year_to_int[y1] == year_to_int[y2] + diff)
            for y1 in years for y2 in years]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(skydivers)
m += AllDifferent(suits)
m += AllDifferent(years)

# Clue 1: Jorge is either the skydiver who wears the red suit or the jumper who started in 1982:
m += Xor([jorge == red_suit, jorge == year1982])

# Clue 2: The skydiver who wears the pink suit started skydiving 1 year before Otis:
m += started_exactly_after_than(pink_suit, otis, -1)

# Clue 3: The jumper who wears the yellow suit started skydiving sometime after Philip:
m += started_after_than(yellow_suit, philip)

# Clue 4: The jumper who wears the lime green suit started skydiving sometime after the jumper who wears the yellow suit:
m += started_after_than(lime_green_suit, yellow_suit)

# Clue 5: The jumper who wears the pink suit started skydiving 2 years before Shaun:
m += started_exactly_after_than(pink_suit, shaun, -2)

```
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The variety that requires 190 degree water costs 1 dollar less than the variety that requires 195 degree water.
The Pouchong costs 1 dollar less than the Red Robe.
The Pouchong needs 195 degree water.
The four teas are the Ali Shan, the variety that costs $6, the variety that requires 200 degree water and the tea that requires 190 degree water.

Entities:
teas: Ali Shan, Jin Xuan, Pouchong, Red Robe
prices: $4, $5, $6, $7
temperatures: 190 degree, 195 degree, 200 degree, 215 degree
VAR (12-19): variety
PARAM (34-37): 190
PARAM (57-58): 1
PARAM (66-70): less
PARAM (102-105): 195
VAR (125-133): Pouchong
PARAM (140-141): 1
VAR (178-186): Pouchong
PARAM (193-196): 195
VAR (249-256): variety
PARAM (270-271): 6
VAR (278-285): variety
PARAM (300-303): 200
VAR (325-328): tea
PARAM (343-346): 190
VAR (402-410): Pouchong
VAR (417-421): Robe
PARAM (433-434): 4
PARAM (439-440): 5
PARAM (445-446): 6
PARAM (451-452): 7
PARAM (468-471): 190
PARAM (481-484): 195
PARAM (494-497): 200
PARAM (507-510): 215

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if AliShan == 1, and Price4 == 1, and Temp190 == 1, then the Ali Shan tea costs $4 and requires 190-degree water.

### Decision variables:
-   Names of the teas: AliShan, JinXuan, Pouchong, RedRobe (all different, 1 to 4)
-   Prices of the teas: Price4, Price5, Price6, Price7 (all different, 1 to 4)
-   Water temperatures required: Temp190, Temp195, Temp200, Temp215 (all different, 1 to 4)

### Constraints:
-   The variety that requires 190-degree water costs 1 dollar less than the variety that requires 195-degree water:
    For this, we will need to add a constraint for each possible assignment of teas requiring 190-degree and 195-degree water, such that the tea requiring 190-degree water costs $1 less than the tea requiring 195-degree water. So, the constraints will be of the form:
    t1 == Temp190 and t2 == Temp195 => p1_to_int == p2_to_int - 1, for all t1, t2 in teas.

-   The Pouchong costs 1 dollar less than the Red Robe:
    For this, we will need to add a constraint that states that the Pouchong tea costs $1 less than the Red Robe tea. So:
    Pouchong_to_int == RedRobe_to_int - 1.

-   The Pouchong needs 195-degree water:
    This is a direct assignment constraint:
    Pouchong == Temp195.

-   The four teas are the Ali Shan, the variety that costs $6, the variety that requires 200-degree water, and the tea that requires 190-degree water:
    This constraint states that the four teas are Ali Shan, the tea costing $6, the tea requiring 200-degree water, and the tea requiring 190-degree water. So, we need to assign these values accordingly.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if AliShan == 1, and Price4 == 1, and Temp190 == 1, then the Ali Shan tea costs $4 and requires 190-degree water.

### Decision variables:
-   Names of the teas: AliShan, JinXuan, Pouchong, RedRobe (all different, 1 to 4)
-   Prices of the teas: Price4, Price5, Price6, Price7 (all different, 1 to 4)
-   Water temperatures required: Temp190, Temp195, Temp200, Temp215 (all different, 1 to 4)

### Constraints:
-   The variety that requires 190-degree water costs 1 dollar less than the variety that requires 195-degree water:
    For this, we will need to add a constraint for each possible assignment of teas requiring 190-degree and 195-degree water, such that the tea requiring 190-degree water costs $1 less than the tea requiring 195-degree water. So, the constraints will be of the form:
    t1 == Temp190 and t2 == Temp195 => p1_to_int == p2_to_int - 1, for all t1, t2 in teas.

-   The Pouchong costs 1 dollar less than the Red Robe:
    For this, we will need to add a constraint that states that the Pouchong tea costs $1 less than the Red Robe tea. So:
    Pouchong_to_int == RedRobe_to_int - 1.

-   The Pouchong needs 195-degree water:
    This is a direct assignment constraint:
    Pouchong == Temp195.

-   The four teas are the Ali Shan, the variety that costs $6, the variety that requires 200-degree water, and the tea that requires 190-degree water:
    This constraint states that the four teas are Ali Shan, the tea costing $6, the tea requiring 200-degree water, and the tea requiring 190-degree water. So, we need to assign these values accordingly.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of tea, price, and temperature)
# e.g. if alishan == 1 and price4 == 1 and temp190 == 1, then the Ali Shan tea costs $4 and requires 190-degree water
alishan, jinxuan, pouchong, redrobe = teas = intvar(1, 4, shape=4)
price4, price5, price6, price7 = prices = intvar(1, 4, shape=4)
temp190, temp195, temp200, temp215 = temperatures = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
tea_to_int = None  # N/A
price_to_int = {price4: 4, price5: 5, price6: 6, price7: 7}  # in dollars
temp_to_int = {temp190: 190, temp195: 195, temp200: 200, temp215: 215}  # in degrees


# Helper functions (for formulating comparison constraints)
def costs_less_than(var1, var2):
    """
    Formulate the constraint that var1 costs 1 dollar less than var2.
    """
    return [((t1 == var1) & (t2 == var2)).implies(price_to_int[t1] == price_to_int[t2] - 1)
            for t1 in prices for t2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(teas)
m += AllDifferent(prices)
m += AllDifferent(temperatures)

# Clue 1: The variety that requires 190-degree water costs 1 dollar less than the variety that requires 195-degree water:
m += costs_less_than(temp190, temp195)

# Clue 2: The Pouchong costs 1 dollar less than the Red Robe:
m += pouchong == redrobe - 1

# Clue 3: The Pouchong needs 195-degree water:
m += pouchong == temp195

# Clue 4: The four teas are the Ali Shan, the variety that costs $6, the variety that requires 200-degree water, and the tea that requires 190-degree water:
m += [alishan == 1, price6 == 2, temp200 == 3, temp190 == 4]

```
True
False
False
Wrong: 2, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The flier leaving in April will bring shamrock.
The passenger with the rabbit's foot will leave 1 month after Troy.
The flier with the horseshoe will leave 1 month after Doug.
The flier with the horseshoe is either Peggy or the passenger leaving in January.

Entities:
fliers: Doug, Eloise, Peggy, Troy
months: January, February, March, April
lucky charms: coin, horseshoe, rabbit's foot, shamrock
PARAM (106-107): 1
PARAM (167-168): 1

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Doug == 1, and January == 1, and Coin == 1, then Doug is the flier leaving in January with a coin.

### Decision variables:
-   Names of the fliers: Doug, Eloise, Peggy, Troy (all different, 1 to 4)
-   Months of departure: January, February, March, April (all different, 1 to 4)
-   Lucky charms: Coin, Horseshoe, RabbitFoot, Shamrock (all different, 1 to 4)

### Constraints:
-   The flier leaving in April will bring shamrock:
    This is a direct assignment constraint:
    April == Shamrock.

-   The passenger with the rabbit's foot will leave 1 month after Troy:
    For this, we will need to add a constraint for each possible assignment of the months of departure for the flier with the rabbit's foot and Troy, such that the flier with the rabbit's foot's month of departure is 1 more than Troy's month of departure. So, the constraints will be of the form:
    m1 == RabbitFoot and m2 == Troy => m1_to_int == m2_to_int + 1, for all m1, m2 in months of departure.

-   The flier with the horseshoe will leave 1 month after Doug:
    For this, we will need to add a constraint for each possible assignment of the months of departure for the flier with the horseshoe and Doug, such that the flier with the horseshoe's month of departure is 1 more than Doug's month of departure. So, the constraints will be of the form:
    m1 == Horseshoe and m2 == Doug => m1_to_int == m2_to_int + 1, for all m1, m2 in months of departure.

-   The flier with the horseshoe is either Peggy or the passenger leaving in January:
    This is a constraint that states that the flier with the horseshoe is either Peggy or the flier leaving in January, but not both. So:
    Xor([Peggy == Horseshoe, January == Horseshoe]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Doug == 1, and January == 1, and Coin == 1, then Doug is the flier leaving in January with a coin.

### Decision variables:
-   Names of the fliers: Doug, Eloise, Peggy, Troy (all different, 1 to 4)
-   Months of departure: January, February, March, April (all different, 1 to 4)
-   Lucky charms: Coin, Horseshoe, RabbitFoot, Shamrock (all different, 1 to 4)

### Constraints:
-   The flier leaving in April will bring shamrock:
    This is a direct assignment constraint:
    April == Shamrock.

-   The passenger with the rabbit's foot will leave 1 month after Troy:
    For this, we will need to add a constraint for each possible assignment of the months of departure for the flier with the rabbit's foot and Troy, such that the flier with the rabbit's foot's month of departure is 1 more than Troy's month of departure. So, the constraints will be of the form:
    m1 == RabbitFoot and m2 == Troy => m1_to_int == m2_to_int + 1, for all m1, m2 in months of departure.

-   The flier with the horseshoe will leave 1 month after Doug:
    For this, we will need to add a constraint for each possible assignment of the months of departure for the flier with the horseshoe and Doug, such that the flier with the horseshoe's month of departure is 1 more than Doug's month of departure. So, the constraints will be of the form:
    m1 == Horseshoe and m2 == Doug => m1_to_int == m2_to_int + 1, for all m1, m2 in months of departure.

-   The flier with the horseshoe is either Peggy or the passenger leaving in January:
    This is a constraint that states that the flier with the horseshoe is either Peggy or the flier leaving in January, but not both. So:
    Xor([Peggy == Horseshoe, January == Horseshoe]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of flier, month, and lucky charm)
# e.g. if doug == 1 and january == 1 and coin == 1, then Doug is the flier leaving in January with a coin
doug, eloise, peggy, troy = fliers = intvar(1, 4, shape=4)
january, february, march, april = months = intvar(1, 4, shape=4)
coin, horseshoe, rabbit_foot, shamrock = lucky_charms = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
flier_to_int = None  # N/A
month_to_int = {january: 1, february: 2, march: 3, april: 4}  # in months
lucky_charm_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def leave_after_than(var1, var2):
    """
    Formulate the constraint that var1 leaves after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] > month_to_int[m2])
            for m1 in months for m2 in months]


def leave_exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 leaves exactly diff months after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] == month_to_int[m2] + diff)
            for m1 in months for m2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(fliers)
m += AllDifferent(months)
m += AllDifferent(lucky_charms)

# Clue 1: The flier leaving in April will bring shamrock:
m += april == shamrock

# Clue 2: The passenger with the rabbit's foot will leave 1 month after Troy:
m += leave_exactly_after_than(rabbit_foot, troy, 1)

# Clue 3: The flier with the horseshoe will leave 1 month after Doug:
m += leave_exactly_after_than(horseshoe, doug, 1)

# Clue 4: The flier with the horseshoe is either Peggy or the passenger leaving in January:
m += Xor([peggy == horseshoe, january == horseshoe])

```
True
True
True
Wrong: 0, Total: 7
---------------------------------------------------------------------------------------------

Clues:
Ronda's sandwich and the sandwich with havarti cheese are different sandwiches.
Ronda's order costs $5.
Lula's order is either the 3 dollars sandwich or the order that costs 5 dollars.
The sandwich with cheddar cheese costs less than the order with havarti cheese.
Yolanda's sandwich costs 2 dollars less than the order with swiss cheese.

Entities:
customers: Lula, Ronda, Sue, Yolanda
prices: $2, $3, $4, $5
cheeses: cheddar, havarti, muenster, swiss
VAR (8-25): Ronda 's sandwich
VAR (34-47): sandwich with
VAR (48-62): havarti cheese
VAR (90-95): Ronda
PARAM (113-114): 5
PARAM (145-146): 3
PARAM (188-189): 5
VAR (204-232): sandwich with cheddar cheese
PARAM (239-243): less
VAR (264-278): havarti cheese
VAR (281-300): Yolanda 's sandwich
PARAM (307-308): 2
VAR (342-354): swiss cheese
VAR (401-408): Yolanda
OBJ_NAME (409-415): prices
PARAM (420-421): 2
PARAM (426-427): 3
PARAM (432-433): 4
PARAM (438-439): 5

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Lula == 1, and Price3 == 1, and Cheddar == 1, then Lula's order is the $3 sandwich with cheddar cheese.

### Decision variables:
-   Names of the customers: Lula, Ronda, Sue, Yolanda (all different, 1 to 4)
-   Prices of the sandwiches: Price2, Price3, Price4, Price5 (all different, 1 to 4)
-   Types of cheeses: Cheddar, Havarti, Muenster, Swiss (all different, 1 to 4)

### Constraints:
-   Ronda's sandwich and the sandwich with havarti cheese are different sandwiches:
    This is a constraint that states that Ronda's sandwich and the sandwich with havarti cheese are different, thus:
    AllDifferent([Ronda, Havarti]).

-   Ronda's order costs $5:
    This is a direct assignment constraint:
    Ronda == Price5.

-   Lula's order is either the $3 sandwich or the order that costs $5:
    This is a constraint that states that Lula's order is either the $3 sandwich or the $5 sandwich, but not both. So:
    Xor([Lula == Price3, Lula == Price5]).

-   The sandwich with cheddar cheese costs less than the order with havarti cheese:
    For this, we will need to add a constraint for each possible assignment of prices for the sandwiches with cheddar and havarti cheese, such that the price of the cheddar cheese sandwich is less than the price of the havarti cheese sandwich. So, the constraints will be of the form:
    p1 == Cheddar and p2 == Havarti => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   Yolanda's sandwich costs $2 less than the order with swiss cheese:
    For this, we will need to add a constraint for each possible assignment of prices for Yolanda's sandwich and the sandwich with swiss cheese, such that Yolanda's sandwich price is $2 less than the price of the swiss cheese sandwich. So, the constraints will be of the form:
    p1 == Yolanda and p2 == Swiss => p1_to_int == p2_to_int - 2, for all p1, p2 in prices.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Lula == 1, and Price3 == 1, and Cheddar == 1, then Lula's order is the $3 sandwich with cheddar cheese.

### Decision variables:
-   Names of the customers: Lula, Ronda, Sue, Yolanda (all different, 1 to 4)
-   Prices of the sandwiches: Price2, Price3, Price4, Price5 (all different, 1 to 4)
-   Types of cheeses: Cheddar, Havarti, Muenster, Swiss (all different, 1 to 4)

### Constraints:
-   Ronda's sandwich and the sandwich with havarti cheese are different sandwiches:
    This is a constraint that states that Ronda's sandwich and the sandwich with havarti cheese are different, thus:
    AllDifferent([Ronda, Havarti]).

-   Ronda's order costs $5:
    This is a direct assignment constraint:
    Ronda == Price5.

-   Lula's order is either the $3 sandwich or the order that costs $5:
    This is a constraint that states that Lula's order is either the $3 sandwich or the $5 sandwich, but not both. So:
    Xor([Lula == Price3, Lula == Price5]).

-   The sandwich with cheddar cheese costs less than the order with havarti cheese:
    For this, we will need to add a constraint for each possible assignment of prices for the sandwiches with cheddar and havarti cheese, such that the price of the cheddar cheese sandwich is less than the price of the havarti cheese sandwich. So, the constraints will be of the form:
    p1 == Cheddar and p2 == Havarti => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   Yolanda's sandwich costs $2 less than the order with swiss cheese:
    For this, we will need to add a constraint for each possible assignment of prices for Yolanda's sandwich and the sandwich with swiss cheese, such that Yolanda's sandwich price is $2 less than the price of the swiss cheese sandwich. So, the constraints will be of the form:
    p1 == Yolanda and p2 == Swiss => p1_to_int == p2_to_int - 2, for all p1, p2 in prices.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of customer, price, and cheese)
# e.g. if lula == 1 and price3 == 1 and cheddar == 1, then Lula's order is the $3 sandwich with cheddar cheese
lula, ronda, sue, yolanda = customers = intvar(1, 4, shape=4)
price2, price3, price4, price5 = prices = intvar(1, 4, shape=4)
cheddar, havarti, muenster, swiss = cheeses = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
customer_to_int = None  # N/A
price_to_int = {price2: 2, price3: 3, price4: 4, price5: 5}  # in dollars
cheese_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def different_sandwiches(var1, var2):
    """
    Formulate the constraint that var1 and var2 are different sandwiches.
    """
    return [var1 != var2]


def sandwich_costs(var, cost):
    """
    Formulate the constraint that the sandwich ordered by var costs a specific amount.
    """
    return [var == cost]


def sandwich_either(var1, var2, cost1, cost2):
    """
    Formulate the constraint that var1's order is either cost1 or cost2.
    """
    return [Xor([var1 == cost1, var1 == cost2])]


def sandwich_costs_less(var1, var2):
    """
    Formulate the constraint that the sandwich with var1 cheese costs less than the sandwich with var2 cheese.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] < price_to_int[p2])
            for p1 in prices for p2 in prices]


def sandwich_costs_less_by(var1, var2, diff):
    """
    Formulate the constraint that the sandwich ordered by var1 costs $diff less than the sandwich ordered by var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] - diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(customers)
m += AllDifferent(prices)
m += AllDifferent(cheeses)

# Clue 1: Ronda's sandwich and the sandwich with havarti cheese are different sandwiches:
m += different_sandwiches(ronda, havarti)

# Clue 2: Ronda's order costs $5:
m += sandwich_costs(ronda, price5)

# Clue 3: Lula's order is either the $3 sandwich or the order that costs $5:
m += sandwich_either(lula, price3, price5)

# Clue 4: The sandwich with cheddar cheese costs less than the order with havarti cheese:
m += sandwich_costs_less(cheddar, havarti)

# Clue 5: Yolanda's sandwich costs $2 less than the order with swiss cheese:
m += sandwich_costs_less_by(yolanda, swiss, 2)

```
Error: invalid syntax (<string>, line 1)
False
False
Error: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
The rocket developed by Vexatech will launch 1 month after the Exatris.
The rocket developed by SpaceZen will launch sometime after the Beritron.
The Worul is made by Techtrin.
The Exatris will launch in January.
The Cornick is either the rocket that will launch in April or the rocket developed by Rubicorp.

Entities:
rockets: Beritron, Cornick, Exatris, Worul
months: January, February, March, April
companies: Rubicorp, SpaceZen, Techtrin, Vexatech
VAR (71-78): Exatris
VAR (105-113): SpaceZen
VAR (145-153): Beritron
VAR (192-199): Exatris
VAR (229-236): Cornick
VAR (343-351): Beritron
VAR (364-371): Exatris
VAR (447-455): SpaceZen
VAR (469-477): Vexatech

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Beritron == 1, and January == 1, and Rubicorp == 1, then Beritron is the rocket that will launch in January and is developed by Rubicorp.

### Decision variables:
-   Names of the rockets: Beritron, Cornick, Exatris, Worul (all different, 1 to 4)
-   Months of launch: January, February, March, April (all different, 1 to 4)
-   Companies that made the rockets: Rubicorp, SpaceZen, Techtrin, Vexatech (all different, 1 to 4)

### Constraints:
-   The rocket developed by Vexatech will launch 1 month after the Exatris:
    For this, we will need to add a constraint for each possible assignment of the months of launch for Vexatech's rocket and the Exatris, such that Vexatech's rocket's month of launch is 1 more than the Exatris's month of launch. So, the constraints will be of the form:
    m1 == Vexatech and m2 == Exatris => m1_to_int == m2_to_int + 1, for all m1, m2 in months of launch.

-   The rocket developed by SpaceZen will launch sometime after the Beritron:
    For this, we will need to add a constraint for each possible assignment of the months of launch for SpaceZen's rocket and the Beritron, such that SpaceZen's rocket's month of launch is greater than the Beritron's month of launch. So, the constraints will be of the form:
    m1 == SpaceZen and m2 == Beritron => m1_to_int > m2_to_int, for all m1, m2 in months of launch.

-   The Worul is made by Techtrin:
    This is a direct assignment constraint:
    Worul == Techtrin.

-   The Exatris will launch in January:
    This is a direct assignment constraint:
    Exatris == January.

-   The Cornick is either the rocket that will launch in April or the rocket developed by Rubicorp:
    This is a constraint that states that Cornick's month of launch is either April or the month of launch of the rocket developed by Rubicorp, but not both. So:
    Xor([Cornick == April, Cornick == Rubicorp]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Beritron == 1, and January == 1, and Rubicorp == 1, then Beritron is the rocket that will launch in January and is developed by Rubicorp.

### Decision variables:
-   Names of the rockets: Beritron, Cornick, Exatris, Worul (all different, 1 to 4)
-   Months of launch: January, February, March, April (all different, 1 to 4)
-   Companies that made the rockets: Rubicorp, SpaceZen, Techtrin, Vexatech (all different, 1 to 4)

### Constraints:
-   The rocket developed by Vexatech will launch 1 month after the Exatris:
    For this, we will need to add a constraint for each possible assignment of the months of launch for Vexatech's rocket and the Exatris, such that Vexatech's rocket's month of launch is 1 more than the Exatris's month of launch. So, the constraints will be of the form:
    m1 == Vexatech and m2 == Exatris => m1_to_int == m2_to_int + 1, for all m1, m2 in months of launch.

-   The rocket developed by SpaceZen will launch sometime after the Beritron:
    For this, we will need to add a constraint for each possible assignment of the months of launch for SpaceZen's rocket and the Beritron, such that SpaceZen's rocket's month of launch is greater than the Beritron's month of launch. So, the constraints will be of the form:
    m1 == SpaceZen and m2 == Beritron => m1_to_int > m2_to_int, for all m1, m2 in months of launch.

-   The Worul is made by Techtrin:
    This is a direct assignment constraint:
    Worul == Techtrin.

-   The Exatris will launch in January:
    This is a direct assignment constraint:
    Exatris == January.

-   The Cornick is either the rocket that will launch in April or the rocket developed by Rubicorp:
    This is a constraint that states that Cornick's month of launch is either April or the month of launch of the rocket developed by Rubicorp, but not both. So:
    Xor([Cornick == April, Cornick == Rubicorp]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of rocket, month, and company)
# e.g. if beritron == 1 and january == 1 and rubicorp == 1, then Beritron will launch in January and developed by Rubicorp
beritron, cornick, exatris, worul = rockets = intvar(1, 4, shape=4)
january, february, march, april = months = intvar(1, 4, shape=4)
rubicorp, spacezen, techtrin, vexatech = companies = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
rocket_to_int = None  # N/A
month_to_int = {january: 1, february: 2, march: 3, april: 4}  # in months
company_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def launched_after_than(var1, var2):
    """
    Formulate the constraint that var1 launched after var2.
    """
    return [((r1 == var1) & (r2 == var2)).implies(month_to_int[r1] > month_to_int[r2])
            for r1 in months for r2 in months]


def launched_exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 launched exactly diff months after var2.
    """
    return [((r1 == var1) & (r2 == var2)).implies(month_to_int[r1] == month_to_int[r2] + diff)
            for r1 in months for r2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(rockets)
m += AllDifferent(months)
m += AllDifferent(companies)

# Clue 1: The rocket developed by Vexatech will launch 1 month after the Exatris:
m += launched_exactly_after_than(vexatech, exatris, 1)

# Clue 2: The rocket developed by SpaceZen will launch sometime after the Beritron:
m += launched_after_than(spacezen, beritron)

# Clue 3: The Worul is made by Techtrin:
m += worul == techtrin

# Clue 4: The Exatris will launch in January:
m += exatris == january

# Clue 5: The Cornick is either the rocket that will launch in April or the rocket developed by Rubicorp:
m += Xor([cornick == april, cornick == rubicorp])

```
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The student who will major in Physics was awarded $5000 less than the student who will major in Biology.
Wilma will major in Mathematics.
Delores was awarded $5000 more than Anna.
Anna was awarded some amount less than the person who will major in Mathematics.
Wilma is either the person who received the 35000 dollars scholarship or the person who received the 25000 dollars scholarship.

Entities:
names: Anna, Delores, Wilma, Yvonne
scholarships: $25000, $30000, $35000, $40000
majors: Biology, Mathematics, Physics, Theology
VAR (38-45): Physics
PARAM (60-64): 5000
CONST_DIR (65-69): less
VAR (105-112): Biology
VAR (135-146): Mathematics
VAR (149-156): Delores
PARAM (171-175): 5000
CONST_DIR (176-180): more
VAR (261-272): Mathematics
PARAM (319-324): 35000
PARAM (376-381): 25000
VAR (430-437): Delores
PARAM (472-477): 25000
PARAM (482-487): 30000
PARAM (492-497): 35000
PARAM (502-507): 40000
VAR (517-524): Biology
VAR (527-538): Mathematics
VAR (541-548): Physics

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Anna == 1, and $25000 == 1, and Biology == 1, then Anna was awarded $25000 for majoring in Biology.

### Decision variables:
-   Names of the students: Anna, Delores, Wilma, Yvonne (all different, 1 to 4)
-   Amounts of scholarships: $25000, $30000, $35000, $40000 (all different, 1 to 4)
-   Majors: Biology, Mathematics, Physics, Theology (all different, 1 to 4)

### Constraints:
-   The student who will major in Physics was awarded $5000 less than the student who will major in Biology:
    For this, we will need to add a constraint for each possible assignment of majors for Physics and Biology, such that the scholarship amount for Physics is $5000 less than the scholarship amount for Biology. So, the constraints will be of the form:
    m1 == Physics and m2 == Biology => m1_to_int == m2_to_int - 5000, for all m1, m2 in scholarships.

-   Wilma will major in Mathematics:
    This is a direct assignment constraint:
    Wilma == Mathematics.

-   Delores was awarded $5000 more than Anna:
    For this, we will need to add a constraint for each possible assignment of scholarships for Delores and Anna, such that Delores's scholarship amount is $5000 more than Anna's scholarship amount. So, the constraints will be of the form:
    s1 == Delores and s2 == Anna => s1_to_int == s2_to_int + 5000, for all s1, s2 in scholarships.

-   Anna was awarded some amount less than the person who will major in Mathematics:
    For this, we will need to add a constraint for each possible assignment of scholarships for Anna and the person majoring in Mathematics, such that Anna's scholarship amount is less than the scholarship amount of the person majoring in Mathematics. So, the constraints will be of the form:
    s1 == Anna and s2 == Mathematics => s1_to_int < s2_to_int, for all s1, s2 in scholarships.

-   Wilma is either the person who received the $35000 scholarship or the person who received the $25000 scholarship:
    This is a constraint that states that Wilma's scholarship amount is either $35000 or $25000, but not both. So:
    Xor([Wilma == $35000, Wilma == $25000]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Anna == 1, and $25000 == 1, and Biology == 1, then Anna was awarded $25000 for majoring in Biology.

### Decision variables:
-   Names of the students: Anna, Delores, Wilma, Yvonne (all different, 1 to 4)
-   Amounts of scholarships: $25000, $30000, $35000, $40000 (all different, 1 to 4)
-   Majors: Biology, Mathematics, Physics, Theology (all different, 1 to 4)

### Constraints:
-   The student who will major in Physics was awarded $5000 less than the student who will major in Biology:
    For this, we will need to add a constraint for each possible assignment of majors for Physics and Biology, such that the scholarship amount for Physics is $5000 less than the scholarship amount for Biology. So, the constraints will be of the form:
    m1 == Physics and m2 == Biology => m1_to_int == m2_to_int - 5000, for all m1, m2 in scholarships.

-   Wilma will major in Mathematics:
    This is a direct assignment constraint:
    Wilma == Mathematics.

-   Delores was awarded $5000 more than Anna:
    For this, we will need to add a constraint for each possible assignment of scholarships for Delores and Anna, such that Delores's scholarship amount is $5000 more than Anna's scholarship amount. So, the constraints will be of the form:
    s1 == Delores and s2 == Anna => s1_to_int == s2_to_int + 5000, for all s1, s2 in scholarships.

-   Anna was awarded some amount less than the person who will major in Mathematics:
    For this, we will need to add a constraint for each possible assignment of scholarships for Anna and the person majoring in Mathematics, such that Anna's scholarship amount is less than the scholarship amount of the person majoring in Mathematics. So, the constraints will be of the form:
    s1 == Anna and s2 == Mathematics => s1_to_int < s2_to_int, for all s1, s2 in scholarships.

-   Wilma is either the person who received the $35000 scholarship or the person who received the $25000 scholarship:
    This is a constraint that states that Wilma's scholarship amount is either $35000 or $25000, but not both. So:
    Xor([Wilma == $35000, Wilma == $25000]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of student, scholarship, and major)
# e.g. if anna == 1 and $25000 == 1 and biology == 1, then Anna was awarded $25000 for majoring in Biology
anna, delores, wilma, yvonne = students = intvar(1, 4, shape=4)
$25000, $30000, $35000, $40000 = scholarships = intvar(1, 4, shape=4)
biology, mathematics, physics, theology = majors = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
student_to_int = None  # N/A
scholarship_to_int = {25000: 1, 30000: 2, 35000: 3, 40000: 4}  # in dollars
major_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def awarded_less_than(var1, var2, diff):
    """
    Formulate the constraint that var1 was awarded diff dollars less than var2.
    """
    return [((s1 == var1) & (s2 == var2)).implies(scholarship_to_int[s1] == scholarship_to_int[s2] - diff)
            for s1 in scholarships for s2 in scholarships]


def awarded_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 was awarded diff dollars more than var2.
    """
    return [((s1 == var1) & (s2 == var2)).implies(scholarship_to_int[s1] == scholarship_to_int[s2] + diff)
            for s1 in scholarships for s2 in scholarships]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(students)
m += AllDifferent(scholarships)
m += AllDifferent(majors)

# Clue 1: The student who will major in Physics was awarded $5000 less than the student who will major in Biology:
m += awarded_less_than(physics, biology, 5000)

# Clue 2: Wilma will major in Mathematics:
m += wilma == mathematics

# Clue 3: Delores was awarded $5000 more than Anna:
m += awarded_more_than(delores, anna, 5000)

# Clue 4: Anna was awarded some amount less than the person who will major in Mathematics:
m += awarded_less_than(anna, mathematics, 0)

# Clue 5: Wilma is either the person who received the $35000 scholarship or the person who received the $25000 scholarship:
m += Xor([wilma == $35000, wilma == $25000])

```
Error: invalid syntax (<string>, line 1)
False
False
Error: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
The four butterflies were the swallowtail butterfly, Rena's purchase, the insect that sold for $90, and Phillip's purchase.
Otis's purchase was either the peacock butterfly or the swallowtail butterfly.
Brandon's purchase cost 30 dollars less than Otis's purchase.
Rena's purchase cost 15 dollars less than the swallowtail butterfly.
The insect that sold for $75 was the torturix butterfly.

Entities:
winners: Brandon, Otis, Phillip, Rena
prices: $45, $60, $75, $90
butterflies: peacock, peppered, swallowtail, torturix
VAR (38-59): swallowtail butterfly
VAR (62-78): Rena 's purchase
PARAM (108-110): 90
VAR (117-136): Phillip 's purchase
VAR (171-188): peacock butterfly
VAR (196-217): swallowtail butterfly
VAR (220-239): Brandon 's purchase
PARAM (245-247): 30
VAR (266-273): Otis 's
VAR (285-301): Rena 's purchase
PARAM (307-309): 15
VAR (332-353): swallowtail butterfly
PARAM (383-385): 75
VAR (394-412): torturix butterfly
VAR (453-460): Phillip
VAR (463-467): Rena
PARAM (479-481): 45
PARAM (486-488): 60
PARAM (493-495): 75
PARAM (500-502): 90

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Brandon == 1, and $45 == 1, and peacock == 1, then Brandon's purchase was the peacock butterfly that cost $45.

### Decision variables:
-   Names of the winners: Brandon, Otis, Phillip, Rena (all different, 1 to 4)
-   Prices of the purchases: $45, $60, $75, $90 (all different, 1 to 4)
-   Types of butterflies: peacock, peppered, swallowtail, torturix (all different, 1 to 4)

### Constraints:
-   The four butterflies were the swallowtail butterfly, Rena's purchase, the insect that sold for $90, and Phillip's purchase:
    This is a constraint that states that each of these entities corresponds to a different butterfly, thus:
    AllDifferent([swallowtail, Rena, $90, Phillip]).

-   Otis's purchase was either the peacock butterfly or the swallowtail butterfly:
    This is a constraint that states that Otis's purchase is either the peacock butterfly or the swallowtail butterfly, but not both. So:
    Xor([Otis == peacock, Otis == swallowtail]).

-   Brandon's purchase cost 30 dollars less than Otis's purchase:
    For this, we will need to add a constraint for each possible assignment of prices for Brandon and Otis's purchase, such that Brandon's purchase price is 30 less than Otis's purchase price. So, the constraints will be of the form:
    p1 == Brandon and p2 == Otis => p1_to_int == p2_to_int - 30, for all p1, p2 in prices.

-   Rena's purchase cost 15 dollars less than the swallowtail butterfly:
    For this, we will need to add a constraint for each possible assignment of prices for Rena's purchase and the swallowtail butterfly, such that Rena's purchase price is 15 less than the swallowtail butterfly's price. So, the constraints will be of the form:
    p1 == Rena and p2 == swallowtail => p1_to_int == p2_to_int - 15, for all p1, p2 in prices.

-   The insect that sold for $75 was the torturix butterfly:
    This is a direct assignment constraint:
    torturix == $75.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Brandon == 1, and $45 == 1, and peacock == 1, then Brandon's purchase was the peacock butterfly that cost $45.

### Decision variables:
-   Names of the winners: Brandon, Otis, Phillip, Rena (all different, 1 to 4)
-   Prices of the purchases: $45, $60, $75, $90 (all different, 1 to 4)
-   Types of butterflies: peacock, peppered, swallowtail, torturix (all different, 1 to 4)

### Constraints:
-   The four butterflies were the swallowtail butterfly, Rena's purchase, the insect that sold for $90, and Phillip's purchase:
    This is a constraint that states that each of these entities corresponds to a different butterfly, thus:
    AllDifferent([swallowtail, Rena, $90, Phillip]).

-   Otis's purchase was either the peacock butterfly or the swallowtail butterfly:
    This is a constraint that states that Otis's purchase is either the peacock butterfly or the swallowtail butterfly, but not both. So:
    Xor([Otis == peacock, Otis == swallowtail]).

-   Brandon's purchase cost 30 dollars less than Otis's purchase:
    For this, we will need to add a constraint for each possible assignment of prices for Brandon and Otis's purchase, such that Brandon's purchase price is 30 less than Otis's purchase price. So, the constraints will be of the form:
    p1 == Brandon and p2 == Otis => p1_to_int == p2_to_int - 30, for all p1, p2 in prices.

-   Rena's purchase cost 15 dollars less than the swallowtail butterfly:
    For this, we will need to add a constraint for each possible assignment of prices for Rena's purchase and the swallowtail butterfly, such that Rena's purchase price is 15 less than the swallowtail butterfly's price. So, the constraints will be of the form:
    p1 == Rena and p2 == swallowtail => p1_to_int == p2_to_int - 15, for all p1, p2 in prices.

-   The insect that sold for $75 was the torturix butterfly:
    This is a direct assignment constraint:
    torturix == $75.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of winner, price, and butterfly)
# e.g. if brandon == 1 and price45 == 1 and peacock == 1, then Brandon's purchase was the peacock butterfly that cost $45
brandon, otis, phillip, rena = winners = intvar(1, 4, shape=4)
price45, price60, price75, price90 = prices = intvar(1, 4, shape=4)
peacock, peppered, swallowtail, torturix = butterflies = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
winner_to_int = None  # N/A
price_to_int = {price45: 45, price60: 60, price75: 75, price90: 90}  # in dollars
butterfly_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def cost_less_than(var1, var2, diff):
    """
    Formulate the constraint that var1 cost less than var2 by diff dollars.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] - diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(winners)
m += AllDifferent(prices)
m += AllDifferent(butterflies)

# Clue 1: The four butterflies were the swallowtail butterfly, Rena's purchase, the insect that sold for $90, and Phillip's purchase:
m += AllDifferent([swallowtail, rena, price90, phillip])

# Clue 2: Otis's purchase was either the peacock butterfly or the swallowtail butterfly:
m += Xor([otis == peacock, otis == swallowtail])

# Clue 3: Brandon's purchase cost 30 dollars less than Otis's purchase:
m += cost_less_than(brandon, otis, 30)

# Clue 4: Rena's purchase cost 15 dollars less than the swallowtail butterfly:
m += cost_less_than(rena, swallowtail, 15)

# Clue 5: The insect that sold for $75 was the torturix butterfly:
m += torturix == price75

```
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The ambassador with the 9 day visit will leave sometime after Fitzgerald.
Quinn will leave 2 months after Bender.
The person leaving in January is either the ambassador with the 3 day visit or Fitzgerald.
Quinn will leave 1 month before the ambassador with the 7 day visit.

Entities:
diplomats: Bender, Fitzgerald, Owens, Quinn
months: January, February, March, April
durations: 2 day, 3 day, 7 day, 9 day
PARAM (32-33): 9
VAR (70-80): Fitzgerald
VAR (83-88): Quinn
PARAM (100-101): 2
VAR (115-121): Bender
PARAM (188-189): 3
VAR (203-213): Fitzgerald
VAR (216-221): Quinn
PARAM (233-234): 1
PARAM (272-273): 7
VAR (309-315): Bender
VAR (318-328): Fitzgerald
VAR (339-344): Quinn
PARAM (401-402): 2
PARAM (409-410): 3
PARAM (417-418): 7
PARAM (425-426): 9

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Bender == 1, and January == 1, and Day2 == 1, then Bender is the diplomat leaving in January with a 2-day visit.

### Decision variables:
-   Names of the diplomats: Bender, Fitzgerald, Owens, Quinn (all different, 1 to 4)
-   Months of departure: January, February, March, April (all different, 1 to 4)
-   Visit durations: Day2, Day3, Day7, Day9 (all different, 1 to 4)

### Constraints:
-   The ambassador with the 9-day visit will leave sometime after Fitzgerald:
    For this, we will need to add a constraint for each possible assignment of the months of departure for the ambassador with the 9-day visit and Fitzgerald, such that the ambassador with the 9-day visit's month of departure is greater than Fitzgerald's month of departure. So, the constraints will be of the form:
    m1 == Day9 and m2 == Fitzgerald => m1_to_int > m2_to_int, for all m1, m2 in months of departure.

-   Quinn will leave 2 months after Bender:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Quinn and Bender, such that Quinn's month of departure is 2 more than Bender's month of departure. So, the constraints will be of the form:
    m1 == Quinn and m2 == Bender => m1_to_int == m2_to_int + 2, for all m1, m2 in months of departure.

-   The person leaving in January is either the ambassador with the 3-day visit or Fitzgerald:
    This is a constraint that states that the person leaving in January is either the ambassador with the 3-day visit or Fitzgerald, but not both. So:
    Xor([January == Day3, January == Fitzgerald]).

-   Quinn will leave 1 month before the ambassador with the 7-day visit:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Quinn and the ambassador with the 7-day visit, such that Quinn's month of departure is 1 less than the 7-day ambassador's month of departure. So, the constraints will be of the form:
    m1 == Quinn and m2 == Day7 => m1_to_int == m2_to_int - 1, for all m1, m2 in months of departure.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Bender == 1, and January == 1, and Day2 == 1, then Bender is the diplomat leaving in January with a 2-day visit.

### Decision variables:
-   Names of the diplomats: Bender, Fitzgerald, Owens, Quinn (all different, 1 to 4)
-   Months of departure: January, February, March, April (all different, 1 to 4)
-   Visit durations: Day2, Day3, Day7, Day9 (all different, 1 to 4)

### Constraints:
-   The ambassador with the 9-day visit will leave sometime after Fitzgerald:
    For this, we will need to add a constraint for each possible assignment of the months of departure for the ambassador with the 9-day visit and Fitzgerald, such that the ambassador with the 9-day visit's month of departure is greater than Fitzgerald's month of departure. So, the constraints will be of the form:
    m1 == Day9 and m2 == Fitzgerald => m1_to_int > m2_to_int, for all m1, m2 in months of departure.

-   Quinn will leave 2 months after Bender:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Quinn and Bender, such that Quinn's month of departure is 2 more than Bender's month of departure. So, the constraints will be of the form:
    m1 == Quinn and m2 == Bender => m1_to_int == m2_to_int + 2, for all m1, m2 in months of departure.

-   The person leaving in January is either the ambassador with the 3-day visit or Fitzgerald:
    This is a constraint that states that the person leaving in January is either the ambassador with the 3-day visit or Fitzgerald, but not both. So:
    Xor([January == Day3, January == Fitzgerald]).

-   Quinn will leave 1 month before the ambassador with the 7-day visit:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Quinn and the ambassador with the 7-day visit, such that Quinn's month of departure is 1 less than the 7-day ambassador's month of departure. So, the constraints will be of the form:
    m1 == Quinn and m2 == Day7 => m1_to_int == m2_to_int - 1, for all m1, m2 in months of departure.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of diplomat, month, and duration)
# e.g. if bender == 1 and january == 1 and day2 == 1, then Bender will leave in January with a 2-day visit
bender, fitzgerald, owens, quinn = diplomats = intvar(1, 4, shape=4)
january, february, march, april = months = intvar(1, 4, shape=4)
day2, day3, day7, day9 = durations = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
diplomat_to_int = None  # N/A
month_to_int = {january: 1, february: 2, march: 3, april: 4}  # in months
duration_to_int = {day2: 2, day3: 3, day7: 7, day9: 9}  # in days


# Helper functions (for formulating comparison constraints)
def leave_after_than(var1, var2):
    """
    Formulate the constraint that var1 leaves after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] > month_to_int[m2])
            for m1 in months for m2 in months]


def leave_exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 leaves exactly diff months after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] == month_to_int[m2] + diff)
            for m1 in months for m2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(diplomats)
m += AllDifferent(months)
m += AllDifferent(durations)

# Clue 1: The ambassador with the 9-day visit will leave sometime after Fitzgerald:
m += leave_after_than(day9, fitzgerald)

# Clue 2: Quinn will leave 2 months after Bender:
m += leave_exactly_after_than(quinn, bender, 2)

# Clue 3: The person leaving in January is either the ambassador with the 3-day visit or Fitzgerald:
m += Xor([january == day3, january == fitzgerald])

# Clue 4: Quinn will leave 1 month before the ambassador with the 7-day visit:
m += leave_exactly_after_than(quinn, day7, -1)

```
True
True
True
Wrong: 0, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The person who came in at 8:00am asked for wheat bread.
Tricia came in a half-hour after Ora.
Of Felicia and the customer who ordered flatbread, one came in at 7:30am and the other came in at 7:00am.
Of the customer who ordered wheat bread; and the person who ordered pumpernickel, one came in at 8:30am and the other was Tricia.

Entities:
breads: flatbread, pumpernickel, rye bread, wheat bread
times: 7:00am, 7:30am, 8:00am, 8:30am
customers: Felicia, Isabel, Ora, Tricia
PARAM (34-40): 8:00am
VAR (51-62): wheat bread
PARAM (82-86): half
VAR (146-155): flatbread
PARAM (173-179): 7:30am
PARAM (205-211): 7:00am
VAR (242-253): wheat bread
VAR (283-295): pumpernickel
PARAM (313-319): 8:30am
VAR (406-417): wheat bread
PARAM (426-432): 7:00am
PARAM (435-441): 7:30am
PARAM (444-450): 8:00am
PARAM (453-459): 8:30am

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Felicia == 1, and WheatBread == 1, and Time800 == 1, then Felicia came in at 8:00 am and ordered wheat bread.

### Decision variables:
-   Names of the customers: Felicia, Isabel, Ora, Tricia (all different, 1 to 4)
-   Types of bread ordered: Flatbread, Pumpernickel, RyeBread, WheatBread (all different, 1 to 4)
-   Times of arrival: 7:00am, 7:30am, 8:00am, 8:30am (all different, 1 to 4)

### Constraints:
-   The person who came in at 8:00am asked for wheat bread:
    This is a direct assignment constraint:
    Time800 == WheatBread.

-   Tricia came in a half-hour after Ora:
    For this, we will need to add a constraint for each possible assignment of the times of arrival for Tricia and Ora, such that Tricia's arrival time is half an hour after Ora's arrival time. So, the constraints will be of the form:
    t1 == Tricia and t2 == Ora => t1_to_int == t2_to_int + 1, for all t1, t2 in times of arrival.

-   Of Felicia and the customer who ordered flatbread, one came in at 7:30am and the other came in at 7:00am:
    This is a constraint that states that Felicia and the customer who ordered flatbread have different arrival times, one at 7:30am and the other at 7:00am. So:
    Xor([Felicia == Time730, Felicia == Time700]).

-   Of the customer who ordered wheat bread and the person who ordered pumpernickel, one came in at 8:30am and the other was Tricia:
    This is a constraint that states that the customer who ordered wheat bread and the person who ordered pumpernickel have different arrival times, one at 8:30am and the other being Tricia. So:
    Xor([WheatBread == Time830, WheatBread == Tricia]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Felicia == 1, and WheatBread == 1, and Time800 == 1, then Felicia came in at 8:00 am and ordered wheat bread.

### Decision variables:
-   Names of the customers: Felicia, Isabel, Ora, Tricia (all different, 1 to 4)
-   Types of bread ordered: Flatbread, Pumpernickel, RyeBread, WheatBread (all different, 1 to 4)
-   Times of arrival: 7:00am, 7:30am, 8:00am, 8:30am (all different, 1 to 4)

### Constraints:
-   The person who came in at 8:00am asked for wheat bread:
    This is a direct assignment constraint:
    Time800 == WheatBread.

-   Tricia came in a half-hour after Ora:
    For this, we will need to add a constraint for each possible assignment of the times of arrival for Tricia and Ora, such that Tricia's arrival time is half an hour after Ora's arrival time. So, the constraints will be of the form:
    t1 == Tricia and t2 == Ora => t1_to_int == t2_to_int + 1, for all t1, t2 in times of arrival.

-   Of Felicia and the customer who ordered flatbread, one came in at 7:30am and the other came in at 7:00am:
    This is a constraint that states that Felicia and the customer who ordered flatbread have different arrival times, one at 7:30am and the other at 7:00am. So:
    Xor([Felicia == Time730, Felicia == Time700]).

-   Of the customer who ordered wheat bread and the person who ordered pumpernickel, one came in at 8:30am and the other was Tricia:
    This is a constraint that states that the customer who ordered wheat bread and the person who ordered pumpernickel have different arrival times, one at 8:30am and the other being Tricia. So:
    Xor([WheatBread == Time830, WheatBread == Tricia]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of customer, bread, and time)
# e.g. if felicia == 1 and wheat_bread == 1 and time800 == 1, then Felicia came in at 8:00 am and ordered wheat bread
felicia, isabel, ora, tricia = customers = intvar(1, 4, shape=4)
flatbread, pumpernickel, rye_bread, wheat_bread = breads = intvar(1, 4, shape=4)
time700, time730, time800, time830 = times = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
customer_to_int = None  # N/A
bread_to_int = None  # N/A
time_to_int = {time700: 1, time730: 2, time800: 3, time830: 4}  # in hours


# Helper functions (for formulating comparison constraints)
def half_hour_after(var1, var2):
    """
    Formulate the constraint that var1 is half an hour after var2.
    """
    return [((t1 == var1) & (t2 == var2)).implies(time_to_int[t1] == time_to_int[t2] + 1)
            for t1 in times for t2 in times]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(customers)
m += AllDifferent(breads)
m += AllDifferent(times)

# Clue 1: The person who came in at 8:00am asked for wheat bread:
m += time800 == wheat_bread

# Clue 2: Tricia came in a half-hour after Ora:
m += half_hour_after(tricia, ora)

# Clue 3: Of Felicia and the customer who ordered flatbread, one came in at 7:30am and the other came in at 7:00am:
m += Xor([felicia == time730, felicia == time700])

# Clue 4: Of the customer who ordered wheat bread and the person who ordered pumpernickel, one came in at 8:30am and the other was Tricia:
m += Xor([wheat_bread == time830, wheat_bread == tricia])

```
False
False
Error: list.remove(x): x not in list
Wrong: 3, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The 75 million year old fossil costs 500 dollars less than the pilodontus.
The senosaurus is 85 million years old.
The 75 million year old fossil costs 500 dollars less than the 78 million year old fossil.
The 75 million year old fossil costs less than the archadon.
The 69 million year old fossil costs 250 dollars more than the 78 million year old fossil.

Entities:
dinosaurs: archadon, mirasaurus, pilodontus, senosaurus
price: $500, $750, $1000, $1250
ages: 69 million, 75 million, 78 million, 85 million
VAR (12-38): 75 million year old fossil
PARAM (45-48): 500
VAR (88-98): senosaurus
PARAM (102-104): 85
VAR (129-155): 75 million year old fossil
PARAM (162-165): 500
CONST_DIR (174-178): less
VAR (188-214): 78 million year old fossil
VAR (221-247): 75 million year old fossil
VAR (283-309): 69 million year old fossil
PARAM (316-319): 250
CONST_DIR (328-332): more
VAR (342-368): 78 million year old fossil
OBJ_NAME (442-447): price
PARAM (452-455): 500
PARAM (460-463): 750
PARAM (468-472): 1000
PARAM (477-481): 1250
OBJ_NAME (482-486): ages
PARAM (489-491): 69
PARAM (502-504): 75
PARAM (515-517): 78
PARAM (528-530): 85

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Archadon == 1, and Price500 == 1, and Age69 == 1, then Archadon is the dinosaur with a price of $500 and an age of 69 million years.

### Decision variables:
-   Names of the dinosaurs: Archadon, Mirasaurus, Pilodontus, Senosaurus (all different, 1 to 4)
-   Prices of the fossils: Price500, Price750, Price1000, Price1250 (all different, 1 to 4)
-   Ages of the fossils: Age69, Age75, Age78, Age85 (all different, 1 to 4)

### Constraints:
-   The 75 million year old fossil costs $500 less than the Pilodontus:
    For this, we will need to add a constraint for each possible assignment of the prices for the 75 million year old fossil and the Pilodontus, such that the price of the 75 million year old fossil is $500 less than the Pilodontus. So, the constraints will be of the form:
    p1 == 75MillionYearOldFossil and p2 == Pilodontus => p1_to_int == p2_to_int - 500, for all p1, p2 in prices.

-   The Senosaurus is 85 million years old:
    This is a direct assignment constraint:
    Senosaurus == Age85.

-   The 75 million year old fossil costs $500 less than the 78 million year old fossil:
    For this, we will need to add a constraint for each possible assignment of the prices for the 75 million year old fossil and the 78 million year old fossil, such that the price of the 75 million year old fossil is $500 less than the 78 million year old fossil. So, the constraints will be of the form:
    p1 == 75MillionYearOldFossil and p2 == 78MillionYearOldFossil => p1_to_int == p2_to_int - 500, for all p1, p2 in prices.

-   The 75 million year old fossil costs less than the Archadon:
    For this, we will need to add a constraint for each possible assignment of the prices for the 75 million year old fossil and the Archadon, such that the price of the 75 million year old fossil is less than the Archadon. So, the constraints will be of the form:
    p1 == 75MillionYearOldFossil and p2 == Archadon => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   The 69 million year old fossil costs $250 more than the 78 million year old fossil:
    For this, we will need to add a constraint for each possible assignment of the prices for the 69 million year old fossil and the 78 million year old fossil, such that the price of the 69 million year old fossil is $250 more than the 78 million year old fossil. So, the constraints will be of the form:
    p1 == 69MillionYearOldFossil and p2 == 78MillionYearOldFossil => p1_to_int == p2_to_int + 250, for all p1, p2 in prices.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Archadon == 1, and Price500 == 1, and Age69 == 1, then Archadon is the dinosaur with a price of $500 and an age of 69 million years.

### Decision variables:
-   Names of the dinosaurs: Archadon, Mirasaurus, Pilodontus, Senosaurus (all different, 1 to 4)
-   Prices of the fossils: Price500, Price750, Price1000, Price1250 (all different, 1 to 4)
-   Ages of the fossils: Age69, Age75, Age78, Age85 (all different, 1 to 4)

### Constraints:
-   The 75 million year old fossil costs $500 less than the Pilodontus:
    For this, we will need to add a constraint for each possible assignment of the prices for the 75 million year old fossil and the Pilodontus, such that the price of the 75 million year old fossil is $500 less than the Pilodontus. So, the constraints will be of the form:
    p1 == 75MillionYearOldFossil and p2 == Pilodontus => p1_to_int == p2_to_int - 500, for all p1, p2 in prices.

-   The Senosaurus is 85 million years old:
    This is a direct assignment constraint:
    Senosaurus == Age85.

-   The 75 million year old fossil costs $500 less than the 78 million year old fossil:
    For this, we will need to add a constraint for each possible assignment of the prices for the 75 million year old fossil and the 78 million year old fossil, such that the price of the 75 million year old fossil is $500 less than the 78 million year old fossil. So, the constraints will be of the form:
    p1 == 75MillionYearOldFossil and p2 == 78MillionYearOldFossil => p1_to_int == p2_to_int - 500, for all p1, p2 in prices.

-   The 75 million year old fossil costs less than the Archadon:
    For this, we will need to add a constraint for each possible assignment of the prices for the 75 million year old fossil and the Archadon, such that the price of the 75 million year old fossil is less than the Archadon. So, the constraints will be of the form:
    p1 == 75MillionYearOldFossil and p2 == Archadon => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   The 69 million year old fossil costs $250 more than the 78 million year old fossil:
    For this, we will need to add a constraint for each possible assignment of the prices for the 69 million year old fossil and the 78 million year old fossil, such that the price of the 69 million year old fossil is $250 more than the 78 million year old fossil. So, the constraints will be of the form:
    p1 == 69MillionYearOldFossil and p2 == 78MillionYearOldFossil => p1_to_int == p2_to_int + 250, for all p1, p2 in prices.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of dinosaur, price, and age)
# e.g. if archadon == 1 and price500 == 1 and age69 == 1, then Archadon has a price of $500 and an age of 69 million years
archadon, mirasaurus, pilodontus, senosaurus = dinosaurs = intvar(1, 4, shape=4)
price500, price750, price1000, price1250 = prices = intvar(1, 4, shape=4)
age69, age75, age78, age85 = ages = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
dinosaur_to_int = None  # N/A
price_to_int = {price500: 500, price750: 750, price1000: 1000, price1250: 1250}  # in dollars
age_to_int = {age69: 69, age75: 75, age78: 78, age85: 85}  # in million years


# Helper functions (for formulating comparison constraints)
def costs_less_than(var1, var2):
    """
    Formulate the constraint that var1 costs less than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] < price_to_int[p2])
            for p1 in prices for p2 in prices]


def costs_exactly_less_than(var1, var2, diff):
    """
    Formulate the constraint that var1 costs exactly diff dollars less than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] - diff)
            for p1 in prices for p2 in prices]


def costs_more_than(var1, var2):
    """
    Formulate the constraint that var1 costs more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] > price_to_int[p2])
            for p1 in prices for p2 in prices]


def costs_exactly_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 costs exactly diff dollars more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] + diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(dinosaurs)
m += AllDifferent(prices)
m += AllDifferent(ages)

# Clue 1: The 75 million year old fossil costs $500 less than the Pilodontus:
m += costs_exactly_less_than(age75, pilodontus, 500)

# Clue 2: The Senosaurus is 85 million years old:
m += senosaurus == age85

# Clue 3: The 75 million year old fossil costs $500 less than the 78 million year old fossil:
m += costs_exactly_less_than(age75, age78, 500)

# Clue 4: The 75 million year old fossil costs less than the Archadon:
m += costs_less_than(age75, archadon)

# Clue 5: The 69 million year old fossil costs $250 more than the 78 million year old fossil:
m += costs_exactly_more_than(age69, age78, 250)

```
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Henrietta's task starts 2 hours after Glenn's job.
Glenn's task is the dining room.
Glenn's chore starts 1 hour after the mud room assignment.
Henrietta's task is the living room.
The mud room assignment starts sometime before Willie's assignment.

Entities:
children: Glenn, Henrietta, Olivia, Willie
times: 8:00am, 9:00am, 10:00am, 11:00am
rooms: dining room, laundry room, living room, mud room
VAR (8-17): Henrietta
PARAM (33-34): 2
VAR (83-94): dining room
PARAM (119-120): 1
VAR (136-144): mud room
VAR (158-167): Henrietta
VAR (183-194): living room
VAR (201-209): mud room
PARAM (333-339): 8:00am
PARAM (342-348): 9:00am
PARAM (351-358): 10:00am
PARAM (361-368): 11:00am
VAR (377-388): dining room
VAR (406-417): living room
VAR (420-428): mud room

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Glenn == 1, and DiningRoom == 1, and Time8am == 1, then Glenn's task is in the dining room and starts at 8:00 am.

### Decision variables:
-   Names of the children: Glenn, Henrietta, Olivia, Willie (all different, 1 to 4)
-   Tasks: DiningRoom, LaundryRoom, LivingRoom, MudRoom (all different, 1 to 4)
-   Times: 8:00am, 9:00am, 10:00am, 11:00am (all different, 1 to 4)

### Constraints:
-   Henrietta's task starts 2 hours after Glenn's task:
    For this, we will need to add a constraint for each possible assignment of the times for Henrietta and Glenn, such that Henrietta's time is 2 hours after Glenn's time. So, the constraints will be of the form:
    t1 == Henrietta and t2 == Glenn => t1_to_int == t2_to_int + 2, for all t1, t2 in times.

-   Glenn's task is the dining room:
    This is a direct assignment constraint:
    Glenn == DiningRoom.

-   Glenn's task starts 1 hour after the mud room assignment:
    For this, we will need to add a constraint for each possible assignment of the times for Glenn and the mud room assignment, such that Glenn's time is 1 hour after the mud room assignment's time. So, the constraints will be of the form:
    t1 == Glenn and t2 == MudRoom => t1_to_int == t2_to_int + 1, for all t1, t2 in times.

-   Henrietta's task is the living room:
    This is a direct assignment constraint:
    Henrietta == LivingRoom.

-   The mud room assignment starts sometime before Willie's assignment:
    For this, we will need to add a constraint for each possible assignment of the rooms for the mud room assignment and Willie's assignment, such that the mud room assignment's room is before Willie's assignment's room. So, the constraints will be of the form:
    r1 == MudRoom and r2 == Willie => r1_to_int < r2_to_int, for all r1, r2 in rooms.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Glenn == 1, and DiningRoom == 1, and Time8am == 1, then Glenn's task is in the dining room and starts at 8:00 am.

### Decision variables:
-   Names of the children: Glenn, Henrietta, Olivia, Willie (all different, 1 to 4)
-   Tasks: DiningRoom, LaundryRoom, LivingRoom, MudRoom (all different, 1 to 4)
-   Times: 8:00am, 9:00am, 10:00am, 11:00am (all different, 1 to 4)

### Constraints:
-   Henrietta's task starts 2 hours after Glenn's task:
    For this, we will need to add a constraint for each possible assignment of the times for Henrietta and Glenn, such that Henrietta's time is 2 hours after Glenn's time. So, the constraints will be of the form:
    t1 == Henrietta and t2 == Glenn => t1_to_int == t2_to_int + 2, for all t1, t2 in times.

-   Glenn's task is the dining room:
    This is a direct assignment constraint:
    Glenn == DiningRoom.

-   Glenn's task starts 1 hour after the mud room assignment:
    For this, we will need to add a constraint for each possible assignment of the times for Glenn and the mud room assignment, such that Glenn's time is 1 hour after the mud room assignment's time. So, the constraints will be of the form:
    t1 == Glenn and t2 == MudRoom => t1_to_int == t2_to_int + 1, for all t1, t2 in times.

-   Henrietta's task is the living room:
    This is a direct assignment constraint:
    Henrietta == LivingRoom.

-   The mud room assignment starts sometime before Willie's assignment:
    For this, we will need to add a constraint for each possible assignment of the rooms for the mud room assignment and Willie's assignment, such that the mud room assignment's room is before Willie's assignment's room. So, the constraints will be of the form:
    r1 == MudRoom and r2 == Willie => r1_to_int < r2_to_int, for all r1, r2 in rooms.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of child, task, and time)
# e.g. if glenn == 1 and dining_room == 1 and time8am == 1, then Glenn's task is in the dining room and starts at 8:00 am
glenn, henrietta, olivia, willie = children = intvar(1, 4, shape=4)
dining_room, laundry_room, living_room, mud_room = tasks = intvar(1, 4, shape=4)
time8am, time9am, time10am, time11am = times = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
child_to_int = None  # N/A
task_to_int = None  # N/A
time_to_int = {time8am: 1, time9am: 2, time10am: 3, time11am: 4}  # in hours


# Helper functions (for formulating comparison constraints)
def starts_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 starts diff hours after var2.
    """
    return [((t1 == var1) & (t2 == var2)).implies(time_to_int[t1] == time_to_int[t2] + diff)
            for t1 in times for t2 in times]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(children)
m += AllDifferent(tasks)
m += AllDifferent(times)

# Clue 1: Henrietta's task starts 2 hours after Glenn's task:
m += starts_after_than(henrietta, glenn, 2)

# Clue 2: Glenn's task is the dining room:
m += glenn == dining_room

# Clue 3: Glenn's task starts 1 hour after the mud room assignment:
m += starts_after_than(glenn, mud_room, 1)

# Clue 4: Henrietta's task is the living room:
m += henrietta == living_room

# Clue 5: The mud room assignment starts sometime before Willie's assignment:
m += mud_room < willie

```
True
True
False
Wrong: 1, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Mr. Ayers will dive on July 14.
Mr. Drake will dive 1 day after the diver going out with Hilda.
The customer going out on July 14 will go out with Hilda.
The customer going out with Vicki is either Mr. Gallegos or the customer going out on July 14.
The customer going out with Nadine will dive 1 day before Mr. Ayers.

Entities:
customers: Mr. Ayers, Mr. Drake, Mr. Erickson, Mr. Gallegos
dates: July 13, July 14, July 15, July 16
guides: Hilda, Jorge, Nadine, Vicki
PARAM (36-38): 14
PARAM (61-62): 1
VAR (98-103): Hilda
VAR (132-136): July
PARAM (137-139): 14
VAR (157-162): Hilda
VAR (193-198): Vicki
PARAM (256-258): 14
VAR (289-295): Nadine
PARAM (306-307): 1
PARAM (419-421): 13
PARAM (429-431): 14
PARAM (439-441): 15
PARAM (449-451): 16
VAR (461-466): Hilda
VAR (477-483): Nadine
VAR (486-491): Vicki

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if MrAyers == 1, and July14 == 1, and Hilda == 1, then Mr. Ayers will dive on July 14 with Hilda.

### Decision variables:
-   Names of the customers: MrAyers, MrDrake, MrErickson, MrGallegos (all different, 1 to 4)
-   Dates of the dives: July13, July14, July15, July16 (all different, 1 to 4)
-   Names of the guides: Hilda, Jorge, Nadine, Vicki (all different, 1 to 4)

### Constraints:
-   Mr. Ayers will dive on July 14:
    This is a direct assignment constraint:
    MrAyers == July14.

-   Mr. Drake will dive 1 day after the diver going out with Hilda:
    For this, we will need to add a constraint for each possible assignment of the dates for Mr. Drake and the diver going out with Hilda, such that Mr. Drake's dive date is 1 more than Hilda's dive date. So, the constraints will be of the form:
    d1 == MrDrake and d2 == Hilda => d1_to_int == d2_to_int + 1, for all d1, d2 in dates.

-   The customer going out on July 14 will go out with Hilda:
    This is a direct assignment constraint:
    July14 == Hilda.

-   The customer going out with Vicki is either Mr. Gallegos or the customer going out on July 14:
    This is a constraint that states that the customer going out with Vicki is either Mr. Gallegos or the customer going out on July 14, but not both. So:
    Xor([Vicki == MrGallegos, Vicki == July14]).

-   The customer going out with Nadine will dive 1 day before Mr. Ayers:
    For this, we will need to add a constraint for each possible assignment of the dates for the customer going out with Nadine and Mr. Ayers, such that the customer going out with Nadine's dive date is 1 less than Mr. Ayers's dive date. So, the constraints will be of the form:
    d1 == Nadine and d2 == MrAyers => d1_to_int == d2_to_int - 1, for all d1, d2 in dates.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if MrAyers == 1, and July14 == 1, and Hilda == 1, then Mr. Ayers will dive on July 14 with Hilda.

### Decision variables:
-   Names of the customers: MrAyers, MrDrake, MrErickson, MrGallegos (all different, 1 to 4)
-   Dates of the dives: July13, July14, July15, July16 (all different, 1 to 4)
-   Names of the guides: Hilda, Jorge, Nadine, Vicki (all different, 1 to 4)

### Constraints:
-   Mr. Ayers will dive on July 14:
    This is a direct assignment constraint:
    MrAyers == July14.

-   Mr. Drake will dive 1 day after the diver going out with Hilda:
    For this, we will need to add a constraint for each possible assignment of the dates for Mr. Drake and the diver going out with Hilda, such that Mr. Drake's dive date is 1 more than Hilda's dive date. So, the constraints will be of the form:
    d1 == MrDrake and d2 == Hilda => d1_to_int == d2_to_int + 1, for all d1, d2 in dates.

-   The customer going out on July 14 will go out with Hilda:
    This is a direct assignment constraint:
    July14 == Hilda.

-   The customer going out with Vicki is either Mr. Gallegos or the customer going out on July 14:
    This is a constraint that states that the customer going out with Vicki is either Mr. Gallegos or the customer going out on July 14, but not both. So:
    Xor([Vicki == MrGallegos, Vicki == July14]).

-   The customer going out with Nadine will dive 1 day before Mr. Ayers:
    For this, we will need to add a constraint for each possible assignment of the dates for the customer going out with Nadine and Mr. Ayers, such that the customer going out with Nadine's dive date is 1 less than Mr. Ayers's dive date. So, the constraints will be of the form:
    d1 == Nadine and d2 == MrAyers => d1_to_int == d2_to_int - 1, for all d1, d2 in dates.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of customer, date, and guide)
# e.g. if ayers == 1 and july14 == 1 and hilda == 1, then Mr. Ayers will dive on July 14 with Hilda
ayers, drake, erickson, gallegos = customers = intvar(1, 4, shape=4)
july13, july14, july15, july16 = dates = intvar(1, 4, shape=4)
hilda, jorge, nadine, vicki = guides = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
customer_to_int = None  # N/A
date_to_int = {july13: 13, july14: 14, july15: 15, july16: 16}  # in days
guide_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def dive_after_than(var1, var2):
    """
    Formulate the constraint that var1 dives after var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(date_to_int[d1] > date_to_int[d2])
            for d1 in dates for d2 in dates]


def dive_exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 dives exactly diff days after var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(date_to_int[d1] == date_to_int[d2] + diff)
            for d1 in dates for d2 in dates]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(customers)
m += AllDifferent(dates)
m += AllDifferent(guides)

# Clue 1: Mr. Ayers will dive on July 14:
m += ayers == july14

# Clue 2: Mr. Drake will dive 1 day after the diver going out with Hilda:
m += dive_exactly_after_than(drake, hilda, 1)

# Clue 3: The customer going out on July 14 will go out with Hilda:
m += july14 == hilda

# Clue 4: The customer going out with Vicki is either Mr. Gallegos or the customer going out on July 14:
m += Xor([vicki == gallegos, vicki == july14])

# Clue 5: The customer going out with Nadine will dive 1 day before Mr. Ayers:
m += dive_exactly_after_than(nadine, ayers, -1)

```
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The Ethel Street project begins 1 month after Cal Craft's project.
The job starting in May will be headed by Ed Erickson.
The Juniper Lane project starts in April.
Al Anderson's project begins 2 months before the Fred Lane project.

Entities:
Streets: Ethel Street, Fred Lane, Juniper Lane, Quince Street
managers: Al Anderson, Cal Craft, Ed Erickson, Hal Hamilton
months: April, May, June, July
VAR (12-24): Ethel Street
PARAM (40-41): 1
VAR (137-149): Juniper Lane
PARAM (206-207): 2
VAR (226-235): Fred Lane
VAR (267-272): Ethel
VAR (287-291): Lane
VAR (294-306): Juniper Lane

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if EthelStreet == 1, and CalCraft == 1, and April == 1, then the Ethel Street project starts in April and is managed by Cal Craft.

### Decision variables:
-   Names of the streets: EthelStreet, FredLane, JuniperLane, QuinceStreet (all different, 1 to 4)
-   Managers of the projects: AlAnderson, CalCraft, EdErickson, HalHamilton (all different, 1 to 4)
-   Months of project start: April, May, June, July (all different, 1 to 4)

### Constraints:
-   The Ethel Street project begins 1 month after Cal Craft's project:
    For this, we will need to add a constraint for each possible assignment of the months for Ethel Street and Cal Craft's project, such that Ethel Street's project start month is 1 more than Cal Craft's project start month. So, the constraints will be of the form:
    m1 == EthelStreet and m2 == CalCraft => m1_to_int == m2_to_int + 1, for all m1, m2 in months.

-   The job starting in May will be headed by Ed Erickson:
    This is a direct assignment constraint:
    May == EdErickson.

-   The Juniper Lane project starts in April:
    This is a direct assignment constraint:
    JuniperLane == April.

-   Al Anderson's project begins 2 months before the Fred Lane project:
    For this, we will need to add a constraint for each possible assignment of the months for Al Anderson and Fred Lane's project, such that Al Anderson's project start month is 2 less than Fred Lane's project start month. So, the constraints will be of the form:
    m1 == AlAnderson and m2 == FredLane => m1_to_int == m2_to_int - 2, for all m1, m2 in months.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if EthelStreet == 1, and CalCraft == 1, and April == 1, then the Ethel Street project starts in April and is managed by Cal Craft.

### Decision variables:
-   Names of the streets: EthelStreet, FredLane, JuniperLane, QuinceStreet (all different, 1 to 4)
-   Managers of the projects: AlAnderson, CalCraft, EdErickson, HalHamilton (all different, 1 to 4)
-   Months of project start: April, May, June, July (all different, 1 to 4)

### Constraints:
-   The Ethel Street project begins 1 month after Cal Craft's project:
    For this, we will need to add a constraint for each possible assignment of the months for Ethel Street and Cal Craft's project, such that Ethel Street's project start month is 1 more than Cal Craft's project start month. So, the constraints will be of the form:
    m1 == EthelStreet and m2 == CalCraft => m1_to_int == m2_to_int + 1, for all m1, m2 in months.

-   The job starting in May will be headed by Ed Erickson:
    This is a direct assignment constraint:
    May == EdErickson.

-   The Juniper Lane project starts in April:
    This is a direct assignment constraint:
    JuniperLane == April.

-   Al Anderson's project begins 2 months before the Fred Lane project:
    For this, we will need to add a constraint for each possible assignment of the months for Al Anderson and Fred Lane's project, such that Al Anderson's project start month is 2 less than Fred Lane's project start month. So, the constraints will be of the form:
    m1 == AlAnderson and m2 == FredLane => m1_to_int == m2_to_int - 2, for all m1, m2 in months.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of street, manager, and month)
# e.g. if ethel == 1 and cal == 1 and april == 1, then the Ethel Street project starts in April and is managed by Cal Craft
ethel, fred, juniper, quince = streets = intvar(1, 4, shape=4)
al, cal, ed, hal = managers = intvar(1, 4, shape=4)
april, may, june, july = months = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
street_to_int = None  # N/A
manager_to_int = None  # N/A
month_to_int = {april: 4, may: 5, june: 6, july: 7}  # in months


# Helper functions (for formulating comparison constraints)
def starts_after_than(var1, var2):
    """
    Formulate the constraint that var1 starts after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] > month_to_int[m2])
            for m1 in months for m2 in months]


def starts_exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 starts exactly diff months after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] == month_to_int[m2] + diff)
            for m1 in months for m2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(streets)
m += AllDifferent(managers)
m += AllDifferent(months)

# Clue 1: The Ethel Street project begins 1 month after Cal Craft's project:
m += starts_exactly_after_than(ethel, cal, 1)

# Clue 2: The job starting in May will be headed by Ed Erickson:
m += may == ed

# Clue 3: The Juniper Lane project starts in April:
m += juniper == april

# Clue 4: Al Anderson's project begins 2 months before the Fred Lane project:
m += starts_exactly_after_than(al, fred, -2)

```
True
True
True
Wrong: 0, Total: 7
---------------------------------------------------------------------------------------------

Clues:
Ingram had 7 goals this season.
The four players are Underwood, the player from the Ice Hogs, the player from the Monsters and the player from the Checkers.
Parrish scored 1 goal more than Quinn.
The player with 9 goals is from the Ice Hogs.
Ingram is either the player from the Checkers or the player with 6 goals.

Entities:
players: Ingram, Parrish, Quinn, Underwood
goals: 6, 7, 8, 9
teams: Checkers, Comets, Ice Hogs, Monsters
LIMIT (19-20): 7
VAR (94-102): Ice Hogs
VAR (125-133): Monsters
VAR (158-166): Checkers
VAR (169-176): Parrish
PARAM (184-185): 1
PARAM (225-226): 9
VAR (245-253): Ice Hogs
VAR (293-301): Checkers
PARAM (321-322): 6
VAR (361-368): Parrish
PARAM (397-398): 6
PARAM (401-402): 7
PARAM (405-406): 8
PARAM (409-410): 9
VAR (419-427): Checkers
VAR (430-436): Comets
VAR (439-447): Ice Hogs
VAR (450-458): Monsters

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ingram == 1, and Checkers == 1, and Goals6 == 1, then Ingram is the player from the Checkers with 6 goals.

### Decision variables:
-   Names of the players: Ingram, Parrish, Quinn, Underwood (all different, 1 to 4)
-   Number of goals: 6, 7, 8, 9 (all different, 1 to 4)
-   Teams: Checkers, Comets, Ice Hogs, Monsters (all different, 1 to 4)

### Constraints:
-   Ingram had 7 goals this season:
    This is a direct assignment constraint:
    Ingram == Goals7.

-   The four players are Underwood, the player from the Ice Hogs, the player from the Monsters, and the player from the Checkers:
    This is a constraint that states that all these entities are different, thus:
    AllDifferent([Underwood, IceHogs, Monsters, Checkers]).

-   Parrish scored 1 goal more than Quinn:
    For this, we will need to add a constraint for each possible assignment of goals for Parrish and Quinn, such that Parrish's goals are 1 more than Quinn's goals. So, the constraints will be of the form:
    g1 == Parrish and g2 == Quinn => g1_to_int == g2_to_int + 1, for all g1, g2 in goals.

-   The player with 9 goals is from the Ice Hogs:
    This is a direct assignment constraint:
    IceHogs == Goals9.

-   Ingram is either the player from the Checkers or the player with 6 goals:
    This is a constraint that states that Ingram is either the player from the Checkers or the player with 6 goals, but not both. So:
    Xor([Ingram == Checkers, Ingram == Goals6]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ingram == 1, and Checkers == 1, and Goals6 == 1, then Ingram is the player from the Checkers with 6 goals.

### Decision variables:
-   Names of the players: Ingram, Parrish, Quinn, Underwood (all different, 1 to 4)
-   Number of goals: 6, 7, 8, 9 (all different, 1 to 4)
-   Teams: Checkers, Comets, Ice Hogs, Monsters (all different, 1 to 4)

### Constraints:
-   Ingram had 7 goals this season:
    This is a direct assignment constraint:
    Ingram == Goals7.

-   The four players are Underwood, the player from the Ice Hogs, the player from the Monsters, and the player from the Checkers:
    This is a constraint that states that all these entities are different, thus:
    AllDifferent([Underwood, IceHogs, Monsters, Checkers]).

-   Parrish scored 1 goal more than Quinn:
    For this, we will need to add a constraint for each possible assignment of goals for Parrish and Quinn, such that Parrish's goals are 1 more than Quinn's goals. So, the constraints will be of the form:
    g1 == Parrish and g2 == Quinn => g1_to_int == g2_to_int + 1, for all g1, g2 in goals.

-   The player with 9 goals is from the Ice Hogs:
    This is a direct assignment constraint:
    IceHogs == Goals9.

-   Ingram is either the player from the Checkers or the player with 6 goals:
    This is a constraint that states that Ingram is either the player from the Checkers or the player with 6 goals, but not both. So:
    Xor([Ingram == Checkers, Ingram == Goals6]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of player, goals, and team)
# e.g. if ingram == 1 and checkers == 1 and goals7 == 1, then Ingram is the player from the Checkers with 7 goals
ingram, parrish, quinn, underwood = players = intvar(1, 4, shape=4)
goals6, goals7, goals8, goals9 = goals = intvar(1, 4, shape=4)
checkers, comets, ice_hogs, monsters = teams = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
player_to_int = None  # N/A
goals_to_int = {goals6: 6, goals7: 7, goals8: 8, goals9: 9}  # in number of goals
team_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def scored_more_than(var1, var2):
    """
    Formulate the constraint that var1 scored more goals than var2.
    """
    return [((g1 == var1) & (g2 == var2)).implies(goals_to_int[g1] > goals_to_int[g2])
            for g1 in goals for g2 in goals]


def scored_exactly_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 scored exactly diff more goals than var2.
    """
    return [((g1 == var1) & (g2 == var2)).implies(goals_to_int[g1] == goals_to_int[g2] + diff)
            for g1 in goals for g2 in goals]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(players)
m += AllDifferent(goals)
m += AllDifferent(teams)

# Clue 1: Ingram had 7 goals this season:
m += ingram == goals7

# Clue 2: The four players are Underwood, the player from the Ice Hogs, the player from the Monsters, and the player from the Checkers:
m += AllDifferent([underwood, ice_hogs, monsters, checkers])

# Clue 3: Parrish scored 1 goal more than Quinn:
m += scored_exactly_more_than(parrish, quinn, 1)

# Clue 4: The player with 9 goals is from the Ice Hogs:
m += ice_hogs == goals9

# Clue 5: Ingram is either the player from the Checkers or the player with 6 goals:
m += Xor([ingram == checkers, ingram == goals6])

```
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Natasha's study starts 2 months after the project on the Odyssey.
Of the assignment on the Liberty and the assignment on the Escape, one is Felix's assignment and the other starts in March.
The study on the Liberty starts 2 months after Eunice's project.

Entities:
students: Eunice, Felix, Natasha, Stacy
months: March, April, May, June
ships: Escape, Liberty, Odyssey, Osprey
PARAM (32-33): 2
VAR (101-108): Liberty
VAR (135-141): Escape
VAR (220-227): Liberty
PARAM (235-236): 2
VAR (369-375): Escape
VAR (378-385): Liberty

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Eunice == 1, and March == 1, and Liberty == 1, then Eunice's project on the Liberty starts in March.

### Decision variables:
-   Names of the students: Eunice, Felix, Natasha, Stacy (all different, 1 to 4)
-   Months of the projects: March, April, May, June (all different, 1 to 4)
-   Names of the ships: Escape, Liberty, Odyssey, Osprey (all different, 1 to 4)

### Constraints:
-   Natasha's study starts 2 months after the project on the Odyssey:
    For this, we will need to add a constraint for each possible assignment of the months for Natasha's study and the project on the Odyssey, such that Natasha's study starts 2 months after the Odyssey project. So, the constraints will be of the form:
    m1 == Natasha and m2 == Odyssey => m1_to_int == m2_to_int + 2, for all m1, m2 in months.

-   Of the assignment on the Liberty and the assignment on the Escape, one is Felix's assignment and the other starts in March:
    This is a constraint that states that one of the assignments is Felix's and the other starts in March. So, we can represent this as:
    (Liberty == Felix and Escape == March) or (Escape == Felix and Liberty == March).

-   The study on the Liberty starts 2 months after Eunice's project:
    For this, we will need to add a constraint for each possible assignment of the months for the study on the Liberty and Eunice's project, such that the Liberty study starts 2 months after Eunice's project. So, the constraints will be of the form:
    m1 == Liberty and m2 == Eunice => m1_to_int == m2_to_int + 2, for all m1, m2 in months.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Eunice == 1, and March == 1, and Liberty == 1, then Eunice's project on the Liberty starts in March.

### Decision variables:
-   Names of the students: Eunice, Felix, Natasha, Stacy (all different, 1 to 4)
-   Months of the projects: March, April, May, June (all different, 1 to 4)
-   Names of the ships: Escape, Liberty, Odyssey, Osprey (all different, 1 to 4)

### Constraints:
-   Natasha's study starts 2 months after the project on the Odyssey:
    For this, we will need to add a constraint for each possible assignment of the months for Natasha's study and the project on the Odyssey, such that Natasha's study starts 2 months after the Odyssey project. So, the constraints will be of the form:
    m1 == Natasha and m2 == Odyssey => m1_to_int == m2_to_int + 2, for all m1, m2 in months.

-   Of the assignment on the Liberty and the assignment on the Escape, one is Felix's assignment and the other starts in March:
    This is a constraint that states that one of the assignments is Felix's and the other starts in March. So, we can represent this as:
    (Liberty == Felix and Escape == March) or (Escape == Felix and Liberty == March).

-   The study on the Liberty starts 2 months after Eunice's project:
    For this, we will need to add a constraint for each possible assignment of the months for the study on the Liberty and Eunice's project, such that the Liberty study starts 2 months after Eunice's project. So, the constraints will be of the form:
    m1 == Liberty and m2 == Eunice => m1_to_int == m2_to_int + 2, for all m1, m2 in months.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of student, month, and ship)
# e.g. if eunice == 1 and march == 1 and liberty == 1, then Eunice's project on the Liberty starts in March
eunice, felix, natasha, stacy = students = intvar(1, 4, shape=4)
march, april, may, june = months = intvar(1, 4, shape=4)
escape, liberty, odyssey, osprey = ships = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
student_to_int = None  # N/A
month_to_int = {march: 1, april: 2, may: 3, june: 4}  # in months
ship_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def starts_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 starts diff months after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] == month_to_int[m2] + diff)
            for m1 in months for m2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(students)
m += AllDifferent(months)
m += AllDifferent(ships)

# Clue 1: Natasha's study starts 2 months after the project on the Odyssey:
m += starts_after_than(natasha, odyssey, 2)

# Clue 2: Of the assignment on the Liberty and the assignment on the Escape, one is Felix's assignment and the other starts in March:
m += ((liberty == felix) & (escape == march)) | ((escape == felix) & (liberty == march))

# Clue 3: The study on the Liberty starts 2 months after Eunice's project:
m += starts_after_than(liberty, eunice, 2)

```
True
True
True
Wrong: 1, Total: 6
---------------------------------------------------------------------------------------------

Clues:
The project headed by Dr. Golden will go online sometime before the Zynga Complex.
The project headed by Dr. Weber will go online 1 year before the Bale-Hahn SSC.
The Egert Facility will go online 1 year after the ISON-X42.
The project headed by Dr. Owens will go online 1 year after the ISON-X42.

Entities:
years: 2016, 2017, 2018, 2019
names: Bale-Hahn SSC, Egert Facility, ISON-X42, Zynga Complex
scientists: Dr. Farley, Dr. Golden, Dr. Owens, Dr. Weber
PARAM (139-140): 1
VAR (157-172): Bale - Hahn SSC
VAR (179-193): Egert Facility
PARAM (209-210): 1
PARAM (286-287): 1
VAR (369-384): Bale - Hahn SSC
VAR (387-401): Egert Facility

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if DrFarley == 1, and 2016 == 1, and BaleHahnSSC == 1, then Dr. Farley's project will go online in 2016 and is the Bale-Hahn SSC.

### Decision variables:
-   Years: 2016, 2017, 2018, 2019 (all different, 1 to 4)
-   Names of the projects: Bale-Hahn SSC, Egert Facility, ISON-X42, Zynga Complex (all different, 1 to 4)
-   Scientists: Dr. Farley, Dr. Golden, Dr. Owens, Dr. Weber (all different, 1 to 4)

### Constraints:
-   The project headed by Dr. Golden will go online sometime before the Zynga Complex:
    For this, we will need to add a constraint for each possible assignment of the years for Dr. Golden's project and the Zynga Complex, such that Dr. Golden's project's year is less than the Zynga Complex's year. So, the constraints will be of the form:
    y1 == DrGolden and y2 == ZyngaComplex => y1_to_int < y2_to_int, for all y1, y2 in years.

-   The project headed by Dr. Weber will go online 1 year before the Bale-Hahn SSC:
    For this, we will need to add a constraint for each possible assignment of the years for Dr. Weber's project and the Bale-Hahn SSC, such that Dr. Weber's project's year is 1 less than the Bale-Hahn SSC's year. So, the constraints will be of the form:
    y1 == DrWeber and y2 == BaleHahnSSC => y1_to_int == y2_to_int - 1, for all y1, y2 in years.

-   The Egert Facility will go online 1 year after the ISON-X42:
    For this, we will need to add a constraint for each possible assignment of the years for the Egert Facility and the ISON-X42, such that the Egert Facility's year is 1 more than the ISON-X42's year. So, the constraints will be of the form:
    y1 == EgertFacility and y2 == ISONX42 => y1_to_int == y2_to_int + 1, for all y1, y2 in years.

-   The project headed by Dr. Owens will go online 1 year after the ISON-X42:
    For this, we will need to add a constraint for each possible assignment of the years for Dr. Owens's project and the ISON-X42, such that Dr. Owens's project's year is 1 more than the ISON-X42's year. So, the constraints will be of the form:
    y1 == DrOwens and y2 == ISONX42 => y1_to_int == y2_to_int + 1, for all y1, y2 in years.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if DrFarley == 1, and 2016 == 1, and BaleHahnSSC == 1, then Dr. Farley's project will go online in 2016 and is the Bale-Hahn SSC.

### Decision variables:
-   Years: 2016, 2017, 2018, 2019 (all different, 1 to 4)
-   Names of the projects: Bale-Hahn SSC, Egert Facility, ISON-X42, Zynga Complex (all different, 1 to 4)
-   Scientists: Dr. Farley, Dr. Golden, Dr. Owens, Dr. Weber (all different, 1 to 4)

### Constraints:
-   The project headed by Dr. Golden will go online sometime before the Zynga Complex:
    For this, we will need to add a constraint for each possible assignment of the years for Dr. Golden's project and the Zynga Complex, such that Dr. Golden's project's year is less than the Zynga Complex's year. So, the constraints will be of the form:
    y1 == DrGolden and y2 == ZyngaComplex => y1_to_int < y2_to_int, for all y1, y2 in years.

-   The project headed by Dr. Weber will go online 1 year before the Bale-Hahn SSC:
    For this, we will need to add a constraint for each possible assignment of the years for Dr. Weber's project and the Bale-Hahn SSC, such that Dr. Weber's project's year is 1 less than the Bale-Hahn SSC's year. So, the constraints will be of the form:
    y1 == DrWeber and y2 == BaleHahnSSC => y1_to_int == y2_to_int - 1, for all y1, y2 in years.

-   The Egert Facility will go online 1 year after the ISON-X42:
    For this, we will need to add a constraint for each possible assignment of the years for the Egert Facility and the ISON-X42, such that the Egert Facility's year is 1 more than the ISON-X42's year. So, the constraints will be of the form:
    y1 == EgertFacility and y2 == ISONX42 => y1_to_int == y2_to_int + 1, for all y1, y2 in years.

-   The project headed by Dr. Owens will go online 1 year after the ISON-X42:
    For this, we will need to add a constraint for each possible assignment of the years for Dr. Owens's project and the ISON-X42, such that Dr. Owens's project's year is 1 more than the ISON-X42's year. So, the constraints will be of the form:
    y1 == DrOwens and y2 == ISONX42 => y1_to_int == y2_to_int + 1, for all y1, y2 in years.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of year, project, and scientist)
# e.g. if year2016 == 1 and bale_hahn == 1 and dr_farley == 1, then the Bale-Hahn SSC will go online in 2016 and is headed by Dr. Farley
year2016, year2017, year2018, year2019 = years = intvar(1, 4, shape=4)
bale_hahn, egert, ison_x42, zynga = projects = intvar(1, 4, shape=4)
dr_farley, dr_golden, dr_owens, dr_weber = scientists = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
year_to_int = {year2016: 2016, year2017: 2017, year2018: 2018, year2019: 2019}  # in years
project_to_int = None  # N/A
scientist_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def online_before_than(var1, var2):
    """
    Formulate the constraint that var1 goes online before var2.
    """
    return [((y1 == var1) & (y2 == var2)).implies(year_to_int[y1] < year_to_int[y2])
            for y1 in years for y2 in years]


def online_exactly_before_than(var1, var2, diff):
    """
    Formulate the constraint that var1 goes online exactly diff years before var2.
    """
    return [((y1 == var1) & (y2 == var2)).implies(year_to_int[y1] == year_to_int[y2] - diff)
            for y1 in years for y2 in years]


def online_exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 goes online exactly diff years after var2.
    """
    return [((y1 == var1) & (y2 == var2)).implies(year_to_int[y1] == year_to_int[y2] + diff)
            for y1 in years for y2 in years]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(years)
m += AllDifferent(projects)
m += AllDifferent(scientists)

# Clue 1: The project headed by Dr. Golden will go online sometime before the Zynga Complex:
m += online_before_than(dr_golden, zynga)

# Clue 2: The project headed by Dr. Weber will go online 1 year before the Bale-Hahn SSC:
m += online_exactly_before_than(dr_weber, bale_hahn, 1)

# Clue 3: The Egert Facility will go online 1 year after the ISON-X42:
m += online_exactly_after_than(egert, ison_x42, 1)

# Clue 4: The project headed by Dr. Owens will go online 1 year after the ISON-X42:
m += online_exactly_after_than(dr_owens, ison_x42, 1)

```
True
True
True
Wrong: 0, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The model made by Torvia costs 25 dollars more than the model made by Honwa.
The camera made by Honwa is either the Zenix 2C or the MX-827.
Of the $600 model and the FC-520, one is made by Honwa and the other is made by Dayero.
The Zenix 2C costs less than the FC-520.

Entities:
companies: Banion, Dayero, Honwa, Torvia
prices: $550, $575, $600, $625
cameras: DM-5000, FC-520, MX-827, Zenix 2C
PARAM (39-41): 25
VAR (125-133): Zenix 2C
PARAM (159-162): 600
VAR (245-253): Zenix 2C
PARAM (260-264): less
OBJ_NAME (339-345): prices
PARAM (350-353): 550
PARAM (358-361): 575
PARAM (366-369): 600
PARAM (374-377): 625
VAR (416-424): Zenix 2C

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Banion == 1, and Price550 == 1, and DM5000 == 1, then Banion's camera DM-5000 costs $550.

### Decision variables:
-   Companies: Banion, Dayero, Honwa, Torvia (all different, 1 to 4)
-   Prices: $550, $575, $600, $625 (all different, 1 to 4)
-   Cameras: DM-5000, FC-520, MX-827, Zenix 2C (all different, 1 to 4)

### Constraints:
-   The model made by Torvia costs 25 dollars more than the model made by Honwa:
    For this, we will need to add a constraint for each possible assignment of prices for Torvia and Honwa's models, such that Torvia's price is $25 more than Honwa's price. So, the constraints will be of the form:
    p1 == Torvia and p2 == Honwa => p1_to_int == p2_to_int + 25, for all p1, p2 in prices.

-   The camera made by Honwa is either the Zenix 2C or the MX-827:
    This is a constraint that states that the camera made by Honwa is either the Zenix 2C or the MX-827, but not both. So:
    Xor([Honwa == Zenix2C, Honwa == MX827]).

-   Of the $600 model and the FC-520, one is made by Honwa and the other is made by Dayero:
    This is a constraint that states that one of the $600 model and the FC-520 is made by Honwa and the other is made by Dayero. So:
    Xor([Price600 == Honwa and FC520 == Dayero, Price600 == Dayero and FC520 == Honwa]).

-   The Zenix 2C costs less than the FC-520:
    This is a constraint that states that the Zenix 2C costs less than the FC-520, thus:
    Zenix2C_to_int < FC520_to_int.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Banion == 1, and Price550 == 1, and DM5000 == 1, then Banion's camera DM-5000 costs $550.

### Decision variables:
-   Companies: Banion, Dayero, Honwa, Torvia (all different, 1 to 4)
-   Prices: $550, $575, $600, $625 (all different, 1 to 4)
-   Cameras: DM-5000, FC-520, MX-827, Zenix 2C (all different, 1 to 4)

### Constraints:
-   The model made by Torvia costs 25 dollars more than the model made by Honwa:
    For this, we will need to add a constraint for each possible assignment of prices for Torvia and Honwa's models, such that Torvia's price is $25 more than Honwa's price. So, the constraints will be of the form:
    p1 == Torvia and p2 == Honwa => p1_to_int == p2_to_int + 25, for all p1, p2 in prices.

-   The camera made by Honwa is either the Zenix 2C or the MX-827:
    This is a constraint that states that the camera made by Honwa is either the Zenix 2C or the MX-827, but not both. So:
    Xor([Honwa == Zenix2C, Honwa == MX827]).

-   Of the $600 model and the FC-520, one is made by Honwa and the other is made by Dayero:
    This is a constraint that states that one of the $600 model and the FC-520 is made by Honwa and the other is made by Dayero. So:
    Xor([Price600 == Honwa and FC520 == Dayero, Price600 == Dayero and FC520 == Honwa]).

-   The Zenix 2C costs less than the FC-520:
    This is a constraint that states that the Zenix 2C costs less than the FC-520, thus:
    Zenix2C_to_int < FC520_to_int.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of company, price, and camera)
# e.g. if banion == 1 and price550 == 1 and dm5000 == 1, then Banion's camera DM-5000 costs $550
banion, dayero, honwa, torvia = companies = intvar(1, 4, shape=4)
price550, price575, price600, price625 = prices = intvar(1, 4, shape=4)
dm5000, fc520, mx827, zenix2c = cameras = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
company_to_int = None  # N/A
price_to_int = {price550: 550, price575: 575, price600: 600, price625: 625}  # in dollars
camera_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def costs_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 costs more than var2 by diff dollars.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] + diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(companies)
m += AllDifferent(prices)
m += AllDifferent(cameras)

# Clue 1: The model made by Torvia costs 25 dollars more than the model made by Honwa:
m += costs_more_than(torvia, honwa, 25)

# Clue 2: The camera made by Honwa is either the Zenix 2C or the MX-827:
m += Xor([honwa == zenix2c, honwa == mx827])

# Clue 3: Of the $600 model and the FC-520, one is made by Honwa and the other is made by Dayero:
m += Xor([price600 == honwa and fc520 == dayero, price600 == dayero and fc520 == honwa])

# Clue 4: The Zenix 2C costs less than the FC-520:
m += zenix2c < fc520

```
False
True
False
Wrong: 2, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The football facility holds more people than Underwood Arena.
The basketball facility holds 80 more people than Vazquez Arena.
Young Arena holds 230 people.
Underwood Arena holds 40 fewer people than Vazquez Arena.
The facility with seating for 190 people is either the lacrosse facility or Underwood Arena.

Entities:
arenas: Gentry, Underwood, Vazquez, Young
capacities: 110, 150, 190, 230
sports: basketball, football, lacrosse, soccer
VAR (12-29): football facility
VAR (53-68): Underwood Arena
VAR (75-94): basketball facility
PARAM (101-103): 80
VAR (121-134): Vazquez Arena
VAR (137-148): Young Arena
PARAM (155-158): 230
VAR (168-183): Underwood Arena
PARAM (190-192): 40
VAR (211-224): Vazquez Arena
LIMIT (257-260): 190
VAR (282-299): lacrosse facility
VAR (303-318): Underwood Arena
VAR (362-369): Vazquez
PARAM (391-394): 110
PARAM (397-400): 150
PARAM (403-406): 190
PARAM (409-412): 230
VAR (446-454): lacrosse

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Gentry == 1, and FootballFacility == 1, and Soccer == 1, then Gentry is the football facility for soccer matches.

### Decision variables:
-   Names of the arenas: Gentry, Underwood, Vazquez, Young (all different, 1 to 4)
-   Capacities of the facilities: 110, 150, 190, 230 (all different, 1 to 4)
-   Sports played: basketball, football, lacrosse, soccer (all different, 1 to 4)

### Constraints:
-   The football facility holds more people than Underwood Arena:
    For this, we will need to add a constraint for each possible assignment of capacities for the football facility and Underwood Arena, such that the football facility's capacity is greater than Underwood Arena's capacity. So, the constraints will be of the form:
    c1 == FootballFacility and c2 == Underwood => c1_to_int > c2_to_int, for all c1, c2 in capacities.

-   The basketball facility holds 80 more people than Vazquez Arena:
    For this, we will need to add a constraint for each possible assignment of capacities for the basketball facility and Vazquez Arena, such that the basketball facility's capacity is 80 more than Vazquez Arena's capacity. So, the constraints will be of the form:
    c1 == BasketballFacility and c2 == Vazquez => c1_to_int == c2_to_int + 80, for all c1, c2 in capacities.

-   Young Arena holds 230 people:
    This is a direct assignment constraint:
    Young == 230.

-   Underwood Arena holds 40 fewer people than Vazquez Arena:
    For this, we will need to add a constraint for each possible assignment of capacities for Underwood Arena and Vazquez Arena, such that Underwood Arena's capacity is 40 less than Vazquez Arena's capacity. So, the constraints will be of the form:
    c1 == Underwood and c2 == Vazquez => c1_to_int == c2_to_int - 40, for all c1, c2 in capacities.

-   The facility with seating for 190 people is either the lacrosse facility or Underwood Arena:
    This is a constraint that states that the facility with a capacity of 190 is either the lacrosse facility or Underwood Arena, but not both. So:
    Xor([LacrosseFacility == 190, Underwood == 190]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Gentry == 1, and FootballFacility == 1, and Soccer == 1, then Gentry is the football facility for soccer matches.

### Decision variables:
-   Names of the arenas: Gentry, Underwood, Vazquez, Young (all different, 1 to 4)
-   Capacities of the facilities: 110, 150, 190, 230 (all different, 1 to 4)
-   Sports played: basketball, football, lacrosse, soccer (all different, 1 to 4)

### Constraints:
-   The football facility holds more people than Underwood Arena:
    For this, we will need to add a constraint for each possible assignment of capacities for the football facility and Underwood Arena, such that the football facility's capacity is greater than Underwood Arena's capacity. So, the constraints will be of the form:
    c1 == FootballFacility and c2 == Underwood => c1_to_int > c2_to_int, for all c1, c2 in capacities.

-   The basketball facility holds 80 more people than Vazquez Arena:
    For this, we will need to add a constraint for each possible assignment of capacities for the basketball facility and Vazquez Arena, such that the basketball facility's capacity is 80 more than Vazquez Arena's capacity. So, the constraints will be of the form:
    c1 == BasketballFacility and c2 == Vazquez => c1_to_int == c2_to_int + 80, for all c1, c2 in capacities.

-   Young Arena holds 230 people:
    This is a direct assignment constraint:
    Young == 230.

-   Underwood Arena holds 40 fewer people than Vazquez Arena:
    For this, we will need to add a constraint for each possible assignment of capacities for Underwood Arena and Vazquez Arena, such that Underwood Arena's capacity is 40 less than Vazquez Arena's capacity. So, the constraints will be of the form:
    c1 == Underwood and c2 == Vazquez => c1_to_int == c2_to_int - 40, for all c1, c2 in capacities.

-   The facility with seating for 190 people is either the lacrosse facility or Underwood Arena:
    This is a constraint that states that the facility with a capacity of 190 is either the lacrosse facility or Underwood Arena, but not both. So:
    Xor([LacrosseFacility == 190, Underwood == 190]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of arena, capacity, and sport)
# e.g. if gentry == 1 and football == 1 and soccer == 1, then Gentry is the football facility for soccer matches
gentry, underwood, vazquez, young = arenas = intvar(1, 4, shape=4)
cap110, cap150, cap190, cap230 = capacities = intvar(1, 4, shape=4)
basketball, football, lacrosse, soccer = sports = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
arena_to_int = None  # N/A
capacity_to_int = {cap110: 110, cap150: 150, cap190: 190, cap230: 230}  # in people
sport_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def holds_more_than(var1, var2):
    """
    Formulate the constraint that var1 holds more people than var2.
    """
    return [((c1 == var1) & (c2 == var2)).implies(capacity_to_int[c1] > capacity_to_int[c2])
            for c1 in capacities for c2 in capacities]


def holds_exactly_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 holds exactly diff more people than var2.
    """
    return [((c1 == var1) & (c2 == var2)).implies(capacity_to_int[c1] == capacity_to_int[c2] + diff)
            for c1 in capacities for c2 in capacities]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(arenas)
m += AllDifferent(capacities)
m += AllDifferent(sports)

# Clue 1: The football facility holds more people than Underwood Arena:
m += holds_more_than(football, underwood)

# Clue 2: The basketball facility holds 80 more people than Vazquez Arena:
m += holds_exactly_more_than(basketball, vazquez, 80)

# Clue 3: Young Arena holds 230 people:
m += young == cap230

# Clue 4: Underwood Arena holds 40 fewer people than Vazquez Arena:
m += holds_exactly_more_than(underwood, vazquez, -40)

# Clue 5: The facility with seating for 190 people is either the lacrosse facility or Underwood Arena:
m += Xor([lacrosse == cap190, underwood == cap190])

```
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Hope paid less than Delia.
Patricia had the cappuccino.
The one who had the cafe americano paid 1 dollar more than Patricia.
Hope paid more than the one who had the cafe americano.
The one who had the chai tea paid 1 dollar more than the one who had the cafe americano.

Entities:
names: Delia, Hope, Patricia, Wayne
prices: $5, $6, $7, $8
drinks: cafe americano, cafe latte, cappuccino, chai tea
VAR (8-12): Hope
VAR (28-33): Delia
VAR (36-44): Patricia
VAR (86-100): cafe americano
PARAM (106-107): 1
VAR (125-133): Patricia
VAR (136-140): Hope
CONST_DIR (146-150): more
VAR (176-190): cafe americano
VAR (213-221): chai tea
PARAM (227-228): 1
OBJ_NAME (236-240): more
VAR (266-280): cafe americano
VAR (302-307): Delia
VAR (310-314): Hope
VAR (317-325): Patricia
PARAM (345-346): 5
PARAM (351-352): 6
PARAM (357-358): 7
PARAM (363-364): 8
VAR (374-388): cafe americano
VAR (417-425): chai tea

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Delia == 1, and Price5 == 1, and CafeAmericano == 1, then Delia paid $5 for a cafe americano.

### Decision variables:
-   Names of the customers: Delia, Hope, Patricia, Wayne (all different, 1 to 4)
-   Prices paid: $5, $6, $7, $8 (all different, 1 to 4)
-   Drinks ordered: CafeAmericano, CafeLatte, Cappuccino, ChaiTea (all different, 1 to 4)

### Constraints:
-   Hope paid less than Delia:
    For this, we will need to add a constraint for each possible assignment of prices to Hope and Delia, such that Hope's price is less than Delia's price. So, the constraints will be of the form:
    p1 == Hope and p2 == Delia => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   Patricia had the cappuccino:
    This is a direct assignment constraint:
    Patricia == Cappuccino.

-   The one who had the cafe americano paid 1 dollar more than Patricia:
    For this, we will need to add a constraint for each possible assignment of prices to the customer who had the cafe americano and Patricia, such that the cafe americano customer's price is 1 more than Patricia's price. So, the constraints will be of the form:
    p1 == CafeAmericano and p2 == Patricia => p1_to_int == p2_to_int + 1, for all p1, p2 in prices.

-   Hope paid more than the one who had the cafe americano:
    For this, we will need to add a constraint for each possible assignment of prices to Hope and the customer who had the cafe americano, such that Hope's price is more than the cafe americano customer's price. So, the constraints will be of the form:
    p1 == Hope and p2 == CafeAmericano => p1_to_int > p2_to_int, for all p1, p2 in prices.

-   The one who had the chai tea paid 1 dollar more than the one who had the cafe americano:
    For this, we will need to add a constraint for each possible assignment of prices to the customer who had the chai tea and the customer who had the cafe americano, such that the chai tea customer's price is 1 more than the cafe americano customer's price. So, the constraints will be of the form:
    p1 == ChaiTea and p2 == CafeAmericano => p1_to_int == p2_to_int + 1, for all p1, p2 in prices.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Delia == 1, and Price5 == 1, and CafeAmericano == 1, then Delia paid $5 for a cafe americano.

### Decision variables:
-   Names of the customers: Delia, Hope, Patricia, Wayne (all different, 1 to 4)
-   Prices paid: $5, $6, $7, $8 (all different, 1 to 4)
-   Drinks ordered: CafeAmericano, CafeLatte, Cappuccino, ChaiTea (all different, 1 to 4)

### Constraints:
-   Hope paid less than Delia:
    For this, we will need to add a constraint for each possible assignment of prices to Hope and Delia, such that Hope's price is less than Delia's price. So, the constraints will be of the form:
    p1 == Hope and p2 == Delia => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   Patricia had the cappuccino:
    This is a direct assignment constraint:
    Patricia == Cappuccino.

-   The one who had the cafe americano paid 1 dollar more than Patricia:
    For this, we will need to add a constraint for each possible assignment of prices to the customer who had the cafe americano and Patricia, such that the cafe americano customer's price is 1 more than Patricia's price. So, the constraints will be of the form:
    p1 == CafeAmericano and p2 == Patricia => p1_to_int == p2_to_int + 1, for all p1, p2 in prices.

-   Hope paid more than the one who had the cafe americano:
    For this, we will need to add a constraint for each possible assignment of prices to Hope and the customer who had the cafe americano, such that Hope's price is more than the cafe americano customer's price. So, the constraints will be of the form:
    p1 == Hope and p2 == CafeAmericano => p1_to_int > p2_to_int, for all p1, p2 in prices.

-   The one who had the chai tea paid 1 dollar more than the one who had the cafe americano:
    For this, we will need to add a constraint for each possible assignment of prices to the customer who had the chai tea and the customer who had the cafe americano, such that the chai tea customer's price is 1 more than the cafe americano customer's price. So, the constraints will be of the form:
    p1 == ChaiTea and p2 == CafeAmericano => p1_to_int == p2_to_int + 1, for all p1, p2 in prices.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of customer, price, and drink)
# e.g. if delia == 1 and price5 == 1 and cafe_americano == 1, then Delia paid $5 for a cafe americano
delia, hope, patricia, wayne = customers = intvar(1, 4, shape=4)
price5, price6, price7, price8 = prices = intvar(1, 4, shape=4)
cafe_americano, cafe_latte, cappuccino, chai_tea = drinks = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
customer_to_int = None  # N/A
price_to_int = {price5: 5, price6: 6, price7: 7, price8: 8}  # in dollars
drink_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def paid_less_than(var1, var2):
    """
    Formulate the constraint that var1 paid less than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] < price_to_int[p2])
            for p1 in prices for p2 in prices]


def paid_exactly_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 paid exactly diff dollars more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] + diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(customers)
m += AllDifferent(prices)
m += AllDifferent(drinks)

# Clue 1: Hope paid less than Delia:
m += paid_less_than(hope, delia)

# Clue 2: Patricia had the cappuccino:
m += patricia == cappuccino

# Clue 3: The one who had the cafe americano paid 1 dollar more than Patricia:
m += paid_exactly_more_than(cafe_americano, patricia, 1)

# Clue 4: Hope paid more than the one who had the cafe americano:
m += paid_less_than(cafe_americano, hope)

# Clue 5: The one who had the chai tea paid 1 dollar more than the one who had the cafe americano:
m += paid_exactly_more_than(chai_tea, cafe_americano, 1)

```
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The Leden drove 25 miles farther than the automobile with a high speed of 75 MPH.
The Poltris drove 25 miles farther than the automobile with a high speed of 69 MPH.
The Awick drove somewhat less than the automobile with a high speed of 81 MPH.
The car with a high speed of 69 MPH drove somewhat farther than the automobile with a high speed of 81 MPH.

Entities:
cars: Awick, Leden, Poltris, Versem
distances: 525 miles, 550 miles, 575 miles, 600 miles
speeds: 62 MPH, 69 MPH, 75 MPH, 81 MPH
VAR (12-17): Leden
PARAM (24-26): 25
PARAM (82-84): 75
VAR (95-102): Poltris
PARAM (109-111): 25
PARAM (167-169): 69
VAR (180-185): Awick
PARAM (247-249): 81
PARAM (285-287): 69
PARAM (356-358): 81
VAR (383-388): Awick
VAR (391-396): Leden
VAR (399-406): Poltris
OBJ_NAME (416-425): distances
LIMIT (428-431): 525
LIMIT (440-443): 550
LIMIT (452-455): 575
LIMIT (464-467): 600
PARAM (483-485): 62
PARAM (492-494): 69
PARAM (501-503): 75
PARAM (510-512): 81

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Awick == 1, and Leden == 1, and Versem == 1, then Awick drove 525 miles with a speed of 62 MPH.

### Decision variables:
-   Names of the cars: Awick, Leden, Poltris, Versem (all different, 1 to 4)
-   Distances driven: 525 miles, 550 miles, 575 miles, 600 miles (all different, 1 to 4)
-   Speeds of the cars: 62 MPH, 69 MPH, 75 MPH, 81 MPH (all different, 1 to 4)

### Constraints:
-   The Leden drove 25 miles farther than the automobile with a high speed of 75 MPH:
    For this, we will need to add a constraint for each possible assignment of distances for Leden and the car with a speed of 75 MPH, such that Leden's distance is 25 miles more than the 75 MPH car's distance. So, the constraints will be of the form:
    d1 == Leden and d2 == 75MPH_car => d1_to_int == d2_to_int + 25, for all d1, d2 in distances.

-   The Poltris drove 25 miles farther than the automobile with a high speed of 69 MPH:
    For this, we will need to add a constraint for each possible assignment of distances for Poltris and the car with a speed of 69 MPH, such that Poltris's distance is 25 miles more than the 69 MPH car's distance. So, the constraints will be of the form:
    d1 == Poltris and d2 == 69MPH_car => d1_to_int == d2_to_int + 25, for all d1, d2 in distances.

-   The Awick drove somewhat less than the automobile with a high speed of 81 MPH:
    For this, we will need to add a constraint for each possible assignment of distances for Awick and the car with a speed of 81 MPH, such that Awick's distance is less than the 81 MPH car's distance. So, the constraints will be of the form:
    d1 == Awick and d2 == 81MPH_car => d1_to_int < d2_to_int, for all d1, d2 in distances.

-   The car with a high speed of 69 MPH drove somewhat farther than the automobile with a high speed of 81 MPH:
    For this, we will need to add a constraint for each possible assignment of distances for the 69 MPH car and the 81 MPH car, such that the 69 MPH car's distance is greater than the 81 MPH car's distance. So, the constraints will be of the form:
    d1 == 69MPH_car and d2 == 81MPH_car => d1_to_int > d2_to_int, for all d1, d2 in distances.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Awick == 1, and Leden == 1, and Versem == 1, then Awick drove 525 miles with a speed of 62 MPH.

### Decision variables:
-   Names of the cars: Awick, Leden, Poltris, Versem (all different, 1 to 4)
-   Distances driven: 525 miles, 550 miles, 575 miles, 600 miles (all different, 1 to 4)
-   Speeds of the cars: 62 MPH, 69 MPH, 75 MPH, 81 MPH (all different, 1 to 4)

### Constraints:
-   The Leden drove 25 miles farther than the automobile with a high speed of 75 MPH:
    For this, we will need to add a constraint for each possible assignment of distances for Leden and the car with a speed of 75 MPH, such that Leden's distance is 25 miles more than the 75 MPH car's distance. So, the constraints will be of the form:
    d1 == Leden and d2 == 75MPH_car => d1_to_int == d2_to_int + 25, for all d1, d2 in distances.

-   The Poltris drove 25 miles farther than the automobile with a high speed of 69 MPH:
    For this, we will need to add a constraint for each possible assignment of distances for Poltris and the car with a speed of 69 MPH, such that Poltris's distance is 25 miles more than the 69 MPH car's distance. So, the constraints will be of the form:
    d1 == Poltris and d2 == 69MPH_car => d1_to_int == d2_to_int + 25, for all d1, d2 in distances.

-   The Awick drove somewhat less than the automobile with a high speed of 81 MPH:
    For this, we will need to add a constraint for each possible assignment of distances for Awick and the car with a speed of 81 MPH, such that Awick's distance is less than the 81 MPH car's distance. So, the constraints will be of the form:
    d1 == Awick and d2 == 81MPH_car => d1_to_int < d2_to_int, for all d1, d2 in distances.

-   The car with a high speed of 69 MPH drove somewhat farther than the automobile with a high speed of 81 MPH:
    For this, we will need to add a constraint for each possible assignment of distances for the 69 MPH car and the 81 MPH car, such that the 69 MPH car's distance is greater than the 81 MPH car's distance. So, the constraints will be of the form:
    d1 == 69MPH_car and d2 == 81MPH_car => d1_to_int > d2_to_int, for all d1, d2 in distances.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of car, distance, and speed)
# e.g. if awick == 1 and miles525 == 1 and speed62 == 1, then Awick drove 525 miles with a speed of 62 MPH
awick, leden, poltris, versem = cars = intvar(1, 4, shape=4)
miles525, miles550, miles575, miles600 = distances = intvar(1, 4, shape=4)
speed62, speed69, speed75, speed81 = speeds = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
car_to_int = None  # N/A
distance_to_int = {miles525: 525, miles550: 550, miles575: 575, miles600: 600}  # in miles
speed_to_int = {speed62: 62, speed69: 69, speed75: 75, speed81: 81}  # in MPH


# Helper functions (for formulating comparison constraints)
def drove_further_than(var1, var2, diff):
    """
    Formulate the constraint that var1 drove diff miles farther than var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(distance_to_int[d1] == distance_to_int[d2] + diff)
            for d1 in distances for d2 in distances]


def drove_less_than(var1, var2):
    """
    Formulate the constraint that var1 drove less miles than var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(distance_to_int[d1] < distance_to_int[d2])
            for d1 in distances for d2 in distances]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(cars)
m += AllDifferent(distances)
m += AllDifferent(speeds)

# Clue 1: The Leden drove 25 miles farther than the automobile with a high speed of 75 MPH:
m += drove_further_than(leden, speed75, 25)

# Clue 2: The Poltris drove 25 miles farther than the automobile with a high speed of 69 MPH:
m += drove_further_than(poltris, speed69, 25)

# Clue 3: The Awick drove somewhat less than the automobile with a high speed of 81 MPH:
m += drove_less_than(awick, speed81)

# Clue 4: The car with a high speed of 69 MPH drove somewhat farther than the automobile with a high speed of 81 MPH:
m += drove_further_than(speed69, speed81, 1)

```
False
False
False
Wrong: 1, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The report from Zearing was either the August 4 report or Edith Estes's report.
Hal Harrison's report was submitted sometime after Iva Ingram's sighting.
The August 5 sighting was from Islesboro.
The report from Tarzana was submitted 1 day before the sighting from Islesboro.
Benny Baron's report was received on August 7.

Entities:
witnesses: Benny Baron, Edith Estes, Hal Harrison, Iva Ingram
dates: August 4, August 5, August 6, August 7
towns: Islesboro, Long Barn, Tarzana, Zearing
VAR (54-55): 4
PARAM (178-179): 5
VAR (198-207): Islesboro
VAR (226-233): Tarzana
PARAM (248-249): 1
VAR (279-288): Islesboro
PARAM (336-337): 7
PARAM (432-433): 4
PARAM (443-444): 5
PARAM (454-455): 6
PARAM (465-466): 7
VAR (475-484): Islesboro
VAR (499-506): Tarzana

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if BennyBaron == 1, and August7 == 1, and Islesboro == 1, then Benny Baron's report was received on August 7 from Islesboro.

### Decision variables:
-   Names of the witnesses: BennyBaron, EdithEstes, HalHarrison, IvaIngram (all different, 1 to 4)
-   Dates of the reports: August4, August5, August6, August7 (all different, 1 to 4)
-   Names of the towns: Islesboro, LongBarn, Tarzana, Zearing (all different, 1 to 4)

### Constraints:
-   The report from Zearing was either the August 4 report or Edith Estes's report:
    This is a constraint that states that the report from Zearing's date is either August 4 or the date of Edith Estes's report, but not both. So:
    Xor([Zearing == August4, Zearing == EdithEstes]).

-   Hal Harrison's report was submitted sometime after Iva Ingram's sighting:
    For this, we will need to add a constraint for each possible assignment of the dates for Hal Harrison and Iva Ingram, such that Hal Harrison's report date is greater than Iva Ingram's report date. So, the constraints will be of the form:
    d1 == HalHarrison and d2 == IvaIngram => d1_to_int > d2_to_int, for all d1, d2 in dates.

-   The August 5 sighting was from Islesboro:
    This is a direct assignment constraint:
    August5 == Islesboro.

-   The report from Tarzana was submitted 1 day before the sighting from Islesboro:
    For this, we will need to add a constraint for each possible assignment of the dates for Tarzana and Islesboro, such that Tarzana's report date is 1 less than Islesboro's report date. So, the constraints will be of the form:
    d1 == Tarzana and d2 == Islesboro => d1_to_int == d2_to_int - 1, for all d1, d2 in dates.

-   Benny Baron's report was received on August 7:
    This is a direct assignment constraint:
    BennyBaron == August7.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if BennyBaron == 1, and August7 == 1, and Islesboro == 1, then Benny Baron's report was received on August 7 from Islesboro.

### Decision variables:
-   Names of the witnesses: BennyBaron, EdithEstes, HalHarrison, IvaIngram (all different, 1 to 4)
-   Dates of the reports: August4, August5, August6, August7 (all different, 1 to 4)
-   Names of the towns: Islesboro, LongBarn, Tarzana, Zearing (all different, 1 to 4)

### Constraints:
-   The report from Zearing was either the August 4 report or Edith Estes's report:
    This is a constraint that states that the report from Zearing's date is either August 4 or the date of Edith Estes's report, but not both. So:
    Xor([Zearing == August4, Zearing == EdithEstes]).

-   Hal Harrison's report was submitted sometime after Iva Ingram's sighting:
    For this, we will need to add a constraint for each possible assignment of the dates for Hal Harrison and Iva Ingram, such that Hal Harrison's report date is greater than Iva Ingram's report date. So, the constraints will be of the form:
    d1 == HalHarrison and d2 == IvaIngram => d1_to_int > d2_to_int, for all d1, d2 in dates.

-   The August 5 sighting was from Islesboro:
    This is a direct assignment constraint:
    August5 == Islesboro.

-   The report from Tarzana was submitted 1 day before the sighting from Islesboro:
    For this, we will need to add a constraint for each possible assignment of the dates for Tarzana and Islesboro, such that Tarzana's report date is 1 less than Islesboro's report date. So, the constraints will be of the form:
    d1 == Tarzana and d2 == Islesboro => d1_to_int == d2_to_int - 1, for all d1, d2 in dates.

-   Benny Baron's report was received on August 7:
    This is a direct assignment constraint:
    BennyBaron == August7.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of witness, date, and town)
# e.g. if benny == 1 and aug7 == 1 and islesboro == 1, then Benny Baron's report was received on August 7 from Islesboro
benny, edith, hal, iva = witnesses = intvar(1, 4, shape=4)
aug4, aug5, aug6, aug7 = dates = intvar(1, 4, shape=4)
islesboro, long_barn, tarzana, zearing = towns = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
witness_to_int = None  # N/A
date_to_int = {aug4: 4, aug5: 5, aug6: 6, aug7: 7}  # in days
town_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def submitted_after_than(var1, var2):
    """
    Formulate the constraint that var1 submitted after var2.
    """
    return [((w1 == var1) & (w2 == var2)).implies(date_to_int[w1] > date_to_int[w2])
            for w1 in dates for w2 in dates]


def submitted_exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 submitted exactly diff days after var2.
    """
    return [((w1 == var1) & (w2 == var2)).implies(date_to_int[w1] == date_to_int[w2] + diff)
            for w1 in dates for w2 in dates]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(witnesses)
m += AllDifferent(dates)
m += AllDifferent(towns)

# Clue 1: The report from Zearing was either the August 4 report or Edith Estes's report:
m += Xor([zearing == aug4, zearing == edith])

# Clue 2: Hal Harrison's report was submitted sometime after Iva Ingram's sighting:
m += submitted_after_than(hal, iva)

# Clue 3: The August 5 sighting was from Islesboro:
m += aug5 == islesboro

# Clue 4: The report from Tarzana was submitted 1 day before the sighting from Islesboro:
m += submitted_exactly_after_than(tarzana, islesboro, -1)

# Clue 5: Benny Baron's report was received on August 7:
m += benny == aug7

```
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Sunshine is either the condor with a wingspan of 102 inches or the 5-year-old bird.
The condor with a wingspan of 114 inches is 5 years old.
Pepper has a wingspan of 114 inches.
The four condors are the 9-year-old bird, Pepper, Merlin and the condor with a wingspan of 106 inches.
The 9-year-old bird has a wingspan 4 inches shorter than the 4-year-old bird.

Entities:
wingspans: 102 inches, 106 inches, 110 inches, 114 inches
names: Merlin, Pepper, Spike, Sunshine
ages: 4, 5, 8, 9
VAR (31-37): condor
PARAM (57-60): 102
PARAM (75-76): 5
VAR (101-107): condor
PARAM (127-130): 114
PARAM (141-142): 5
VAR (155-161): Pepper
PARAM (180-183): 114
VAR (218-219): 9
VAR (233-237): bird
VAR (240-246): Pepper
VAR (249-255): Merlin
VAR (264-270): condor
PARAM (290-293): 106
VAR (307-315): 9 - year
VAR (318-326): old bird
PARAM (342-343): 4
VAR (368-376): 4 - year
VAR (379-387): old bird
PARAM (413-416): 102
PARAM (426-429): 106
PARAM (439-442): 110
PARAM (452-455): 114
VAR (471-477): Merlin
VAR (480-486): Pepper
PARAM (513-514): 4
PARAM (517-518): 5
PARAM (521-522): 8
PARAM (525-526): 9

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Sunshine == 1, and Inches102 == 1, and Age5 == 1, then Sunshine is the condor with a wingspan of 102 inches and is 5 years old.

### Decision variables:
-   Names of the condors: Merlin, Pepper, Spike, Sunshine (all different, 1 to 4)
-   Wingspans: Inches102, Inches106, Inches110, Inches114 (all different, 1 to 4)
-   Ages of the birds: Age4, Age5, Age8, Age9 (all different, 1 to 4)

### Constraints:
-   Sunshine is either the condor with a wingspan of 102 inches or the 5-year-old bird:
    This is a constraint that states that Sunshine's wingspan is either 102 inches or Sunshine's age is 5, but not both. So:
    Xor([Sunshine == Inches102, Sunshine == Age5]).

-   The condor with a wingspan of 114 inches is 5 years old:
    This is a direct assignment constraint:
    Inches114 == Age5.

-   Pepper has a wingspan of 114 inches:
    This is a direct assignment constraint:
    Pepper == Inches114.

-   The four condors are the 9-year-old bird, Pepper, Merlin, and the condor with a wingspan of 106 inches:
    This is a constraint that states the four entities, thus:
    AllDifferent([Age9, Pepper, Merlin, Inches106]).

-   The 9-year-old bird has a wingspan 4 inches shorter than the 4-year-old bird:
    For this, we will need to add a constraint for each possible assignment of the wingspans for the 9-year-old bird and the 4-year-old bird, such that the 9-year-old bird's wingspan is 4 less than the 4-year-old bird's wingspan. So, the constraints will be of the form:
    w1 == Age9 and w2 == Age4 => w1_to_int == w2_to_int - 4, for all w1, w2 in wingspans.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Sunshine == 1, and Inches102 == 1, and Age5 == 1, then Sunshine is the condor with a wingspan of 102 inches and is 5 years old.

### Decision variables:
-   Names of the condors: Merlin, Pepper, Spike, Sunshine (all different, 1 to 4)
-   Wingspans: Inches102, Inches106, Inches110, Inches114 (all different, 1 to 4)
-   Ages of the birds: Age4, Age5, Age8, Age9 (all different, 1 to 4)

### Constraints:
-   Sunshine is either the condor with a wingspan of 102 inches or the 5-year-old bird:
    This is a constraint that states that Sunshine's wingspan is either 102 inches or Sunshine's age is 5, but not both. So:
    Xor([Sunshine == Inches102, Sunshine == Age5]).

-   The condor with a wingspan of 114 inches is 5 years old:
    This is a direct assignment constraint:
    Inches114 == Age5.

-   Pepper has a wingspan of 114 inches:
    This is a direct assignment constraint:
    Pepper == Inches114.

-   The four condors are the 9-year-old bird, Pepper, Merlin, and the condor with a wingspan of 106 inches:
    This is a constraint that states the four entities, thus:
    AllDifferent([Age9, Pepper, Merlin, Inches106]).

-   The 9-year-old bird has a wingspan 4 inches shorter than the 4-year-old bird:
    For this, we will need to add a constraint for each possible assignment of the wingspans for the 9-year-old bird and the 4-year-old bird, such that the 9-year-old bird's wingspan is 4 less than the 4-year-old bird's wingspan. So, the constraints will be of the form:
    w1 == Age9 and w2 == Age4 => w1_to_int == w2_to_int - 4, for all w1, w2 in wingspans.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of condor, wingspan, and age)
# e.g. if merlin == 1 and inches102 == 1 and age4 == 1, then Merlin has a wingspan of 102 inches and is 4 years old
merlin, pepper, spike, sunshine = condors = intvar(1, 4, shape=4)
inches102, inches106, inches110, inches114 = wingspans = intvar(1, 4, shape=4)
age4, age5, age8, age9 = ages = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
condor_to_int = None  # N/A
wingspan_to_int = {inches102: 102, inches106: 106, inches110: 110, inches114: 114}  # in inches
age_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def wingspan_shorter_than(var1, var2, diff):
    """
    Formulate the constraint that var1's wingspan is diff inches shorter than var2's wingspan.
    """
    return [((w1 == var1) & (w2 == var2)).implies(wingspan_to_int[w1] == wingspan_to_int[w2] - diff)
            for w1 in wingspans for w2 in wingspans]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(condors)
m += AllDifferent(wingspans)
m += AllDifferent(ages)

# Clue 1: Sunshine is either the condor with a wingspan of 102 inches or the 5-year-old bird:
m += Xor([sunshine == inches102, sunshine == age5])

# Clue 2: The condor with a wingspan of 114 inches is 5 years old:
m += inches114 == age5

# Clue 3: Pepper has a wingspan of 114 inches:
m += pepper == inches114

# Clue 4: The four condors are the 9-year-old bird, Pepper, Merlin, and the condor with a wingspan of 106 inches:
m += AllDifferent([age9, pepper, merlin, inches106])

# Clue 5: The 9-year-old bird has a wingspan 4 inches shorter than the 4-year-old bird:
m += wingspan_shorter_than(age9, age4, 4)

```
True
True
True
Wrong: 1, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The puzzle with the autumn leaves theme has somewhat more than the jigsaw puzzle with the rustic village theme.
The four puzzles are the puzzle made by Buralde, the jigsaw puzzle with the rustic village theme, the puzzle with the autumn leaves theme and the puzzle with 1000 pieces.
The jigsaw puzzle made by Buralde has the outer space theme.
The jigsaw puzzle made by Denlend has somewhat fewer than the jigsaw puzzle with the outer space theme.
The jigsaw puzzle made by Kimsight has 250 more pieces than the puzzle made by Denlend.

Entities:
companies: Buralde, Denlend, Irycia, Kimsight
pieces: 250, 500, 750, 1000
themes: autumn leaves, coral reef, outer space, rustic village
VAR (28-41): autumn leaves
VAR (98-118): rustic village theme
VAR (182-188): puzzle
VAR (198-218): rustic village theme
VAR (241-254): autumn leaves
PARAM (281-285): 1000
VAR (321-328): Buralde
VAR (383-390): Denlend
VAR (448-459): space theme
VAR (488-496): Kimsight
PARAM (501-504): 250
VAR (541-548): Denlend
VAR (603-611): Kimsight
PARAM (621-624): 250
PARAM (627-630): 500
PARAM (633-636): 750
PARAM (639-643): 1000

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Buralde == 1, and 1000Pieces == 1, and AutumnLeaves == 1, then Buralde made the puzzle with 1000 pieces and the autumn leaves theme.

### Decision variables:
-   Companies that made the puzzles: Buralde, Denlend, Irycia, Kimsight (all different, 1 to 4)
-   Number of pieces in the puzzles: 250, 500, 750, 1000 (all different, 1 to 4)
-   Themes of the puzzles: AutumnLeaves, CoralReef, OuterSpace, RusticVillage (all different, 1 to 4)

### Constraints:
-   The puzzle with the autumn leaves theme has somewhat more than the jigsaw puzzle with the rustic village theme:
    This constraint implies that the puzzle with the autumn leaves theme has more pieces than the puzzle with the rustic village theme. So, for each pair of pieces, we need to add a constraint to represent this relationship:
    p1 == AutumnLeaves and p2 == RusticVillage => p1_to_int > p2_to_int + 1, for all p1, p2 in pieces.

-   The four puzzles are the puzzle made by Buralde, the jigsaw puzzle with the rustic village theme, the puzzle with the autumn leaves theme, and the puzzle with 1000 pieces:
    This constraint ensures that each of the entities is assigned to one of the four categories. It can be represented as:
    AllDifferent([Buralde, RusticVillage, AutumnLeaves, 1000Pieces]).

-   The jigsaw puzzle made by Buralde has the outer space theme:
    This is a direct assignment constraint:
    Buralde == OuterSpace.

-   The jigsaw puzzle made by Denlend has somewhat fewer than the jigsaw puzzle with the outer space theme:
    This constraint implies that the puzzle made by Denlend has fewer pieces than the puzzle with the outer space theme. So, for each pair of pieces, we need to add a constraint to represent this relationship:
    p1 == Denlend and p2 == OuterSpace => p1_to_int < p2_to_int - 1, for all p1, p2 in pieces.

-   The jigsaw puzzle made by Kimsight has 250 more pieces than the puzzle made by Denlend:
    This constraint implies that the puzzle made by Kimsight has 250 more pieces than the puzzle made by Denlend. So, for each pair of pieces, we need to add a constraint to represent this relationship:
    p1 == Kimsight and p2 == Denlend => p1_to_int == p2_to_int + 250, for all p1, p2 in pieces.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Buralde == 1, and 1000Pieces == 1, and AutumnLeaves == 1, then Buralde made the puzzle with 1000 pieces and the autumn leaves theme.

### Decision variables:
-   Companies that made the puzzles: Buralde, Denlend, Irycia, Kimsight (all different, 1 to 4)
-   Number of pieces in the puzzles: 250, 500, 750, 1000 (all different, 1 to 4)
-   Themes of the puzzles: AutumnLeaves, CoralReef, OuterSpace, RusticVillage (all different, 1 to 4)

### Constraints:
-   The puzzle with the autumn leaves theme has somewhat more than the jigsaw puzzle with the rustic village theme:
    This constraint implies that the puzzle with the autumn leaves theme has more pieces than the puzzle with the rustic village theme. So, for each pair of pieces, we need to add a constraint to represent this relationship:
    p1 == AutumnLeaves and p2 == RusticVillage => p1_to_int > p2_to_int + 1, for all p1, p2 in pieces.

-   The four puzzles are the puzzle made by Buralde, the jigsaw puzzle with the rustic village theme, the puzzle with the autumn leaves theme, and the puzzle with 1000 pieces:
    This constraint ensures that each of the entities is assigned to one of the four categories. It can be represented as:
    AllDifferent([Buralde, RusticVillage, AutumnLeaves, 1000Pieces]).

-   The jigsaw puzzle made by Buralde has the outer space theme:
    This is a direct assignment constraint:
    Buralde == OuterSpace.

-   The jigsaw puzzle made by Denlend has somewhat fewer than the jigsaw puzzle with the outer space theme:
    This constraint implies that the puzzle made by Denlend has fewer pieces than the puzzle with the outer space theme. So, for each pair of pieces, we need to add a constraint to represent this relationship:
    p1 == Denlend and p2 == OuterSpace => p1_to_int < p2_to_int - 1, for all p1, p2 in pieces.

-   The jigsaw puzzle made by Kimsight has 250 more pieces than the puzzle made by Denlend:
    This constraint implies that the puzzle made by Kimsight has 250 more pieces than the puzzle made by Denlend. So, for each pair of pieces, we need to add a constraint to represent this relationship:
    p1 == Kimsight and p2 == Denlend => p1_to_int == p2_to_int + 250, for all p1, p2 in pieces.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of company, theme, and pieces)
# e.g. if buralde == 1 and autumn_leaves == 1 and pieces1000 == 1, then Buralde made the puzzle with the autumn leaves theme and 1000 pieces
buralde, denlend, irycia, kimsight = companies = intvar(1, 4, shape=4)
pieces250, pieces500, pieces750, pieces1000 = pieces = intvar(1, 4, shape=4)
autumn_leaves, coral_reef, outer_space, rustic_village = themes = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
company_to_int = None  # N/A
theme_to_int = None  # N/A
pieces_to_int = {pieces250: 250, pieces500: 500, pieces750: 750, pieces1000: 1000}  # in pieces


# Helper functions (for formulating comparison constraints)
def somewhat_more_than(var1, var2):
    """
    Formulate the constraint that var1 has somewhat more pieces than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(pieces_to_int[p1] > pieces_to_int[p2] + 1)
            for p1 in pieces for p2 in pieces]


def somewhat_fewer_than(var1, var2):
    """
    Formulate the constraint that var1 has somewhat fewer pieces than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(pieces_to_int[p1] < pieces_to_int[p2] - 1)
            for p1 in pieces for p2 in pieces]


def pieces_difference(var1, var2, diff):
    """
    Formulate the constraint that var1 has diff more pieces than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(pieces_to_int[p1] == pieces_to_int[p2] + diff)
            for p1 in pieces for p2 in pieces]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(companies)
m += AllDifferent(themes)
m += AllDifferent(pieces)

# Clue 1: The puzzle with the autumn leaves theme has somewhat more than the jigsaw puzzle with the rustic village theme:
m += somewhat_more_than(autumn_leaves, rustic_village)

# Clue 2: The four puzzles are the puzzle made by Buralde, the jigsaw puzzle with the rustic village theme, the puzzle with the autumn leaves theme, and the puzzle with 1000 pieces:
m += AllDifferent([buralde, rustic_village, autumn_leaves, pieces1000])

# Clue 3: The jigsaw puzzle made by Buralde has the outer space theme:
m += buralde == outer_space

# Clue 4: The jigsaw puzzle made by Denlend has somewhat fewer than the jigsaw puzzle with the outer space theme:
m += somewhat_fewer_than(denlend, outer_space)

# Clue 5: The jigsaw puzzle made by Kimsight has 250 more pieces than the puzzle made by Denlend:
m += pieces_difference(kimsight, denlend, 250)

```
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The worker who works in the green section served more riders than Brett.
Peter served 25 fewer riders than Willis.
Brett served more riders than Peter.
The person who works in the yellow section served 25 more riders than the worker who works in the orange section.
Peter is either the person who served 125 riders or the person who works in the blue section.

Entities:
employees: Brett, Peter, Victor, Willis
rides: 50 riders, 75 riders, 100 riders, 125 riders
section: blue, green, orange, yellow
VAR (36-49): green section
PARAM (95-97): 25
VAR (191-205): yellow section
PARAM (213-215): 25
OBJ_NAME (221-227): riders
VAR (261-275): orange section
PARAM (316-319): 125
VAR (358-370): blue section
PARAM (436-438): 50
PARAM (448-450): 75
PARAM (460-463): 100
PARAM (473-476): 125
VAR (494-498): blue
VAR (501-506): green
VAR (509-515): orange
VAR (518-524): yellow

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Brett == 1, and Blue == 1, and Rides50 == 1, then Brett works in the blue section and served 50 riders.

### Decision variables:
-   Names of the employees: Brett, Peter, Victor, Willis (all different, 1 to 4)
-   Number of rides served: 50 riders, 75 riders, 100 riders, 125 riders (all different, 1 to 4)
-   Sections: Blue, Green, Orange, Yellow (all different, 1 to 4)

### Constraints:
-   The worker who works in the green section served more riders than Brett:
    For this, we will need to add a constraint for each possible assignment of employees to sections, such that the worker in the green section served more riders than Brett. So, the constraints will be of the form:
    e1 == Green and e2 == Brett => e1_to_int > e2_to_int, for all e1, e2 in employees.

-   Peter served 25 fewer riders than Willis:
    For this, we will need to add a constraint for each possible assignment of employees to the number of rides served, such that Peter served 25 fewer riders than Willis. So, the constraints will be of the form:
    e1 == Peter and e2 == Willis => e1_to_int == e2_to_int - 25, for all e1, e2 in employees.

-   Brett served more riders than Peter:
    For this, we will need to add a constraint for each possible assignment of employees to the number of rides served, such that Brett served more riders than Peter. So, the constraints will be of the form:
    e1 == Brett and e2 == Peter => e1_to_int > e2_to_int, for all e1, e2 in employees.

-   The person who works in the yellow section served 25 more riders than the worker who works in the orange section:
    For this, we will need to add a constraint for each possible assignment of employees to sections, such that the worker in the yellow section served 25 more riders than the worker in the orange section. So, the constraints will be of the form:
    e1 == Yellow and e2 == Orange => e1_to_int == e2_to_int + 25, for all e1, e2 in employees.

-   Peter is either the person who served 125 riders or the person who works in the blue section:
    This is a constraint that states that Peter is either the person who served 125 riders or the person who works in the blue section, but not both. So:
    Xor([Peter == Rides125, Peter == Blue]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Brett == 1, and Blue == 1, and Rides50 == 1, then Brett works in the blue section and served 50 riders.

### Decision variables:
-   Names of the employees: Brett, Peter, Victor, Willis (all different, 1 to 4)
-   Number of rides served: 50 riders, 75 riders, 100 riders, 125 riders (all different, 1 to 4)
-   Sections: Blue, Green, Orange, Yellow (all different, 1 to 4)

### Constraints:
-   The worker who works in the green section served more riders than Brett:
    For this, we will need to add a constraint for each possible assignment of employees to sections, such that the worker in the green section served more riders than Brett. So, the constraints will be of the form:
    e1 == Green and e2 == Brett => e1_to_int > e2_to_int, for all e1, e2 in employees.

-   Peter served 25 fewer riders than Willis:
    For this, we will need to add a constraint for each possible assignment of employees to the number of rides served, such that Peter served 25 fewer riders than Willis. So, the constraints will be of the form:
    e1 == Peter and e2 == Willis => e1_to_int == e2_to_int - 25, for all e1, e2 in employees.

-   Brett served more riders than Peter:
    For this, we will need to add a constraint for each possible assignment of employees to the number of rides served, such that Brett served more riders than Peter. So, the constraints will be of the form:
    e1 == Brett and e2 == Peter => e1_to_int > e2_to_int, for all e1, e2 in employees.

-   The person who works in the yellow section served 25 more riders than the worker who works in the orange section:
    For this, we will need to add a constraint for each possible assignment of employees to sections, such that the worker in the yellow section served 25 more riders than the worker in the orange section. So, the constraints will be of the form:
    e1 == Yellow and e2 == Orange => e1_to_int == e2_to_int + 25, for all e1, e2 in employees.

-   Peter is either the person who served 125 riders or the person who works in the blue section:
    This is a constraint that states that Peter is either the person who served 125 riders or the person who works in the blue section, but not both. So:
    Xor([Peter == Rides125, Peter == Blue]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of employee, rides, and section)
# e.g. if brett == 1 and rides50 == 1 and blue == 1, then Brett served 50 riders and works in the blue section
brett, peter, victor, willis = employees = intvar(1, 4, shape=4)
rides50, rides75, rides100, rides125 = rides = intvar(1, 4, shape=4)
blue, green, orange, yellow = sections = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
employee_to_int = None  # N/A
rides_to_int = {rides50: 50, rides75: 75, rides100: 100, rides125: 125}  # in riders
section_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def served_more_than(var1, var2):
    """
    Formulate the constraint that var1 served more riders than var2.
    """
    return [((e1 == var1) & (e2 == var2)).implies(rides_to_int[e1] > rides_to_int[e2])
            for e1 in rides for e2 in rides]


def served_fewer_than(var1, var2, diff):
    """
    Formulate the constraint that var1 served diff fewer riders than var2.
    """
    return [((e1 == var1) & (e2 == var2)).implies(rides_to_int[e1] == rides_to_int[e2] - diff)
            for e1 in rides for e2 in rides]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(employees)
m += AllDifferent(rides)
m += AllDifferent(sections)

# Clue 1: The worker who works in the green section served more riders than Brett:
m += served_more_than(green, brett)

# Clue 2: Peter served 25 fewer riders than Willis:
m += served_fewer_than(peter, willis, 25)

# Clue 3: Brett served more riders than Peter:
m += served_more_than(brett, peter)

# Clue 4: The person who works in the yellow section served 25 more riders than the worker who works in the orange section:
m += [((s1 == yellow) & (s2 == orange)).implies(rides_to_int[s1] == rides_to_int[s2] + 25)
      for s1 in rides for s2 in rides]

# Clue 5: Peter is either the person who served 125 riders or the person who works in the blue section:
m += Xor([peter == rides125, peter == blue])

```
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The team from Venezuela finished with 4 gold medals.
The squad that won 2 gold medals ended with 6 silver medals.
The four teams were the squad from Zimbabwe, the team that won 3 gold medals, the squad that won 6 silver medals and the squad that won 8 silver medals.
The team from Dominica ended the games with 1 fewer gold medal than the squad that won 5 silver medals.

Entities:
countries: Dominica, Jordan, Venezuela, Zimbabwe
gold medals: 1, 2, 3, 4
silver medals: 2, 5, 6, 8
VAR (22-31): Venezuela
PARAM (46-47): 4
PARAM (81-82): 2
PARAM (106-107): 6
VAR (159-167): Zimbabwe
PARAM (188-189): 3
PARAM (223-224): 6
PARAM (262-263): 8
VAR (294-302): Dominica
PARAM (324-325): 1
PARAM (367-368): 5
VAR (408-416): Dominica
VAR (419-425): Jordan
VAR (428-437): Venezuela
VAR (440-448): Zimbabwe
PARAM (463-464): 1
PARAM (467-468): 2
PARAM (471-472): 3
PARAM (475-476): 4
PARAM (493-494): 2
PARAM (497-498): 5
PARAM (501-502): 6
PARAM (505-506): 8

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Dominica == 1, and Gold1 == 1, and Silver2 == 1, then Dominica won 1 gold medal and 2 silver medals.

### Decision variables:
-   Countries: Dominica, Jordan, Venezuela, Zimbabwe (all different, 1 to 4)
-   Gold medals won: 1, 2, 3, 4 (all different, 1 to 4)
-   Silver medals won: 2, 5, 6, 8 (all different, 1 to 4)

### Constraints:
-   The team from Venezuela finished with 4 gold medals:
    This is a direct assignment constraint:
    Venezuela == Gold4.

-   The squad that won 2 gold medals ended with 6 silver medals:
    This is a direct assignment constraint:
    Gold2 == Silver6.

-   The four teams were the squad from Zimbabwe, the team that won 3 gold medals, the squad that won 6 silver medals, and the squad that won 8 silver medals:
    This is a constraint that states that all these entities are different, thus:
    AllDifferent([Zimbabwe, Gold3, Silver6, Silver8]).

-   The team from Dominica ended the games with 1 fewer gold medal than the squad that won 5 silver medals:
    For this, we will need to add a constraint for each possible assignment of gold medals for Dominica and the squad that won 5 silver medals, such that Dominica's gold medals are 1 less than the squad's silver medals. So, the constraints will be of the form:
    g1 == Dominica and s1 == Silver5 => g1_to_int == s1_to_int - 1, for all g1, s1 in gold medals and silver medals.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Dominica == 1, and Gold1 == 1, and Silver2 == 1, then Dominica won 1 gold medal and 2 silver medals.

### Decision variables:
-   Countries: Dominica, Jordan, Venezuela, Zimbabwe (all different, 1 to 4)
-   Gold medals won: 1, 2, 3, 4 (all different, 1 to 4)
-   Silver medals won: 2, 5, 6, 8 (all different, 1 to 4)

### Constraints:
-   The team from Venezuela finished with 4 gold medals:
    This is a direct assignment constraint:
    Venezuela == Gold4.

-   The squad that won 2 gold medals ended with 6 silver medals:
    This is a direct assignment constraint:
    Gold2 == Silver6.

-   The four teams were the squad from Zimbabwe, the team that won 3 gold medals, the squad that won 6 silver medals, and the squad that won 8 silver medals:
    This is a constraint that states that all these entities are different, thus:
    AllDifferent([Zimbabwe, Gold3, Silver6, Silver8]).

-   The team from Dominica ended the games with 1 fewer gold medal than the squad that won 5 silver medals:
    For this, we will need to add a constraint for each possible assignment of gold medals for Dominica and the squad that won 5 silver medals, such that Dominica's gold medals are 1 less than the squad's silver medals. So, the constraints will be of the form:
    g1 == Dominica and s1 == Silver5 => g1_to_int == s1_to_int - 1, for all g1, s1 in gold medals and silver medals.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of country, gold medals, and silver medals)
# e.g. if dominica == 1 and gold1 == 1 and silver2 == 1, then Dominica won 1 gold medal and 2 silver medals
dominica, jordan, venezuela, zimbabwe = countries = intvar(1, 4, shape=4)
gold1, gold2, gold3, gold4 = gold_medals = intvar(1, 4, shape=4)
silver2, silver5, silver6, silver8 = silver_medals = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
country_to_int = None  # N/A
gold_to_int = {gold1: 1, gold2: 2, gold3: 3, gold4: 4}  # in medals
silver_to_int = {silver2: 2, silver5: 5, silver6: 6, silver8: 8}  # in medals


# Helper functions (for formulating comparison constraints)
def one_less_gold_than(var1, var2):
    """
    Formulate the constraint that var1 has 1 less gold medal than var2.
    """
    return [((g1 == var1) & (s1 == var2)).implies(gold_to_int[g1] == silver_to_int[s1] - 1)
            for g1 in gold_medals for s1 in silver_medals]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(countries)
m += AllDifferent(gold_medals)
m += AllDifferent(silver_medals)

# Clue 1: The team from Venezuela finished with 4 gold medals:
m += venezuela == gold4

# Clue 2: The squad that won 2 gold medals ended with 6 silver medals:
m += gold2 == silver6

# Clue 3: The four teams were the squad from Zimbabwe, the team that won 3 gold medals, the squad that won 6 silver medals, and the squad that won 8 silver medals:
m += AllDifferent([zimbabwe, gold3, silver6, silver8])

# Clue 4: The team from Dominica ended the games with 1 fewer gold medal than the squad that won 5 silver medals:
m += one_less_gold_than(dominica, silver5)

```
False
False
False
Wrong: 1, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The Vorckin impact crater is 125 meters wide.
The 150 meters wide one is either the Ordovician impact crater or the Permian impact crater.
The Ordovician impact crater is 25 meters wider than the Jurassic impact crater.
The Triassic impact crater is either the Ormagh impact crater or the 150 meters wide one.
The Cersay impact crater was formed during the Jurassic period.

Entities:
craters: Cersay, Moriwa, Ormagh, Vorckin
diameters: 100 meters, 125 meters, 150 meters, 175 meters
periods: Jurassic, Ordovician, Permian, Triassic
PARAM (37-40): 125
PARAM (59-62): 150
VAR (93-117): Ordovician impact crater
VAR (125-146): Permian impact crater
VAR (153-177): Ordovician impact crater
PARAM (181-183): 25
VAR (206-228): Jurassic impact crater
VAR (235-257): Triassic impact crater
VAR (272-292): Ormagh impact crater
PARAM (300-303): 150
VAR (326-346): Cersay impact crater
PARAM (455-458): 100
PARAM (468-471): 125
PARAM (481-484): 150
PARAM (494-497): 175
VAR (515-523): Jurassic
VAR (526-536): Ordovician
VAR (539-546): Permian
VAR (549-557): Triassic

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Cersay == 1, and 100m == 1, and Jurassic == 1, then the Cersay impact crater with a diameter of 100 meters was formed during the Jurassic period.

### Decision variables:
-   Names of the craters: Cersay, Moriwa, Ormagh, Vorckin (all different, 1 to 4)
-   Diameters of the craters: 100 meters, 125 meters, 150 meters, 175 meters (all different, 1 to 4)
-   Periods of formation: Jurassic, Ordovician, Permian, Triassic (all different, 1 to 4)

### Constraints:
-   The Vorckin impact crater is 125 meters wide:
    This is a direct assignment constraint:
    Vorckin == 125m.

-   The 150 meters wide one is either the Ordovician impact crater or the Permian impact crater:
    This is a constraint that states that the 150 meters wide crater is either the Ordovician impact crater or the Permian impact crater, but not both. So:
    Xor([150m == Ordovician, 150m == Permian]).

-   The Ordovician impact crater is 25 meters wider than the Jurassic impact crater:
    For this, we will need to add a constraint for each possible assignment of the diameters for the Ordovician and Jurassic impact craters, such that the Ordovician impact crater's diameter is 25 more than the Jurassic impact crater's diameter. So, the constraints will be of the form:
    d1 == Ordovician and d2 == Jurassic => d1_to_int == d2_to_int + 25, for all d1, d2 in diameters.

-   The Triassic impact crater is either the Ormagh impact crater or the 150 meters wide one:
    This is a constraint that states that the Triassic impact crater is either the Ormagh impact crater or the 150 meters wide crater, but not both. So:
    Xor([Triassic == Ormagh, Triassic == 150m]).

-   The Cersay impact crater was formed during the Jurassic period:
    This is a direct assignment constraint:
    Cersay == Jurassic.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Cersay == 1, and 100m == 1, and Jurassic == 1, then the Cersay impact crater with a diameter of 100 meters was formed during the Jurassic period.

### Decision variables:
-   Names of the craters: Cersay, Moriwa, Ormagh, Vorckin (all different, 1 to 4)
-   Diameters of the craters: 100 meters, 125 meters, 150 meters, 175 meters (all different, 1 to 4)
-   Periods of formation: Jurassic, Ordovician, Permian, Triassic (all different, 1 to 4)

### Constraints:
-   The Vorckin impact crater is 125 meters wide:
    This is a direct assignment constraint:
    Vorckin == 125m.

-   The 150 meters wide one is either the Ordovician impact crater or the Permian impact crater:
    This is a constraint that states that the 150 meters wide crater is either the Ordovician impact crater or the Permian impact crater, but not both. So:
    Xor([150m == Ordovician, 150m == Permian]).

-   The Ordovician impact crater is 25 meters wider than the Jurassic impact crater:
    For this, we will need to add a constraint for each possible assignment of the diameters for the Ordovician and Jurassic impact craters, such that the Ordovician impact crater's diameter is 25 more than the Jurassic impact crater's diameter. So, the constraints will be of the form:
    d1 == Ordovician and d2 == Jurassic => d1_to_int == d2_to_int + 25, for all d1, d2 in diameters.

-   The Triassic impact crater is either the Ormagh impact crater or the 150 meters wide one:
    This is a constraint that states that the Triassic impact crater is either the Ormagh impact crater or the 150 meters wide crater, but not both. So:
    Xor([Triassic == Ormagh, Triassic == 150m]).

-   The Cersay impact crater was formed during the Jurassic period:
    This is a direct assignment constraint:
    Cersay == Jurassic.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of crater, diameter, and period)
# e.g. if cersay == 1 and diameter100 == 1 and jurassic == 1, then the Cersay impact crater with a diameter of 100 meters was formed during the Jurassic period
cersay, moriwa, ormagh, vorckin = craters = intvar(1, 4, shape=4)
diameter100, diameter125, diameter150, diameter175 = diameters = intvar(1, 4, shape=4)
jurassic, ordovician, permian, triassic = periods = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
crater_to_int = None  # N/A
diameter_to_int = {diameter100: 100, diameter125: 125, diameter150: 150, diameter175: 175}  # in meters
period_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def wider_than(var1, var2, diff):
    """
    Formulate the constraint that var1 is diff meters wider than var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(diameter_to_int[d1] == diameter_to_int[d2] + diff)
            for d1 in diameters for d2 in diameters]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(craters)
m += AllDifferent(diameters)
m += AllDifferent(periods)

# Clue 1: The Vorckin impact crater is 125 meters wide:
m += vorckin == diameter125

# Clue 2: The 150 meters wide one is either the Ordovician impact crater or the Permian impact crater:
m += Xor([diameter150 == ordovician, diameter150 == permian])

# Clue 3: The Ordovician impact crater is 25 meters wider than the Jurassic impact crater:
m += wider_than(ordovician, jurassic, 25)

# Clue 4: The Triassic impact crater is either the Ormagh impact crater or the 150 meters wide one:
m += Xor([triassic == ormagh, triassic == diameter150])

# Clue 5: The Cersay impact crater was formed during the Jurassic period:
m += cersay == jurassic

```
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The butterfly that was auctioned 7th sold for 20 dollars less than the insect won by Daniel.
The four butterflies were the insect that sold for $260, the butterfly that was auctioned 4th, the butterfly that was auctioned 7th and the butterfly won by Roland.
The butterfly won by Gabriel was the 8th lot.

Entities:
winners: Daniel, Gabriel, Roland, Vincent
prices: $250, $260, $270, $280
orders: 3rd, 4th, 7th, 8th
VAR (12-21): butterfly
PARAM (41-44): 7th
OBJ_NAME (45-49): sold
PARAM (54-56): 20
OBJ_NAME (144-148): sold
PARAM (155-158): 260
VAR (165-174): butterfly
PARAM (194-197): 4th
VAR (204-213): butterfly
PARAM (233-236): 7th
VAR (245-254): butterfly
VAR (275-284): butterfly
PARAM (308-311): 8th
PARAM (386-389): 250
PARAM (394-397): 260
PARAM (402-405): 270
PARAM (410-413): 280
PARAM (423-426): 3rd
PARAM (429-432): 4th
PARAM (435-438): 7th
PARAM (441-444): 8th

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Daniel == 1, and $250 == 1, and 3rd == 1, then Daniel won the butterfly that was auctioned 3rd and sold for $250.

### Decision variables:
-   Winners of the butterflies: Daniel, Gabriel, Roland, Vincent (all different, 1 to 4)
-   Prices of the butterflies: $250, $260, $270, $280 (all different, 1 to 4)
-   Orders of the auctions: 3rd, 4th, 7th, 8th (all different, 1 to 4)

### Constraints:
-   The butterfly that was auctioned 7th sold for 20 dollars less than the insect won by Daniel:
    For this, we will need to add a constraint for each possible assignment of the prices for the butterfly auctioned 7th and the butterfly won by Daniel, such that the price of the 7th butterfly is $20 less than Daniel's butterfly. So, the constraints will be of the form:
    p1 == 7th and p2 == Daniel => p1_to_int == p2_to_int - 20, for all p1, p2 in prices.

-   The four butterflies were the insect that sold for $260, the butterfly that was auctioned 4th, the butterfly that was auctioned 7th, and the butterfly won by Roland:
    This is a constraint that states that these entities are the four different butterflies, thus:
    AllDifferent([$260, 4th, 7th, Roland]).

-   The butterfly won by Gabriel was the 8th lot:
    This is a direct assignment constraint:
    Gabriel == 8th.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Daniel == 1, and $250 == 1, and 3rd == 1, then Daniel won the butterfly that was auctioned 3rd and sold for $250.

### Decision variables:
-   Winners of the butterflies: Daniel, Gabriel, Roland, Vincent (all different, 1 to 4)
-   Prices of the butterflies: $250, $260, $270, $280 (all different, 1 to 4)
-   Orders of the auctions: 3rd, 4th, 7th, 8th (all different, 1 to 4)

### Constraints:
-   The butterfly that was auctioned 7th sold for 20 dollars less than the insect won by Daniel:
    For this, we will need to add a constraint for each possible assignment of the prices for the butterfly auctioned 7th and the butterfly won by Daniel, such that the price of the 7th butterfly is $20 less than Daniel's butterfly. So, the constraints will be of the form:
    p1 == 7th and p2 == Daniel => p1_to_int == p2_to_int - 20, for all p1, p2 in prices.

-   The four butterflies were the insect that sold for $260, the butterfly that was auctioned 4th, the butterfly that was auctioned 7th, and the butterfly won by Roland:
    This is a constraint that states that these entities are the four different butterflies, thus:
    AllDifferent([$260, 4th, 7th, Roland]).

-   The butterfly won by Gabriel was the 8th lot:
    This is a direct assignment constraint:
    Gabriel == 8th.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of winner, price, and order)
# e.g. if daniel == 1 and price250 == 1 and order3rd == 1, then Daniel won the butterfly that was auctioned 3rd and sold for $250
daniel, gabriel, roland, vincent = winners = intvar(1, 4, shape=4)
price250, price260, price270, price280 = prices = intvar(1, 4, shape=4)
order3rd, order4th, order7th, order8th = orders = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
winner_to_int = None  # N/A
price_to_int = {price250: 250, price260: 260, price270: 270, price280: 280}  # in dollars
order_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def sold_less_than(var1, var2, diff):
    """
    Formulate the constraint that var1 sold for $diff less than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] - diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(winners)
m += AllDifferent(prices)
m += AllDifferent(orders)

# Clue 1: The butterfly that was auctioned 7th sold for 20 dollars less than the insect won by Daniel:
m += sold_less_than(order7th, daniel, 20)

# Clue 2: The four butterflies were the insect that sold for $260, the butterfly that was auctioned 4th, the butterfly that was auctioned 7th, and the butterfly won by Roland:
m += AllDifferent([price260, order4th, order7th, roland])

# Clue 3: The butterfly won by Gabriel was the 8th lot:
m += gabriel == order8th

```
True
True
True
Wrong: 0, Total: 6
---------------------------------------------------------------------------------------------

Clues:
Greg threw the red darts.
Alton scored 7 points higher than Evan.
The contestant who threw the yellow darts scored somewhat higher than the player who threw the white darts.
The player who scored 48 points threw the yellow darts.
Greg scored 7 points higher than Jeffrey.

Entities:
players: Alton, Evan, Greg, Jeffrey
scores: 41, 48, 55, 62
colors: green, red, white, yellow
VAR (23-32): red darts
VAR (35-40): Alton
PARAM (48-49): 7
OBJ_NAME (50-56): points
VAR (105-117): yellow darts
VAR (171-182): white darts
PARAM (207-209): 48
VAR (227-239): yellow darts
PARAM (254-255): 7
OBJ_NAME (256-262): points
VAR (306-311): Alton
VAR (328-335): Jeffrey
PARAM (345-347): 41
PARAM (350-352): 48
PARAM (355-357): 55
PARAM (360-362): 62

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Alton == 1, and 41 == 1, and Green == 1, then Alton scored 41 points throwing green darts.

### Decision variables:
-   Players: Alton, Evan, Greg, Jeffrey (all different, 1 to 4)
-   Scores: 41, 48, 55, 62 (all different, 1 to 4)
-   Colors of darts: Green, Red, White, Yellow (all different, 1 to 4)

### Constraints:
-   Greg threw the red darts:
    This is a direct assignment constraint:
    Greg == RedDarts.

-   Alton scored 7 points higher than Evan:
    For this, we will need to add a constraint for each possible assignment of scores for Alton and Evan, such that Alton's score is 7 more than Evan's score. So, the constraints will be of the form:
    s1 == Alton and s2 == Evan => s1_to_int == s2_to_int + 7, for all s1, s2 in scores.

-   The contestant who threw the yellow darts scored somewhat higher than the player who threw the white darts:
    This constraint implies that the player who threw yellow darts scored higher than the player who threw white darts. So, we need to add a constraint for each possible assignment of scores for yellow and white darts, such that the score for yellow darts is greater than the score for white darts.

-   The player who scored 48 points threw the yellow darts:
    This is a direct assignment constraint:
    YellowDarts == 48.

-   Greg scored 7 points higher than Jeffrey:
    For this, we will need to add a constraint for each possible assignment of scores for Greg and Jeffrey, such that Greg's score is 7 more than Jeffrey's score. So, the constraints will be of the form:
    s1 == Greg and s2 == Jeffrey => s1_to_int == s2_to_int + 7, for all s1, s2 in scores.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Alton == 1, and 41 == 1, and Green == 1, then Alton scored 41 points throwing green darts.

### Decision variables:
-   Players: Alton, Evan, Greg, Jeffrey (all different, 1 to 4)
-   Scores: 41, 48, 55, 62 (all different, 1 to 4)
-   Colors of darts: Green, Red, White, Yellow (all different, 1 to 4)

### Constraints:
-   Greg threw the red darts:
    This is a direct assignment constraint:
    Greg == RedDarts.

-   Alton scored 7 points higher than Evan:
    For this, we will need to add a constraint for each possible assignment of scores for Alton and Evan, such that Alton's score is 7 more than Evan's score. So, the constraints will be of the form:
    s1 == Alton and s2 == Evan => s1_to_int == s2_to_int + 7, for all s1, s2 in scores.

-   The contestant who threw the yellow darts scored somewhat higher than the player who threw the white darts:
    This constraint implies that the player who threw yellow darts scored higher than the player who threw white darts. So, we need to add a constraint for each possible assignment of scores for yellow and white darts, such that the score for yellow darts is greater than the score for white darts.

-   The player who scored 48 points threw the yellow darts:
    This is a direct assignment constraint:
    YellowDarts == 48.

-   Greg scored 7 points higher than Jeffrey:
    For this, we will need to add a constraint for each possible assignment of scores for Greg and Jeffrey, such that Greg's score is 7 more than Jeffrey's score. So, the constraints will be of the form:
    s1 == Greg and s2 == Jeffrey => s1_to_int == s2_to_int + 7, for all s1, s2 in scores.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of player, score, and color)
# e.g. if alton == 1 and fortyone == 1 and green == 1, then Alton scored 41 points throwing green darts
alton, evan, greg, jeffrey = players = intvar(1, 4, shape=4)
fortyone, fortyeight, fiftyfive, sixytwo = scores = intvar(1, 4, shape=4)
green, red, white, yellow = colors = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
player_to_int = None  # N/A
score_to_int = {fortyone: 41, fortyeight: 48, fiftyfive: 55, sixytwo: 62}  # in points
color_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def scored_higher_than(var1, var2, diff):
    """
    Formulate the constraint that var1 scored diff points higher than var2.
    """
    return [((s1 == var1) & (s2 == var2)).implies(score_to_int[s1] == score_to_int[s2] + diff)
            for s1 in scores for s2 in scores]


def scored_higher(var1, var2):
    """
    Formulate the constraint that var1 scored higher than var2.
    """
    return [((s1 == var1) & (s2 == var2)).implies(score_to_int[s1] > score_to_int[s2])
            for s1 in scores for s2 in scores]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(players)
m += AllDifferent(scores)
m += AllDifferent(colors)

# Clue 1: Greg threw the red darts:
m += greg == red

# Clue 2: Alton scored 7 points higher than Evan:
m += scored_higher_than(alton, evan, 7)

# Clue 3: The contestant who threw the yellow darts scored somewhat higher than the player who threw the white darts:
m += scored_higher(yellow, white)

# Clue 4: The player who scored 48 points threw the yellow darts:
m += yellow == fortyeight

# Clue 5: Greg scored 7 points higher than Jeffrey:
m += scored_higher_than(greg, jeffrey, 7

```
Error: invalid syntax (<string>, line 1)
False
False
Error: list.remove(x): x not in list
---------------------------------------------------------------------------------------------

Clues:
Vasquez will leave sometime after Macdonald.
Vasquez will leave 1 month before the ambassador with the 5 day visit.
Gilbert is either the person leaving in January or the ambassador with the 4 day visit.
Macdonald will leave 1 month before the ambassador with the 4 day visit.
The ambassador with the 4 day visit will leave sometime before the ambassador with the 9 day visit.

Entities:
diplomats: Gilbert, Macdonald, Pickett, Vasquez
months: January, February, March, April
durations: 4 day, 5 day, 9 day, 10 day
VAR (8-15): Vasquez
VAR (42-51): Macdonald
VAR (54-61): Vasquez
PARAM (73-74): 1
PARAM (112-113): 5
PARAM (201-202): 4
VAR (215-224): Macdonald
PARAM (236-237): 1
PARAM (275-276): 4
PARAM (313-314): 4
PARAM (376-377): 9
VAR (445-452): Vasquez
PARAM (509-510): 4
PARAM (517-518): 5
PARAM (525-526): 9
PARAM (533-535): 10

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Gilbert == 1, and January == 1, and Day4 == 1, then Gilbert is the diplomat leaving in January with a 4-day visit.

### Decision variables:
-   Names of the diplomats: Gilbert, Macdonald, Pickett, Vasquez (all different, 1 to 4)
-   Months of departure: January, February, March, April (all different, 1 to 4)
-   Visit durations: Day4, Day5, Day9, Day10 (all different, 1 to 4)

### Constraints:
-   Vasquez will leave sometime after Macdonald:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Vasquez and Macdonald, such that Vasquez's month of departure is greater than Macdonald's month of departure. So, the constraints will be of the form:
    m1 == Vasquez and m2 == Macdonald => m1_to_int > m2_to_int, for all m1, m2 in months of departure.

-   Vasquez will leave 1 month before the ambassador with the 5-day visit:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Vasquez and the ambassador with the 5-day visit, such that Vasquez's month of departure is 1 less than the ambassador's month of departure. So, the constraints will be of the form:
    m1 == Vasquez and m2 == Day5 => m1_to_int == m2_to_int - 1, for all m1, m2 in months of departure.

-   Gilbert is either the person leaving in January or the ambassador with the 4-day visit:
    This is a constraint that states that Gilbert's month of departure is either January or the month of departure of the ambassador with the 4-day visit, but not both. So:
    Xor([Gilbert == January, Gilbert == Day4]).

-   Macdonald will leave 1 month before the ambassador with the 4-day visit:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Macdonald and the ambassador with the 4-day visit, such that Macdonald's month of departure is 1 less than the 4-day month of departure. So, the constraints will be of the form:
    m1 == Macdonald and m2 == Day4 => m1_to_int == m2_to_int - 1, for all m1, m2 in months of departure.

-   The ambassador with the 4-day visit will leave sometime before the ambassador with the 9-day visit:
    For this, we will need to add a constraint for each possible assignment of the months of departure for the ambassador with the 4-day visit and the ambassador with the 9-day visit, such that the 4-day month of departure is less than the 9-day month of departure. So, the constraints will be of the form:
    m1 == Day4 and m2 == Day9 => m1_to_int < m2_to_int, for all m1, m2 in months of departure.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Gilbert == 1, and January == 1, and Day4 == 1, then Gilbert is the diplomat leaving in January with a 4-day visit.

### Decision variables:
-   Names of the diplomats: Gilbert, Macdonald, Pickett, Vasquez (all different, 1 to 4)
-   Months of departure: January, February, March, April (all different, 1 to 4)
-   Visit durations: Day4, Day5, Day9, Day10 (all different, 1 to 4)

### Constraints:
-   Vasquez will leave sometime after Macdonald:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Vasquez and Macdonald, such that Vasquez's month of departure is greater than Macdonald's month of departure. So, the constraints will be of the form:
    m1 == Vasquez and m2 == Macdonald => m1_to_int > m2_to_int, for all m1, m2 in months of departure.

-   Vasquez will leave 1 month before the ambassador with the 5-day visit:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Vasquez and the ambassador with the 5-day visit, such that Vasquez's month of departure is 1 less than the ambassador's month of departure. So, the constraints will be of the form:
    m1 == Vasquez and m2 == Day5 => m1_to_int == m2_to_int - 1, for all m1, m2 in months of departure.

-   Gilbert is either the person leaving in January or the ambassador with the 4-day visit:
    This is a constraint that states that Gilbert's month of departure is either January or the month of departure of the ambassador with the 4-day visit, but not both. So:
    Xor([Gilbert == January, Gilbert == Day4]).

-   Macdonald will leave 1 month before the ambassador with the 4-day visit:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Macdonald and the ambassador with the 4-day visit, such that Macdonald's month of departure is 1 less than the 4-day month of departure. So, the constraints will be of the form:
    m1 == Macdonald and m2 == Day4 => m1_to_int == m2_to_int - 1, for all m1, m2 in months of departure.

-   The ambassador with the 4-day visit will leave sometime before the ambassador with the 9-day visit:
    For this, we will need to add a constraint for each possible assignment of the months of departure for the ambassador with the 4-day visit and the ambassador with the 9-day visit, such that the 4-day month of departure is less than the 9-day month of departure. So, the constraints will be of the form:
    m1 == Day4 and m2 == Day9 => m1_to_int < m2_to_int, for all m1, m2 in months of departure.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of diplomat, month, and duration)
# e.g. if gilbert == 1 and january == 1 and days4 == 1, then Gilbert will leave in January and for 4 days
gilbert, macdonald, pickett, vasquez = diplomats = intvar(1, 4, shape=4)
january, february, march, april = months = intvar(1, 4, shape=4)
days4, days5, days9, days10 = durations = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
diplomat_to_int = None  # N/A
month_to_int = {january: 1, february: 2, march: 3, april: 4}  # in months
duration_to_int = {days4: 4, days5: 5, days9: 9, days10: 10}  # in days


# Helper functions (for formulating comparison constraints)
def left_after_than(var1, var2):
    """
    Formulate the constraint that var1 left after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] > month_to_int[m2])
            for m1 in months for m2 in months]


def left_exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 left exactly diff months after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] == month_to_int[m2] + diff)
            for m1 in months for m2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(diplomats)
m += AllDifferent(months)
m += AllDifferent(durations)

# Clue 1: Vasquez will leave sometime after Macdonald:
m += left_after_than(vasquez, macdonald)

# Clue 2: Vasquez will leave 1 month before the ambassador with the 5-day visit:
m += left_exactly_after_than(vasquez, days5, -1)

# Clue 3: Gilbert is either the person leaving in January or the ambassador with the 4-day visit:
m += Xor([gilbert == january, gilbert == days4])

# Clue 4: Macdonald will leave 1 month before the ambassador with the 4-day visit:
m += left_exactly_after_than(macdonald, days4, -1)

# Clue 5: The ambassador with the 4-day visit will leave sometime before the ambassador with the 9-day visit:
m += left_after_than(days4, days9)

```
True
False
False
Wrong: 1, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Hattie and the student who will major in Theology are different students.
The student who will major in English is either Tracy or the student who received the $25,000 scholarship.
Hattie was awarded $10,000 more than the person who will major in Physics.
The student who received the $40,000 scholarship will major in Theology.
Ora was awarded some amount less than the student who will major in Archaeology.

Entities:
names: Erma, Hattie, Ora, Tracy
scholarships: $25,000, $30,000, $35,000, $40,000
majors: Archaeology, English, Physics, Theology
VAR (8-14): Hattie
VAR (113-120): English
PARAM (171-177): 25,000
VAR (192-198): Hattie
PARAM (213-219): 10,000
CONST_DIR (220-224): more
VAR (259-266): Physics
PARAM (300-306): 40,000
VAR (333-341): Theology
VAR (344-347): Ora
VAR (412-423): Archaeology
PARAM (490-496): 25,000
PARAM (501-507): 30,000
PARAM (512-518): 35,000
PARAM (523-529): 40,000
VAR (539-550): Archaeology
VAR (553-560): English
VAR (563-570): Physics

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Erma == 1, and $25,000 == 1, and Archaeology == 1, then Erma received the $25,000 scholarship and will major in Archaeology.

### Decision variables:
-   Names of the students: Erma, Hattie, Ora, Tracy (all different, 1 to 4)
-   Scholarship amounts: $25,000, $30,000, $35,000, $40,000 (all different, 1 to 4)
-   Majors: Archaeology, English, Physics, Theology (all different, 1 to 4)

### Constraints:
-   Hattie and the student who will major in Theology are different students:
    This is a constraint that states that Hattie and the student majoring in Theology are different, thus:
    AllDifferent([Hattie, Theology]).

-   The student who will major in English is either Tracy or the student who received the $25,000 scholarship:
    This is a constraint that states that the student majoring in English is either Tracy or the student who received the $25,000 scholarship, but not both. So:
    Xor([English == Tracy, English == $25,000]).

-   Hattie was awarded $10,000 more than the person who will major in Physics:
    For this, we will need to add a constraint for each possible assignment of scholarship amounts to Hattie and the student majoring in Physics, such that Hattie's scholarship amount is $10,000 more than the student majoring in Physics. So, the constraints will be of the form:
    s1 == Hattie and s2 == Physics => s1_to_int == s2_to_int + 10, for all s1, s2 in scholarship amounts.

-   The student who received the $40,000 scholarship will major in Theology:
    This is a direct assignment constraint:
    $40,000 == Theology.

-   Ora was awarded some amount less than the student who will major in Archaeology:
    For this, we will need to add a constraint for each possible assignment of scholarship amounts to Ora and the student majoring in Archaeology, such that Ora's scholarship amount is less than the student majoring in Archaeology. So, the constraints will be of the form:
    s1 == Ora and s2 == Archaeology => s1_to_int < s2_to_int, for all s1, s2 in scholarship amounts.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Erma == 1, and $25,000 == 1, and Archaeology == 1, then Erma received the $25,000 scholarship and will major in Archaeology.

### Decision variables:
-   Names of the students: Erma, Hattie, Ora, Tracy (all different, 1 to 4)
-   Scholarship amounts: $25,000, $30,000, $35,000, $40,000 (all different, 1 to 4)
-   Majors: Archaeology, English, Physics, Theology (all different, 1 to 4)

### Constraints:
-   Hattie and the student who will major in Theology are different students:
    This is a constraint that states that Hattie and the student majoring in Theology are different, thus:
    AllDifferent([Hattie, Theology]).

-   The student who will major in English is either Tracy or the student who received the $25,000 scholarship:
    This is a constraint that states that the student majoring in English is either Tracy or the student who received the $25,000 scholarship, but not both. So:
    Xor([English == Tracy, English == $25,000]).

-   Hattie was awarded $10,000 more than the person who will major in Physics:
    For this, we will need to add a constraint for each possible assignment of scholarship amounts to Hattie and the student majoring in Physics, such that Hattie's scholarship amount is $10,000 more than the student majoring in Physics. So, the constraints will be of the form:
    s1 == Hattie and s2 == Physics => s1_to_int == s2_to_int + 10, for all s1, s2 in scholarship amounts.

-   The student who received the $40,000 scholarship will major in Theology:
    This is a direct assignment constraint:
    $40,000 == Theology.

-   Ora was awarded some amount less than the student who will major in Archaeology:
    For this, we will need to add a constraint for each possible assignment of scholarship amounts to Ora and the student majoring in Archaeology, such that Ora's scholarship amount is less than the student majoring in Archaeology. So, the constraints will be of the form:
    s1 == Ora and s2 == Archaeology => s1_to_int < s2_to_int, for all s1, s2 in scholarship amounts.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of student, scholarship, and major)
# e.g. if erma == 1 and $25k == 1 and archaeology == 1, then Erma received the $25,000 scholarship and will major in Archaeology
erma, hattie, ora, tracy = students = intvar(1, 4, shape=4)
$25k, $30k, $35k, $40k = scholarships = intvar(1, 4, shape=4)
archaeology, english, physics, theology = majors = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
student_to_int = None  # N/A
scholarship_to_int = {25_000: 1, 30_000: 2, 35_000: 3, 40_000: 4}  # in dollars
major_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def awarded_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 was awarded diff more than var2.
    """
    return [((s1 == var1) & (s2 == var2)).implies(s1 == s2 + diff)
            for s1 in scholarships for s2 in scholarships]


def awarded_less_than(var1, var2):
    """
    Formulate the constraint that var1 was awarded less than var2.
    """
    return [((s1 == var1) & (s2 == var2)).implies(s1 < s2)
            for s1 in scholarships for s2 in scholarships]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(students)
m += AllDifferent(scholarships)
m += AllDifferent(majors)

# Clue 1: Hattie and the student who will major in Theology are different students:
m += AllDifferent([hattie, theology])

# Clue 2: The student who will major in English is either Tracy or the student who received the $25,000 scholarship:
m += Xor([english == tracy, english == $25k])

# Clue 3: Hattie was awarded $10,000 more than the person who will major in Physics:
m += awarded_more_than(hattie, physics, 10_000)

# Clue 4: The student who received the $40,000 scholarship will major in Theology:
m += $40k == theology

# Clue 5: Ora was awarded some amount less than the student who will major in Archaeology:
m += awarded_less_than(ora, archaeology)

```
Error: invalid syntax (<string>, line 1)
False
Error: list.remove(x): x not in list
Error: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
Hatcha started 6 years after the wing back.
Kawa began playing in 1982.
Banben was the center back.
The person who started in 1985 was either Kawa or the center forward.

Entities:
players: Banben, Hatcha, Kawa, Rothvum
years: 1976, 1979, 1982, 1985
positions: center back, center forward, goalie, wing back
PARAM (23-24): 6
PARAM (75-79): 1982
PARAM (244-248): 1976
PARAM (251-255): 1979
PARAM (258-262): 1982
PARAM (265-269): 1985

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Banben == 1, and 1976 == 1, and CenterBack == 1, then Banben started playing in 1976 as the center back.

### Decision variables:
-   Names of the players: Banben, Hatcha, Kawa, Rothvum (all different, 1 to 4)
-   Years when they started playing: 1976, 1979, 1982, 1985 (all different, 1 to 4)
-   Positions they play: CenterBack, CenterForward, Goalie, WingBack (all different, 1 to 4)

### Constraints:
-   Hatcha started 6 years after the wing back:
    For this, we will need to add a constraint for each possible assignment of the years when Hatcha and the wing back started playing, such that Hatcha's starting year is 6 more than the wing back's starting year. So, the constraints will be of the form:
    y1 == Hatcha and y2 == WingBack => y1_to_int == y2_to_int + 6, for all y1, y2 in years.

-   Kawa began playing in 1982:
    This is a direct assignment constraint:
    Kawa == 1982.

-   Banben was the center back:
    This is a direct assignment constraint:
    Banben == CenterBack.

-   The person who started in 1985 was either Kawa or the center forward:
    This is a constraint that states that the player who started in 1985 is either Kawa or the center forward, but not both. So:
    Xor([1985 == Kawa, 1985 == CenterForward]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Banben == 1, and 1976 == 1, and CenterBack == 1, then Banben started playing in 1976 as the center back.

### Decision variables:
-   Names of the players: Banben, Hatcha, Kawa, Rothvum (all different, 1 to 4)
-   Years when they started playing: 1976, 1979, 1982, 1985 (all different, 1 to 4)
-   Positions they play: CenterBack, CenterForward, Goalie, WingBack (all different, 1 to 4)

### Constraints:
-   Hatcha started 6 years after the wing back:
    For this, we will need to add a constraint for each possible assignment of the years when Hatcha and the wing back started playing, such that Hatcha's starting year is 6 more than the wing back's starting year. So, the constraints will be of the form:
    y1 == Hatcha and y2 == WingBack => y1_to_int == y2_to_int + 6, for all y1, y2 in years.

-   Kawa began playing in 1982:
    This is a direct assignment constraint:
    Kawa == 1982.

-   Banben was the center back:
    This is a direct assignment constraint:
    Banben == CenterBack.

-   The person who started in 1985 was either Kawa or the center forward:
    This is a constraint that states that the player who started in 1985 is either Kawa or the center forward, but not both. So:
    Xor([1985 == Kawa, 1985 == CenterForward]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of player, year, and position)
# e.g. if banben == 1 and year1976 == 1 and centerback == 1, then Banben started playing in 1976 as the center back
banben, hatcha, kawa, rothvum = players = intvar(1, 4, shape=4)
year1976, year1979, year1982, year1985 = years = intvar(1, 4, shape=4)
centerback, centerforward, goalie, wingback = positions = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
player_to_int = None  # N/A
year_to_int = {year1976: 1976, year1979: 1979, year1982: 1982, year1985: 1985}  # in years
position_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def started_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 started playing diff years after var2.
    """
    return [((y1 == var1) & (y2 == var2)).implies(year_to_int[y1] == year_to_int[y2] + diff)
            for y1 in years for y2 in years]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(players)
m += AllDifferent(years)
m += AllDifferent(positions)

# Clue 1: Hatcha started 6 years after the wing back:
m += started_after_than(hatcha, wingback, 6)

# Clue 2: Kawa began playing in 1982:
m += kawa == year1982

# Clue 3: Banben was the center back:
m += banben == centerback

# Clue 4: The person who started in 1985 was either Kawa or the center forward:
m += Xor([year1985 == kawa, year1985 == centerforward])

```
True
True
True
Wrong: 0, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The puzzle with the postage stamp theme has somewhat fewer than the puzzle made by Astury.
The jigsaw puzzle with the outer space theme has 250 more pieces than the puzzle made by Garroda.
The jigsaw puzzle made by Garroda has somewhat fewer than the puzzle made by Vesem.
The jigsaw puzzle with the postage stamp theme has somewhat more than the puzzle with the city skyline theme.
The jigsaw puzzle made by Vesem has 500 pieces.

Entities:
companies: Astury, Denlend, Garroda, Vesem
pieces: 250, 500, 750, 1000
themes: autumn leaves, city skyline, outer space, postage stamp
VAR (28-47): postage stamp theme
VAR (111-117): puzzle
VAR (127-144): outer space theme
PARAM (149-152): 250
VAR (189-196): Garroda
VAR (210-216): puzzle
VAR (225-232): Garroda
VAR (276-281): Vesem
VAR (295-301): puzzle
VAR (311-330): postage stamp theme
VAR (374-392): city skyline theme
VAR (406-412): puzzle
PARAM (431-434): 500
PARAM (511-514): 250
PARAM (517-520): 500
PARAM (523-526): 750
PARAM (529-533): 1000
VAR (559-571): city skyline

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Astury == 1, and 250 == 1, and AutumnLeaves == 1, then Astury made a puzzle with 250 pieces and the Autumn Leaves theme.

### Decision variables:
-   Companies: Astury, Denlend, Garroda, Vesem (all different, 1 to 4)
-   Number of pieces: 250, 500, 750, 1000 (all different, 1 to 4)
-   Themes: AutumnLeaves, CitySkyline, OuterSpace, PostageStamp (all different, 1 to 4)

### Constraints:
-   The puzzle with the postage stamp theme has somewhat fewer pieces than the puzzle made by Astury:
    For this, we will need to add a constraint for each possible assignment of the number of pieces for the postage stamp theme puzzle and Astury's puzzle, such that the postage stamp theme puzzle has fewer pieces than Astury's puzzle. So, the constraints will be of the form:
    t1 == PostageStamp and t2 == Astury => t1_to_int < t2_to_int, for all t1, t2 in pieces.

-   The jigsaw puzzle with the outer space theme has 250 more pieces than the puzzle made by Garroda:
    For this, we will need to add a constraint for each possible assignment of the number of pieces for the outer space theme puzzle and Garroda's puzzle, such that the outer space theme puzzle has 250 more pieces than Garroda's puzzle. So, the constraints will be of the form:
    t1 == OuterSpace and t2 == Garroda => t1_to_int == t2_to_int + 250, for all t1, t2 in pieces.

-   The jigsaw puzzle made by Garroda has somewhat fewer pieces than the puzzle made by Vesem:
    For this, we will need to add a constraint for each possible assignment of the number of pieces for Garroda's puzzle and Vesem's puzzle, such that Garroda's puzzle has fewer pieces than Vesem's puzzle. So, the constraints will be of the form:
    t1 == Garroda and t2 == Vesem => t1_to_int < t2_to_int, for all t1, t2 in pieces.

-   The jigsaw puzzle with the postage stamp theme has somewhat more pieces than the puzzle with the city skyline theme:
    For this, we will need to add a constraint for each possible assignment of the number of pieces for the postage stamp theme puzzle and the city skyline theme puzzle, such that the postage stamp theme puzzle has more pieces than the city skyline theme puzzle. So, the constraints will be of the form:
    t1 == PostageStamp and t2 == CitySkyline => t1_to_int > t2_to_int, for all t1, t2 in pieces.

-   The jigsaw puzzle made by Vesem has 500 pieces:
    This is a direct assignment constraint:
    Vesem == 500.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Astury == 1, and 250 == 1, and AutumnLeaves == 1, then Astury made a puzzle with 250 pieces and the Autumn Leaves theme.

### Decision variables:
-   Companies: Astury, Denlend, Garroda, Vesem (all different, 1 to 4)
-   Number of pieces: 250, 500, 750, 1000 (all different, 1 to 4)
-   Themes: AutumnLeaves, CitySkyline, OuterSpace, PostageStamp (all different, 1 to 4)

### Constraints:
-   The puzzle with the postage stamp theme has somewhat fewer pieces than the puzzle made by Astury:
    For this, we will need to add a constraint for each possible assignment of the number of pieces for the postage stamp theme puzzle and Astury's puzzle, such that the postage stamp theme puzzle has fewer pieces than Astury's puzzle. So, the constraints will be of the form:
    t1 == PostageStamp and t2 == Astury => t1_to_int < t2_to_int, for all t1, t2 in pieces.

-   The jigsaw puzzle with the outer space theme has 250 more pieces than the puzzle made by Garroda:
    For this, we will need to add a constraint for each possible assignment of the number of pieces for the outer space theme puzzle and Garroda's puzzle, such that the outer space theme puzzle has 250 more pieces than Garroda's puzzle. So, the constraints will be of the form:
    t1 == OuterSpace and t2 == Garroda => t1_to_int == t2_to_int + 250, for all t1, t2 in pieces.

-   The jigsaw puzzle made by Garroda has somewhat fewer pieces than the puzzle made by Vesem:
    For this, we will need to add a constraint for each possible assignment of the number of pieces for Garroda's puzzle and Vesem's puzzle, such that Garroda's puzzle has fewer pieces than Vesem's puzzle. So, the constraints will be of the form:
    t1 == Garroda and t2 == Vesem => t1_to_int < t2_to_int, for all t1, t2 in pieces.

-   The jigsaw puzzle with the postage stamp theme has somewhat more pieces than the puzzle with the city skyline theme:
    For this, we will need to add a constraint for each possible assignment of the number of pieces for the postage stamp theme puzzle and the city skyline theme puzzle, such that the postage stamp theme puzzle has more pieces than the city skyline theme puzzle. So, the constraints will be of the form:
    t1 == PostageStamp and t2 == CitySkyline => t1_to_int > t2_to_int, for all t1, t2 in pieces.

-   The jigsaw puzzle made by Vesem has 500 pieces:
    This is a direct assignment constraint:
    Vesem == 500.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of company, pieces, and theme)
# e.g. if astury == 1 and pieces250 == 1 and autumn_leaves == 1, then Astury made a puzzle with 250 pieces and the Autumn Leaves theme
astury, denlend, garroda, vesem = companies = intvar(1, 4, shape=4)
pieces250, pieces500, pieces750, pieces1000 = pieces = intvar(1, 4, shape=4)
autumn_leaves, city_skyline, outer_space, postage_stamp = themes = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
company_to_int = None  # N/A
pieces_to_int = {pieces250: 250, pieces500: 500, pieces750: 750, pieces1000: 1000}  # in pieces
theme_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def somewhat_fewer_than(var1, var2):
    """
    Formulate the constraint that var1 has somewhat fewer pieces than var2.
    """
    return [((t1 == var1) & (t2 == var2)).implies(pieces_to_int[t1] < pieces_to_int[t2])
            for t1 in pieces for t2 in pieces]


def somewhat_more_than(var1, var2):
    """
    Formulate the constraint that var1 has somewhat more pieces than var2.
    """
    return [((t1 == var1) & (t2 == var2)).implies(pieces_to_int[t1] > pieces_to_int[t2])
            for t1 in pieces for t2 in pieces]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(companies)
m += AllDifferent(pieces)
m += AllDifferent(themes)

# Clue 1: The puzzle with the postage stamp theme has somewhat fewer pieces than the puzzle made by Astury:
m += somewhat_fewer_than(postage_stamp, astury)

# Clue 2: The jigsaw puzzle with the outer space theme has 250 more pieces than the puzzle made by Garroda:
m += [(outer_space == garroda).implies(pieces_to_int[outer_space] == pieces_to_int[garroda] + 250)]

# Clue 3: The jigsaw puzzle made by Garroda has somewhat fewer pieces than the puzzle made by Vesem:
m += somewhat_fewer_than(garroda, vesem)

# Clue 4: The jigsaw puzzle with the postage stamp theme has somewhat more pieces than the puzzle with the city skyline theme:
m += somewhat_more_than(postage_stamp, city_skyline)

# Clue 5: The jigsaw puzzle made by Vesem has 500 pieces:
m += vesem == pieces500

```
Error: name 'IV4970' is not defined
False
False
Error: name 'IV4994' is not defined
---------------------------------------------------------------------------------------------

Clues:
The photo published by Nature Monthly was taken 2 months after the photo published by Earth Aware.
The shot of the white rhino was either the photo published by Earth Aware or the photo published by Animal Science.
The photo of the polar bear was taken sometime before the shot of the white rhino.
The photo taken in April was published by Animal Science.
The photo of the giant tortoise was taken in June.

Entities:
animals: giant tortoise, orangutan, polar bear, white rhino
months: March, April, May, June
magazines: Animal Science, Earth Aware, Nature Monthly, Wildzone
PARAM (56-57): 2
VAR (124-135): white rhino
VAR (242-252): polar bear
VAR (295-306): white rhino
VAR (385-399): giant tortoise
VAR (441-455): giant tortoise
VAR (470-480): polar bear
VAR (483-494): white rhino

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if GiantTortoise == 1, and June == 1, and AnimalScience == 1, then the photo of the giant tortoise was taken in June and published by Animal Science.

### Decision variables:
-   Animals in the photos: GiantTortoise, Orangutan, PolarBear, WhiteRhino (all different, 1 to 4)
-   Months when the photos were taken: March, April, May, June (all different, 1 to 4)
-   Magazines where the photos were published: AnimalScience, EarthAware, NatureMonthly, Wildzone (all different, 1 to 4)

### Constraints:
-   The photo published by Nature Monthly was taken 2 months after the photo published by Earth Aware:
    For this, we will need to add a constraint for each possible assignment of the magazines for Nature Monthly and Earth Aware, such that the month of the photo published by Nature Monthly is 2 greater than the month of the photo published by Earth Aware. So, the constraints will be of the form:
    m1 == NatureMonthly and m2 == EarthAware => m1_to_int == m2_to_int + 2, for all m1, m2 in months.

-   The shot of the white rhino was either the photo published by Earth Aware or the photo published by Animal Science:
    This is a constraint that states that the photo of the white rhino is either published by Earth Aware or Animal Science, but not both. So:
    Xor([WhiteRhino == EarthAware, WhiteRhino == AnimalScience]).

-   The photo of the polar bear was taken sometime before the shot of the white rhino:
    For this, we will need to add a constraint for each possible assignment of the animals for the polar bear and the white rhino, such that the month of the photo of the polar bear is less than the month of the photo of the white rhino. So, the constraints will be of the form:
    m1 == PolarBear and m2 == WhiteRhino => m1_to_int < m2_to_int, for all m1, m2 in months.

-   The photo taken in April was published by Animal Science:
    This is a direct assignment constraint:
    April == AnimalScience.

-   The photo of the giant tortoise was taken in June:
    This is a direct assignment constraint:
    GiantTortoise == June.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if GiantTortoise == 1, and June == 1, and AnimalScience == 1, then the photo of the giant tortoise was taken in June and published by Animal Science.

### Decision variables:
-   Animals in the photos: GiantTortoise, Orangutan, PolarBear, WhiteRhino (all different, 1 to 4)
-   Months when the photos were taken: March, April, May, June (all different, 1 to 4)
-   Magazines where the photos were published: AnimalScience, EarthAware, NatureMonthly, Wildzone (all different, 1 to 4)

### Constraints:
-   The photo published by Nature Monthly was taken 2 months after the photo published by Earth Aware:
    For this, we will need to add a constraint for each possible assignment of the magazines for Nature Monthly and Earth Aware, such that the month of the photo published by Nature Monthly is 2 greater than the month of the photo published by Earth Aware. So, the constraints will be of the form:
    m1 == NatureMonthly and m2 == EarthAware => m1_to_int == m2_to_int + 2, for all m1, m2 in months.

-   The shot of the white rhino was either the photo published by Earth Aware or the photo published by Animal Science:
    This is a constraint that states that the photo of the white rhino is either published by Earth Aware or Animal Science, but not both. So:
    Xor([WhiteRhino == EarthAware, WhiteRhino == AnimalScience]).

-   The photo of the polar bear was taken sometime before the shot of the white rhino:
    For this, we will need to add a constraint for each possible assignment of the animals for the polar bear and the white rhino, such that the month of the photo of the polar bear is less than the month of the photo of the white rhino. So, the constraints will be of the form:
    m1 == PolarBear and m2 == WhiteRhino => m1_to_int < m2_to_int, for all m1, m2 in months.

-   The photo taken in April was published by Animal Science:
    This is a direct assignment constraint:
    April == AnimalScience.

-   The photo of the giant tortoise was taken in June:
    This is a direct assignment constraint:
    GiantTortoise == June.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of animal, month, and magazine)
# e.g. if giant_tortoise == 1 and june == 1 and animal_science == 1, then the photo of the giant tortoise was taken in June and published by Animal Science
giant_tortoise, orangutan, polar_bear, white_rhino = animals = intvar(1, 4, shape=4)
march, april, may, june = months = intvar(1, 4, shape=4)
animal_science, earth_aware, nature_monthly, wildzone = magazines = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
animal_to_int = None  # N/A
month_to_int = {march: 1, april: 2, may: 3, june: 4}  # in months
magazine_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def taken_after_than(var1, var2):
    """
    Formulate the constraint that var1 taken after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] > month_to_int[m2])
            for m1 in months for m2 in months]


def taken_exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 taken exactly diff months after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] == month_to_int[m2] + diff)
            for m1 in months for m2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(animals)
m += AllDifferent(months)
m += AllDifferent(magazines)

# Clue 1: The photo published by Nature Monthly was taken 2 months after the photo published by Earth Aware:
m += taken_exactly_after_than(nature_monthly, earth_aware, 2)

# Clue 2: The shot of the white rhino was either the photo published by Earth Aware or the photo published by Animal Science:
m += Xor([white_rhino == earth_aware, white_rhino == animal_science])

# Clue 3: The photo of the polar bear was taken sometime before the shot of the white rhino:
m += taken_after_than(polar_bear, white_rhino)

# Clue 4: The photo taken in April was published by Animal Science:
m += april == animal_science

# Clue 5: The photo of the giant tortoise was taken in June:
m += giant_tortoise == june

```
False
False
False
Wrong: 1, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Oginao is either the 105 ft tall fall or the 115 ft tall waterfall.
Oginao is 5 ft shorter than Irskela.
The fall in Brazil is either Cerbel or Inawatai.
Inawatai is in New Zealand.
Cerbel is 10 ft shorter than the fall in Canada.

Entities:
names: Cerbel, Irskela, Inawatai, Oginao
heights: 100 ft, 105 ft, 110 ft, 115 ft
countries: Canada, Brazil, New Zealand, Switzerland
VAR (8-14): Oginao
PARAM (29-32): 105
PARAM (53-56): 115
VAR (77-83): Oginao
PARAM (87-88): 5
VAR (127-133): Brazil
VAR (144-150): Cerbel
VAR (154-162): Inawatai
VAR (165-173): Inawatai
VAR (194-200): Cerbel
PARAM (204-206): 10
VAR (235-241): Canada
VAR (263-269): Cerbel
VAR (282-290): Inawatai
VAR (293-299): Oginao
PARAM (310-313): 100
PARAM (319-322): 105
PARAM (328-331): 110
PARAM (337-340): 115
VAR (356-362): Canada
VAR (365-371): Brazil

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Cerbel == 1, and Canada == 1, and Height100 == 1, then Cerbel is the waterfall in Canada with a height of 100 ft.

### Decision variables:
-   Names of the waterfalls: Cerbel, Irskela, Inawatai, Oginao (all different, 1 to 4)
-   Heights of the waterfalls: 100 ft, 105 ft, 110 ft, 115 ft (all different, 1 to 4)
-   Countries where the waterfalls are located: Canada, Brazil, New Zealand, Switzerland (all different, 1 to 4)

### Constraints:
-   Oginao is either the 105 ft tall fall or the 115 ft tall waterfall:
    This is a constraint that states that Oginao's height is either 105 ft or 115 ft, but not both. So:
    Xor([Oginao == Height105, Oginao == Height115]).

-   Oginao is 5 ft shorter than Irskela:
    For this, we will need to add a constraint for each possible assignment of heights for Oginao and Irskela, such that Oginao's height is 5 less than Irskela's height. So, the constraints will be of the form:
    h1 == Oginao and h2 == Irskela => h1_to_int == h2_to_int - 5, for all h1, h2 in heights.

-   The fall in Brazil is either Cerbel or Inawatai:
    This is a constraint that states that the fall in Brazil is either Cerbel or Inawatai, but not both. So:
    Xor([Brazil == Cerbel, Brazil == Inawatai]).

-   Inawatai is in New Zealand:
    This is a direct assignment constraint:
    Inawatai == NewZealand.

-   Cerbel is 10 ft shorter than the fall in Canada:
    For this, we will need to add a constraint for each possible assignment of heights for Cerbel and the fall in Canada, such that Cerbel's height is 10 less than the fall in Canada's height. So, the constraints will be of the form:
    h1 == Cerbel and h2 == Canada => h1_to_int == h2_to_int - 10, for all h1, h2 in heights.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Cerbel == 1, and Canada == 1, and Height100 == 1, then Cerbel is the waterfall in Canada with a height of 100 ft.

### Decision variables:
-   Names of the waterfalls: Cerbel, Irskela, Inawatai, Oginao (all different, 1 to 4)
-   Heights of the waterfalls: 100 ft, 105 ft, 110 ft, 115 ft (all different, 1 to 4)
-   Countries where the waterfalls are located: Canada, Brazil, New Zealand, Switzerland (all different, 1 to 4)

### Constraints:
-   Oginao is either the 105 ft tall fall or the 115 ft tall waterfall:
    This is a constraint that states that Oginao's height is either 105 ft or 115 ft, but not both. So:
    Xor([Oginao == Height105, Oginao == Height115]).

-   Oginao is 5 ft shorter than Irskela:
    For this, we will need to add a constraint for each possible assignment of heights for Oginao and Irskela, such that Oginao's height is 5 less than Irskela's height. So, the constraints will be of the form:
    h1 == Oginao and h2 == Irskela => h1_to_int == h2_to_int - 5, for all h1, h2 in heights.

-   The fall in Brazil is either Cerbel or Inawatai:
    This is a constraint that states that the fall in Brazil is either Cerbel or Inawatai, but not both. So:
    Xor([Brazil == Cerbel, Brazil == Inawatai]).

-   Inawatai is in New Zealand:
    This is a direct assignment constraint:
    Inawatai == NewZealand.

-   Cerbel is 10 ft shorter than the fall in Canada:
    For this, we will need to add a constraint for each possible assignment of heights for Cerbel and the fall in Canada, such that Cerbel's height is 10 less than the fall in Canada's height. So, the constraints will be of the form:
    h1 == Cerbel and h2 == Canada => h1_to_int == h2_to_int - 10, for all h1, h2 in heights.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of name, height, and country)
# e.g. if cerbel == 1 and height100 == 1 and canada == 1, then Cerbel is the waterfall in Canada with a height of 100 ft
cerbel, irskela, inawatai, oginao = names = intvar(1, 4, shape=4)
height100, height105, height110, height115 = heights = intvar(1, 4, shape=4)
canada, brazil, new_zealand, switzerland = countries = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
name_to_int = None  # N/A
height_to_int = {height100: 100, height105: 105, height110: 110, height115: 115}  # in feet
country_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def shorter_than(var1, var2, diff):
    """
    Formulate the constraint that var1 is diff feet shorter than var2.
    """
    return [((h1 == var1) & (h2 == var2)).implies(height_to_int[h1] == height_to_int[h2] - diff)
            for h1 in heights for h2 in heights]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(names)
m += AllDifferent(heights)
m += AllDifferent(countries)

# Clue 1: Oginao is either the 105 ft tall fall or the 115 ft tall waterfall:
m += Xor([oginao == height105, oginao == height115])

# Clue 2: Oginao is 5 ft shorter than Irskela:
m += shorter_than(oginao, irskela, 5)

# Clue 3: The fall in Brazil is either Cerbel or Inawatai:
m += Xor([brazil == cerbel, brazil == inawatai])

# Clue 4: Inawatai is in New Zealand:
m += inawatai == new_zealand

# Clue 5: Cerbel is 10 ft shorter than the fall in Canada:
m += shorter_than(cerbel, canada, 10)

```
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The 90 million year old fossil costs 250 dollars more than the pilodontus.
The gigasaurus costs 500 dollars more than the 78 million year old fossil.
The gigasaurus costs 250 dollars less than the 75 million year old fossil.
The mirasaurus is 90 million years old.

Entities:
dinosaurs: gigasaurus, mirasaurus, pilodontus, rotosaurus
prices: $500, $750, $1000, $1250
ages: 72 million, 75 million, 78 million, 90 million
PARAM (12-14): 90
PARAM (45-48): 250
VAR (88-98): gigasaurus
PARAM (105-108): 500
PARAM (131-133): 78
VAR (164-174): gigasaurus
PARAM (181-184): 250
PARAM (207-209): 75
VAR (240-250): mirasaurus
PARAM (254-256): 90
VAR (300-310): gigasaurus
VAR (313-323): mirasaurus
PARAM (361-364): 500
PARAM (369-372): 750
PARAM (377-381): 1000
PARAM (386-390): 1250
OBJ_NAME (391-395): ages
PARAM (398-400): 72
PARAM (411-413): 75
PARAM (424-426): 78
PARAM (437-439): 90

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if gigasaurus == 1, and $500 == 1, and 72 million == 1, then the gigasaurus costs $500 and is 72 million years old.

### Decision variables:
-   Names of the dinosaurs: gigasaurus, mirasaurus, pilodontus, rotosaurus (all different, 1 to 4)
-   Prices of the fossils: $500, $750, $1000, $1250 (all different, 1 to 4)
-   Ages of the fossils: 72 million, 75 million, 78 million, 90 million (all different, 1 to 4)

### Constraints:
-   The 90 million year old fossil costs $250 more than the pilodontus:
    For this, we will need to add a constraint for each possible assignment of prices for the 90 million year old fossil and the pilodontus, such that the price of the 90 million year old fossil is $250 more than the pilodontus. So, the constraints will be of the form:
    d1 == 90 million and d2 == pilodontus => d1_to_int == d2_to_int + 250, for all d1, d2 in prices.

-   The gigasaurus costs $500 more than the 78 million year old fossil:
    For this, we will need to add a constraint for each possible assignment of prices for the gigasaurus and the 78 million year old fossil, such that the price of the gigasaurus is $500 more than the 78 million year old fossil. So, the constraints will be of the form:
    d1 == gigasaurus and d2 == 78 million => d1_to_int == d2_to_int + 500, for all d1, d2 in prices.

-   The gigasaurus costs $250 less than the 75 million year old fossil:
    For this, we will need to add a constraint for each possible assignment of prices for the gigasaurus and the 75 million year old fossil, such that the price of the gigasaurus is $250 less than the 75 million year old fossil. So, the constraints will be of the form:
    d1 == gigasaurus and d2 == 75 million => d1_to_int == d2_to_int - 250, for all d1, d2 in prices.

-   The mirasaurus is 90 million years old:
    This is a direct assignment constraint:
    mirasaurus == 90 million.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if gigasaurus == 1, and $500 == 1, and 72 million == 1, then the gigasaurus costs $500 and is 72 million years old.

### Decision variables:
-   Names of the dinosaurs: gigasaurus, mirasaurus, pilodontus, rotosaurus (all different, 1 to 4)
-   Prices of the fossils: $500, $750, $1000, $1250 (all different, 1 to 4)
-   Ages of the fossils: 72 million, 75 million, 78 million, 90 million (all different, 1 to 4)

### Constraints:
-   The 90 million year old fossil costs $250 more than the pilodontus:
    For this, we will need to add a constraint for each possible assignment of prices for the 90 million year old fossil and the pilodontus, such that the price of the 90 million year old fossil is $250 more than the pilodontus. So, the constraints will be of the form:
    d1 == 90 million and d2 == pilodontus => d1_to_int == d2_to_int + 250, for all d1, d2 in prices.

-   The gigasaurus costs $500 more than the 78 million year old fossil:
    For this, we will need to add a constraint for each possible assignment of prices for the gigasaurus and the 78 million year old fossil, such that the price of the gigasaurus is $500 more than the 78 million year old fossil. So, the constraints will be of the form:
    d1 == gigasaurus and d2 == 78 million => d1_to_int == d2_to_int + 500, for all d1, d2 in prices.

-   The gigasaurus costs $250 less than the 75 million year old fossil:
    For this, we will need to add a constraint for each possible assignment of prices for the gigasaurus and the 75 million year old fossil, such that the price of the gigasaurus is $250 less than the 75 million year old fossil. So, the constraints will be of the form:
    d1 == gigasaurus and d2 == 75 million => d1_to_int == d2_to_int - 250, for all d1, d2 in prices.

-   The mirasaurus is 90 million years old:
    This is a direct assignment constraint:
    mirasaurus == 90 million.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of dinosaur, price, and age)
# e.g. if gigasaurus == 1 and price500 == 1 and age72 == 1, then the gigasaurus costs $500 and is 72 million years old
gigasaurus, mirasaurus, pilodontus, rotosaurus = dinosaurs = intvar(1, 4, shape=4)
price500, price750, price1000, price1250 = prices = intvar(1, 4, shape=4)
age72, age75, age78, age90 = ages = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
dinosaur_to_int = None  # N/A
price_to_int = {price500: 500, price750: 750, price1000: 1000, price1250: 1250}  # in dollars
age_to_int = {age72: 72, age75: 75, age78: 78, age90: 90}  # in million years


# Helper functions (for formulating comparison constraints)
def costs_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 costs more than var2 by diff dollars.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] + diff)
            for p1 in prices for p2 in prices]


def costs_less_than(var1, var2, diff):
    """
    Formulate the constraint that var1 costs less than var2 by diff dollars.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] - diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(dinosaurs)
m += AllDifferent(prices)
m += AllDifferent(ages)

# Clue 1: The 90 million year old fossil costs $250 more than the pilodontus:
m += costs_more_than(age90, pilodontus, 250)

# Clue 2: The gigasaurus costs $500 more than the 78 million year old fossil:
m += costs_more_than(gigasaurus, age78, 500)

# Clue 3: The gigasaurus costs $250 less than the 75 million year old fossil:
m += costs_less_than(gigasaurus, age75, 250)

# Clue 4: The mirasaurus is 90 million years old:
m += mirasaurus == age90

```
True
True
True
Wrong: 0, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The four conductors are Roderick, the conductor working on June 10, the person departing from Leland and the person departing from Indio.
The person working on June 13 will depart from Hardwick.
The conductor working on June 12 is either the conductor departing from Indio or Roderick.
Vernon is either the person working on June 11 or the conductor working on June 13.
Francis will leave sometime before the conductor departing from Leland.

Entities:
names: Francis, Luke, Roderick, Vernon
days: June 10, June 11, June 12, June 13
departures: Hardwick, Indio, Kent, Leland
VAR (32-40): Roderick
PARAM (73-75): 10
VAR (104-110): Leland
VAR (141-146): Indio
PARAM (176-178): 13
VAR (196-204): Hardwick
PARAM (237-239): 12
VAR (279-284): Indio
VAR (288-296): Roderick
PARAM (343-345): 11
VAR (374-378): June
PARAM (379-381): 13
VAR (448-454): Leland
PARAM (523-525): 10
PARAM (533-535): 11
PARAM (543-545): 12
PARAM (553-555): 13
VAR (580-585): Indio
VAR (588-592): Kent
VAR (595-601): Leland

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Francis == 1, and June10 == 1, and Hardwick == 1, then Francis is the conductor working on June 10 departing from Hardwick.

### Decision variables:
-   Names of the conductors: Francis, Luke, Roderick, Vernon (all different, 1 to 4)
-   Days of work: June10, June11, June12, June13 (all different, 1 to 4)
-   Departure locations: Hardwick, Indio, Kent, Leland (all different, 1 to 4)

### Constraints:
-   The four conductors are Roderick, the conductor working on June 10, the person departing from Leland, and the person departing from Indio:
    This is a constraint that states that all these entities are different, thus:
    AllDifferent([Roderick, June10, Leland, Indio]).

-   The person working on June 13 will depart from Hardwick:
    This is a direct assignment constraint:
    June13 == Hardwick.

-   The conductor working on June 12 is either the conductor departing from Indio or Roderick:
    This is a constraint that states that the conductor working on June 12 is either the conductor departing from Indio or Roderick, but not both. So:
    Xor([June12 == Indio, June12 == Roderick]).

-   Vernon is either the person working on June 11 or the conductor working on June 13:
    This is a constraint that states that Vernon is either the person working on June 11 or the conductor working on June 13, but not both. So:
    Xor([Vernon == June11, Vernon == June13]).

-   Francis will leave sometime before the conductor departing from Leland:
    For this, we will need to add a constraint for each possible assignment of the days for Francis and the conductor departing from Leland, such that Francis's day is less than the conductor departing from Leland's day. So, the constraints will be of the form:
    d1 == Francis and d2 == Leland => d1_to_int < d2_to_int, for all d1, d2 in days.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Francis == 1, and June10 == 1, and Hardwick == 1, then Francis is the conductor working on June 10 departing from Hardwick.

### Decision variables:
-   Names of the conductors: Francis, Luke, Roderick, Vernon (all different, 1 to 4)
-   Days of work: June10, June11, June12, June13 (all different, 1 to 4)
-   Departure locations: Hardwick, Indio, Kent, Leland (all different, 1 to 4)

### Constraints:
-   The four conductors are Roderick, the conductor working on June 10, the person departing from Leland, and the person departing from Indio:
    This is a constraint that states that all these entities are different, thus:
    AllDifferent([Roderick, June10, Leland, Indio]).

-   The person working on June 13 will depart from Hardwick:
    This is a direct assignment constraint:
    June13 == Hardwick.

-   The conductor working on June 12 is either the conductor departing from Indio or Roderick:
    This is a constraint that states that the conductor working on June 12 is either the conductor departing from Indio or Roderick, but not both. So:
    Xor([June12 == Indio, June12 == Roderick]).

-   Vernon is either the person working on June 11 or the conductor working on June 13:
    This is a constraint that states that Vernon is either the person working on June 11 or the conductor working on June 13, but not both. So:
    Xor([Vernon == June11, Vernon == June13]).

-   Francis will leave sometime before the conductor departing from Leland:
    For this, we will need to add a constraint for each possible assignment of the days for Francis and the conductor departing from Leland, such that Francis's day is less than the conductor departing from Leland's day. So, the constraints will be of the form:
    d1 == Francis and d2 == Leland => d1_to_int < d2_to_int, for all d1, d2 in days.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of name, day, and departure)
# e.g. if francis == 1 and june10 == 1 and hardwick == 1, then Francis is the conductor working on June 10 departing from Hardwick
francis, luke, roderick, vernon = names = intvar(1, 4, shape=4)
june10, june11, june12, june13 = days = intvar(1, 4, shape=4)
hardwick, indio, kent, leland = departures = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
name_to_int = None  # N/A
day_to_int = {june10: 10, june11: 11, june12: 12, june13: 13}  # in days
departure_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def leave_before_than(var1, var2):
    """
    Formulate the constraint that var1 leaves before var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(day_to_int[d1] < day_to_int[d2])
            for d1 in days for d2 in days]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(names)
m += AllDifferent(days)
m += AllDifferent(departures)

# Clue 1: The four conductors are Roderick, the conductor working on June 10, the person departing from Leland, and the person departing from Indio:
m += AllDifferent([roderick, june10, leland, indio])

# Clue 2: The person working on June 13 will depart from Hardwick:
m += june13 == hardwick

# Clue 3: The conductor working on June 12 is either the conductor departing from Indio or Roderick:
m += Xor([june12 == indio, june12 == roderick])

# Clue 4: Vernon is either the person working on June 11 or the conductor working on June 13:
m += Xor([vernon == june11, vernon == june13])

# Clue 5: Francis will leave sometime before the conductor departing from Leland:
m += leave_before_than(francis, leland)

```
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The Kia rental is for a period 1 day shorter than the Toyota rental.
The 4 day rental is for the Fiat.
Kathy Koch's reservation is either the 5 day reservation or the Fiat rental.
The 3 day rental, Irene Ingram's reservation and Kathy Koch's reservation are all different rentals.
Ann Alexander's rental is for 4 days.

Entities:
customers: Ann Alexander, Edna Erickson, Irene Ingram, Kathy Koch
contract length: 2 days, 3 days, 4 days, 5 days
cars: Fiat, Kia, Nissan, Toyota
VAR (12-22): Kia rental
PARAM (39-40): 1
VAR (62-75): Toyota rental
PARAM (82-83): 4
VAR (106-110): Fiat
PARAM (153-154): 5
VAR (178-189): Fiat rental
PARAM (196-197): 3
PARAM (328-329): 4
PARAM (436-437): 2
PARAM (445-446): 3
PARAM (454-455): 4
PARAM (463-464): 5
VAR (477-481): Fiat
VAR (484-487): Kia

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if AnnAlexander == 1, and Fiat == 1, and Day4 == 1, then Ann Alexander's rental is the Fiat for 4 days.

### Decision variables:
-   Names of the customers: AnnAlexander, EdnaErickson, IreneIngram, KathyKoch (all different, 1 to 4)
-   Length of the rental contracts: Day2, Day3, Day4, Day5 (all different, 1 to 4)
-   Types of cars: Fiat, Kia, Nissan, Toyota (all different, 1 to 4)

### Constraints:
-   The Kia rental is for a period 1 day shorter than the Toyota rental:
    For this, we will need to add a constraint for each possible assignment of the rental lengths for the Kia and Toyota rentals, such that the Kia rental length is 1 less than the Toyota rental length. So, the constraints will be of the form:
    r1 == Kia and r2 == Toyota => r1_to_int == r2_to_int - 1, for all r1, r2 in rental lengths.

-   The 4 day rental is for the Fiat:
    This is a direct assignment constraint:
    Fiat == Day4.

-   Kathy Koch's reservation is either the 5 day reservation or the Fiat rental:
    This is a constraint that states that Kathy Koch's reservation is either the 5-day reservation or the Fiat rental, but not both. So:
    Xor([KathyKoch == Day5, KathyKoch == Fiat]).

-   The 3 day rental, Irene Ingram's reservation, and Kathy Koch's reservation are all different rentals:
    This is a constraint that states that all these entities are different, thus:
    AllDifferent([Day3, IreneIngram, KathyKoch]).

-   Ann Alexander's rental is for 4 days:
    This is a direct assignment constraint:
    AnnAlexander == Day4.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if AnnAlexander == 1, and Fiat == 1, and Day4 == 1, then Ann Alexander's rental is the Fiat for 4 days.

### Decision variables:
-   Names of the customers: AnnAlexander, EdnaErickson, IreneIngram, KathyKoch (all different, 1 to 4)
-   Length of the rental contracts: Day2, Day3, Day4, Day5 (all different, 1 to 4)
-   Types of cars: Fiat, Kia, Nissan, Toyota (all different, 1 to 4)

### Constraints:
-   The Kia rental is for a period 1 day shorter than the Toyota rental:
    For this, we will need to add a constraint for each possible assignment of the rental lengths for the Kia and Toyota rentals, such that the Kia rental length is 1 less than the Toyota rental length. So, the constraints will be of the form:
    r1 == Kia and r2 == Toyota => r1_to_int == r2_to_int - 1, for all r1, r2 in rental lengths.

-   The 4 day rental is for the Fiat:
    This is a direct assignment constraint:
    Fiat == Day4.

-   Kathy Koch's reservation is either the 5 day reservation or the Fiat rental:
    This is a constraint that states that Kathy Koch's reservation is either the 5-day reservation or the Fiat rental, but not both. So:
    Xor([KathyKoch == Day5, KathyKoch == Fiat]).

-   The 3 day rental, Irene Ingram's reservation, and Kathy Koch's reservation are all different rentals:
    This is a constraint that states that all these entities are different, thus:
    AllDifferent([Day3, IreneIngram, KathyKoch]).

-   Ann Alexander's rental is for 4 days:
    This is a direct assignment constraint:
    AnnAlexander == Day4.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of customer, rental length, and car)
# e.g. if ann == 1 and day4 == 1 and fiat == 1, then Ann Alexander's rental is the Fiat for 4 days
ann, edna, irene, kathy = customers = intvar(1, 4, shape=4)
day2, day3, day4, day5 = rental_lengths = intvar(1, 4, shape=4)
fiat, kia, nissan, toyota = cars = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
customer_to_int = None  # N/A
rental_length_to_int = {day2: 2, day3: 3, day4: 4, day5: 5}  # in days
car_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def shorter_than(var1, var2):
    """
    Formulate the constraint that var1 is shorter than var2.
    """
    return [((r1 == var1) & (r2 == var2)).implies(rental_length_to_int[r1] == rental_length_to_int[r2] - 1)
            for r1 in rental_lengths for r2 in rental_lengths]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(customers)
m += AllDifferent(rental_lengths)
m += AllDifferent(cars)

# Clue 1: The Kia rental is for a period 1 day shorter than the Toyota rental:
m += shorter_than(kia, toyota)

# Clue 2: The 4 day rental is for the Fiat:
m += fiat == day4

# Clue 3: Kathy Koch's reservation is either the 5 day reservation or the Fiat rental:
m += Xor([kathy == day5, kathy == fiat])

# Clue 4: The 3 day rental, Irene Ingram's reservation, and Kathy Koch's reservation are all different rentals:
m += AllDifferent([day3, irene, kathy])

# Clue 5: Ann Alexander's rental is for 4 days:
m += ann == day4

```
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The person with 72 LinkedIn connections has 10 fewer Facebook friends than the person with 84 LinkedIn connections.
Yvonne has 20 fewer Facebook friends than Margie.
The four people are the one with 68 LinkedIn connections, Jonathan, Rosie and the person with 120 Facebook friends.
Rosie has 150 Facebook friends.

Entities:
Facebook: 120, 130, 140, 150
LinkedIn: 57, 68, 72, 84
names: Jonathan, Margie, Rosie, Yvonne
PARAM (24-26): 72
PARAM (52-54): 10
PARAM (99-101): 84
PARAM (136-138): 20
VAR (167-173): Margie
PARAM (209-211): 68
LIMIT (272-275): 120
VAR (295-300): Rosie
PARAM (305-308): 150
VAR (339-347): Facebook
PARAM (350-353): 120
PARAM (356-359): 130
PARAM (362-365): 140
PARAM (368-371): 150
PARAM (383-385): 57
PARAM (388-390): 68
PARAM (393-395): 72
PARAM (398-400): 84

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Jonathan == 1, and LinkedIn68 == 1, and Facebook120 == 1, then Jonathan has 68 LinkedIn connections and 120 Facebook friends.

### Decision variables:
-   Names of the people: Jonathan, Margie, Rosie, Yvonne (all different, 1 to 4)
-   Number of LinkedIn connections: 57, 68, 72, 84 (all different, 1 to 4)
-   Number of Facebook friends: 120, 130, 140, 150 (all different, 1 to 4)

### Constraints:
-   The person with 72 LinkedIn connections has 10 fewer Facebook friends than the person with 84 LinkedIn connections:
    For this, we will need to add a constraint for each possible assignment of LinkedIn connections to the person with 72 connections and the person with 84 connections, such that the person with 72 connections has 10 fewer Facebook friends than the person with 84 connections. So, the constraints will be of the form:
    l1 == 72 and l2 == 84 => f1_to_int == f2_to_int - 10, for all l1, l2 in LinkedIn connections and f1, f2 in Facebook friends.

-   Yvonne has 20 fewer Facebook friends than Margie:
    For this, we will need to add a constraint for each possible assignment of Facebook friends to Yvonne and Margie, such that Yvonne has 20 fewer Facebook friends than Margie. So, the constraints will be of the form:
    f1 == Yvonne and f2 == Margie => f1_to_int == f2_to_int - 20, for all f1, f2 in Facebook friends.

-   The four people are the one with 68 LinkedIn connections, Jonathan, Rosie, and the person with 120 Facebook friends:
    This is a constraint that states that the four people are the one with 68 LinkedIn connections, Jonathan, Rosie, and the person with 120 Facebook friends. So, the constraints will be:
    AllDifferent([LinkedIn68, Jonathan, Rosie, Facebook120]).

-   Rosie has 150 Facebook friends:
    This is a direct assignment constraint:
    Rosie == Facebook150.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Jonathan == 1, and LinkedIn68 == 1, and Facebook120 == 1, then Jonathan has 68 LinkedIn connections and 120 Facebook friends.

### Decision variables:
-   Names of the people: Jonathan, Margie, Rosie, Yvonne (all different, 1 to 4)
-   Number of LinkedIn connections: 57, 68, 72, 84 (all different, 1 to 4)
-   Number of Facebook friends: 120, 130, 140, 150 (all different, 1 to 4)

### Constraints:
-   The person with 72 LinkedIn connections has 10 fewer Facebook friends than the person with 84 LinkedIn connections:
    For this, we will need to add a constraint for each possible assignment of LinkedIn connections to the person with 72 connections and the person with 84 connections, such that the person with 72 connections has 10 fewer Facebook friends than the person with 84 connections. So, the constraints will be of the form:
    l1 == 72 and l2 == 84 => f1_to_int == f2_to_int - 10, for all l1, l2 in LinkedIn connections and f1, f2 in Facebook friends.

-   Yvonne has 20 fewer Facebook friends than Margie:
    For this, we will need to add a constraint for each possible assignment of Facebook friends to Yvonne and Margie, such that Yvonne has 20 fewer Facebook friends than Margie. So, the constraints will be of the form:
    f1 == Yvonne and f2 == Margie => f1_to_int == f2_to_int - 20, for all f1, f2 in Facebook friends.

-   The four people are the one with 68 LinkedIn connections, Jonathan, Rosie, and the person with 120 Facebook friends:
    This is a constraint that states that the four people are the one with 68 LinkedIn connections, Jonathan, Rosie, and the person with 120 Facebook friends. So, the constraints will be:
    AllDifferent([LinkedIn68, Jonathan, Rosie, Facebook120]).

-   Rosie has 150 Facebook friends:
    This is a direct assignment constraint:
    Rosie == Facebook150.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of person, LinkedIn connections, and Facebook friends)
# e.g. if jonathan == 1 and linkedin68 == 1 and facebook120 == 1, then Jonathan has 68 LinkedIn connections and 120 Facebook friends
jonathan, margie, rosie, yvonne = people = intvar(1, 4, shape=4)
linkedin57, linkedin68, linkedin72, linkedin84 = linkedin = intvar(1, 4, shape=4)
facebook120, facebook130, facebook140, facebook150 = facebook = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
person_to_int = None  # N/A
linkedin_to_int = {linkedin57: 57, linkedin68: 68, linkedin72: 72, linkedin84: 84}  # in connections
facebook_to_int = {facebook120: 120, facebook130: 130, facebook140: 140, facebook150: 150}  # in friends


# Helper functions (for formulating comparison constraints)
def fewer_friends_than(var1, var2, diff):
    """
    Formulate the constraint that var1 has diff fewer friends than var2.
    """
    return [((f1 == var1) & (f2 == var2)).implies(facebook_to_int[f1] == facebook_to_int[f2] - diff)
            for f1 in facebook for f2 in facebook]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(people)
m += AllDifferent(linkedin)
m += AllDifferent(facebook)

# Clue 1: The person with 72 LinkedIn connections has 10 fewer Facebook friends than the person with 84 LinkedIn connections:
m += fewer_friends_than(linkedin72, linkedin84, 10)

# Clue 2: Yvonne has 20 fewer Facebook friends than Margie:
m += fewer_friends_than(yvonne, margie, 20)

# Clue 3: The four people are the one with 68 LinkedIn connections, Jonathan, Rosie, and the person with 120 Facebook friends:
m += AllDifferent([linkedin68, jonathan, rosie, facebook120])

# Clue 4: Rosie has 150 Facebook friends:
m += rosie == facebook150

```
True
True
True
Wrong: 0, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The photo taken in April was published by Wildzone.
The shot of the giant tortoise was taken 1 month before the photo published by Science World.
The photo of the orangutan was published by The Geographer.
The photo of the snow leopard was taken 2 months after the photo published by The Geographer.

Entities:
animals: giant tortoise, orangutan, snow leopard, tree kangaroo
months: March, April, May, June
magazines: Earth Aware, Science World, The Geographer, Wildzone
VAR (77-91): giant tortoise
PARAM (102-103): 1
VAR (173-182): orangutan
VAR (234-246): snow leopard
PARAM (257-258): 2
VAR (333-347): giant tortoise
VAR (350-359): orangutan
VAR (362-374): snow leopard
VAR (408-413): April

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if GiantTortoise == 1, and April == 1, and Wildzone == 1, then the photo of the giant tortoise taken in April was published by Wildzone.

### Decision variables:
-   Animals: GiantTortoise, Orangutan, SnowLeopard, TreeKangaroo (all different, 1 to 4)
-   Months: March, April, May, June (all different, 1 to 4)
-   Magazines: EarthAware, ScienceWorld, TheGeographer, Wildzone (all different, 1 to 4)

### Constraints:
-   The photo taken in April was published by Wildzone:
    This is a direct assignment constraint:
    April == Wildzone.

-   The shot of the giant tortoise was taken 1 month before the photo published by Science World:
    For this, we will need to add a constraint for each possible assignment of the months for the giant tortoise and Science World, such that the giant tortoise's month is 1 less than Science World's month. So, the constraints will be of the form:
    m1 == GiantTortoise and m2 == ScienceWorld => m1_to_int == m2_to_int - 1, for all m1, m2 in months.

-   The photo of the orangutan was published by The Geographer:
    This is a direct assignment constraint:
    Orangutan == TheGeographer.

-   The photo of the snow leopard was taken 2 months after the photo published by The Geographer:
    For this, we will need to add a constraint for each possible assignment of the months for the snow leopard and The Geographer, such that the snow leopard's month is 2 more than The Geographer's month. So, the constraints will be of the form:
    m1 == SnowLeopard and m2 == TheGeographer => m1_to_int == m2_to_int + 2, for all m1, m2 in months.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if GiantTortoise == 1, and April == 1, and Wildzone == 1, then the photo of the giant tortoise taken in April was published by Wildzone.

### Decision variables:
-   Animals: GiantTortoise, Orangutan, SnowLeopard, TreeKangaroo (all different, 1 to 4)
-   Months: March, April, May, June (all different, 1 to 4)
-   Magazines: EarthAware, ScienceWorld, TheGeographer, Wildzone (all different, 1 to 4)

### Constraints:
-   The photo taken in April was published by Wildzone:
    This is a direct assignment constraint:
    April == Wildzone.

-   The shot of the giant tortoise was taken 1 month before the photo published by Science World:
    For this, we will need to add a constraint for each possible assignment of the months for the giant tortoise and Science World, such that the giant tortoise's month is 1 less than Science World's month. So, the constraints will be of the form:
    m1 == GiantTortoise and m2 == ScienceWorld => m1_to_int == m2_to_int - 1, for all m1, m2 in months.

-   The photo of the orangutan was published by The Geographer:
    This is a direct assignment constraint:
    Orangutan == TheGeographer.

-   The photo of the snow leopard was taken 2 months after the photo published by The Geographer:
    For this, we will need to add a constraint for each possible assignment of the months for the snow leopard and The Geographer, such that the snow leopard's month is 2 more than The Geographer's month. So, the constraints will be of the form:
    m1 == SnowLeopard and m2 == TheGeographer => m1_to_int == m2_to_int + 2, for all m1, m2 in months.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of animal, month, and magazine)
# e.g. if giant_tortoise == 1 and april == 1 and wildzone == 1, then the photo of the giant tortoise taken in April was published by Wildzone
giant_tortoise, orangutan, snow_leopard, tree_kangaroo = animals = intvar(1, 4, shape=4)
march, april, may, june = months = intvar(1, 4, shape=4)
earth_aware, science_world, the_geographer, wildzone = magazines = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
animal_to_int = None  # N/A
month_to_int = {march: 1, april: 2, may: 3, june: 4}  # in months
magazine_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def taken_before_than(var1, var2):
    """
    Formulate the constraint that var1 taken before var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] < month_to_int[m2])
            for m1 in months for m2 in months]


def taken_exactly_before_than(var1, var2, diff):
    """
    Formulate the constraint that var1 taken exactly diff months before var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] == month_to_int[m2] - diff)
            for m1 in months for m2 in months]


def taken_after_than(var1, var2):
    """
    Formulate the constraint that var1 taken after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] > month_to_int[m2])
            for m1 in months for m2 in months]


def taken_exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 taken exactly diff months after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] == month_to_int[m2] + diff)
            for m1 in months for m2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(animals)
m += AllDifferent(months)
m += AllDifferent(magazines)

# Clue 1: The photo taken in April was published by Wildzone:
m += april == wildzone

# Clue 2: The shot of the giant tortoise was taken 1 month before the photo published by Science World:
m += taken_exactly_before_than(giant_tortoise, science_world, 1)

# Clue 3: The photo of the orangutan was published by The Geographer:
m += orangutan == the_geographer

# Clue 4: The photo of the snow leopard was taken 2 months after the photo published by The Geographer:
m += taken_exactly_after_than(snow_leopard, the_geographer, 2

```
Error: invalid syntax (<string>, line 1)
False
False
Error: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
Henrietta's job is either the chore that starts at 9:00am or the chore that starts at 8:00am.
Jack's task is either the job that starts at 8:00am or the living room assignment.
Jack's job starts at 10:00am.
Kay's chore starts at 8:00am.
Jack's assignment starts 2 hours after the mud room assignment.
The laundry room assignment, the chore that starts at 8:00am and the chore that starts at 11:00am are all different jobs.

Entities:
children: Henrietta, Jack, Kay, Zachary
times: 8:00am, 9:00am, 10:00am, 11:00am
rooms: dining room, laundry room, living room, mud room
PARAM (60-66): 9:00am
PARAM (95-101): 8:00am
PARAM (150-156): 8:00am
PARAM (211-218): 10:00am
PARAM (244-250): 8:00am
PARAM (279-280): 2
PARAM (374-380): 8:00am
PARAM (410-417): 11:00am
PARAM (506-512): 8:00am
PARAM (515-521): 9:00am
PARAM (524-531): 10:00am
PARAM (534-541): 11:00am

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Henrietta == 1, and Time9am == 1, and DiningRoom == 1, then Henrietta's chore starts at 9:00am in the dining room.

### Decision variables:
-   Names of the children: Henrietta, Jack, Kay, Zachary (all different, 1 to 4)
-   Times of the chores: 8:00am, 9:00am, 10:00am, 11:00am (all different, 1 to 4)
-   Rooms for the chores: DiningRoom, LaundryRoom, LivingRoom, MudRoom (all different, 1 to 4)

### Constraints:
-   Henrietta's job is either the chore that starts at 9:00am or the chore that starts at 8:00am:
    This is a constraint that states that Henrietta's chore starts either at 9:00am or 8:00am, but not both. So:
    Xor([Henrietta == Time9am, Henrietta == Time8am]).

-   Jack's task is either the job that starts at 8:00am or the living room assignment:
    This is a constraint that states that Jack's chore starts either at 8:00am or in the living room, but not both. So:
    Xor([Jack == Time8am, Jack == LivingRoom]).

-   Jack's job starts at 10:00am:
    This is a direct assignment constraint:
    Jack == Time10am.

-   Kay's chore starts at 8:00am:
    This is a direct assignment constraint:
    Kay == Time8am.

-   Jack's assignment starts 2 hours after the mud room assignment:
    For this, we will need to add a constraint for each possible assignment of the times for Jack's assignment and the mud room assignment, such that Jack's assignment time is 2 more than the mud room assignment time. So, the constraints will be of the form:
    t1 == Jack and t2 == MudRoom => t1_to_int == t2_to_int + 2, for all t1, t2 in times.

-   The laundry room assignment, the chore that starts at 8:00am, and the chore that starts at 11:00am are all different jobs:
    This is a constraint that states that all these entities are different, thus:
    AllDifferent([LaundryRoom, Time8am, Time11am]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Henrietta == 1, and Time9am == 1, and DiningRoom == 1, then Henrietta's chore starts at 9:00am in the dining room.

### Decision variables:
-   Names of the children: Henrietta, Jack, Kay, Zachary (all different, 1 to 4)
-   Times of the chores: 8:00am, 9:00am, 10:00am, 11:00am (all different, 1 to 4)
-   Rooms for the chores: DiningRoom, LaundryRoom, LivingRoom, MudRoom (all different, 1 to 4)

### Constraints:
-   Henrietta's job is either the chore that starts at 9:00am or the chore that starts at 8:00am:
    This is a constraint that states that Henrietta's chore starts either at 9:00am or 8:00am, but not both. So:
    Xor([Henrietta == Time9am, Henrietta == Time8am]).

-   Jack's task is either the job that starts at 8:00am or the living room assignment:
    This is a constraint that states that Jack's chore starts either at 8:00am or in the living room, but not both. So:
    Xor([Jack == Time8am, Jack == LivingRoom]).

-   Jack's job starts at 10:00am:
    This is a direct assignment constraint:
    Jack == Time10am.

-   Kay's chore starts at 8:00am:
    This is a direct assignment constraint:
    Kay == Time8am.

-   Jack's assignment starts 2 hours after the mud room assignment:
    For this, we will need to add a constraint for each possible assignment of the times for Jack's assignment and the mud room assignment, such that Jack's assignment time is 2 more than the mud room assignment time. So, the constraints will be of the form:
    t1 == Jack and t2 == MudRoom => t1_to_int == t2_to_int + 2, for all t1, t2 in times.

-   The laundry room assignment, the chore that starts at 8:00am, and the chore that starts at 11:00am are all different jobs:
    This is a constraint that states that all these entities are different, thus:
    AllDifferent([LaundryRoom, Time8am, Time11am]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of child, time, and room)
# e.g. if henrietta == 1 and time9am == 1 and dining_room == 1, then Henrietta's chore starts at 9:00am in the dining room
henrietta, jack, kay, zachary = children = intvar(1, 4, shape=4)
time8am, time9am, time10am, time11am = times = intvar(1, 4, shape=4)
dining_room, laundry_room, living_room, mud_room = rooms = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
child_to_int = None  # N/A
time_to_int = {time8am: 8, time9am: 9, time10am: 10, time11am: 11}  # in hours
room_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def starts_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 starts diff hours after var2.
    """
    return [((t1 == var1) & (t2 == var2)).implies(time_to_int[t1] == time_to_int[t2] + diff)
            for t1 in times for t2 in times]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(children)
m += AllDifferent(times)
m += AllDifferent(rooms)

# Clue 1: Henrietta's job is either the chore that starts at 9:00am or the chore that starts at 8:00am:
m += Xor([henrietta == time9am, henrietta == time8am])

# Clue 2: Jack's task is either the job that starts at 8:00am or the living room assignment:
m += Xor([jack == time8am, jack == living_room])

# Clue 3: Jack's job starts at 10:00am:
m += jack == time10am

# Clue 4: Kay's chore starts at 8:00am:
m += kay == time8am

# Clue 5: Jack's assignment starts 2 hours after the mud room assignment:
m += starts_after_than(jack, mud_room, 2)

# Clue 6: The laundry room assignment, the chore that starts at 8:00am, and the chore that starts at 11:00am are all different jobs:
m += AllDifferent([laundry_room, time8am, time11am])

```
True
True
True
Wrong: 0, Total: 9
---------------------------------------------------------------------------------------------

Clues:
Charlie is 9 years old.
Gracie has a wingspan of 114 inches.
The 11-year-old bird has a wingspan 8 inches shorter than Charlie.
Angel is either the 8-year-old bird or the bird with a wingspan of 114 inches.

Entities:
names: Angel, Charlie, Gracie, Merlin
wingspans: 102 inches, 106 inches, 110 inches, 114 inches
ages: 8, 9, 10, 11
VAR (8-15): Charlie
PARAM (19-20): 9
VAR (33-39): Gracie
OBJ_NAME (46-54): wingspan
PARAM (58-61): 114
PARAM (111-112): 8
VAR (133-140): Charlie
PARAM (163-164): 8
PARAM (214-217): 114
VAR (246-251): Angel
VAR (254-261): Charlie
VAR (264-270): Gracie
PARAM (292-295): 102
PARAM (305-308): 106
PARAM (318-321): 110
PARAM (331-334): 114
PARAM (349-350): 8
PARAM (353-354): 9
PARAM (357-359): 10
PARAM (362-364): 11

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Angel == 1, and Charlie == 1, and Wingspan114 == 1, then Angel is the 8-year-old bird with a wingspan of 114 inches.

### Decision variables:
-   Names of the birds: Angel, Charlie, Gracie, Merlin (all different, 1 to 4)
-   Wingspans of the birds: Wingspan102, Wingspan106, Wingspan110, Wingspan114 (all different, 1 to 4)
-   Ages of the birds: Age8, Age9, Age10, Age11 (all different, 1 to 4)

### Constraints:
-   Charlie is 9 years old:
    This is a direct assignment constraint:
    Charlie == Age9.

-   Gracie has a wingspan of 114 inches:
    This is a direct assignment constraint:
    Gracie == Wingspan114.

-   The 11-year-old bird has a wingspan 8 inches shorter than Charlie:
    For this, we will need to add a constraint for each possible assignment of ages for the 11-year-old bird and Charlie, such that the 11-year-old bird's wingspan is 8 inches shorter than Charlie's wingspan. So, the constraints will be of the form:
    a1 == Age11 and a2 == Charlie => a1_to_int == a2_to_int - 8, for all a1, a2 in wingspans.

-   Angel is either the 8-year-old bird or the bird with a wingspan of 114 inches:
    This is a constraint that states that Angel is either the 8-year-old bird or the bird with a wingspan of 114 inches, but not both. So:
    Xor([Angel == Age8, Angel == Wingspan114]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Angel == 1, and Charlie == 1, and Wingspan114 == 1, then Angel is the 8-year-old bird with a wingspan of 114 inches.

### Decision variables:
-   Names of the birds: Angel, Charlie, Gracie, Merlin (all different, 1 to 4)
-   Wingspans of the birds: Wingspan102, Wingspan106, Wingspan110, Wingspan114 (all different, 1 to 4)
-   Ages of the birds: Age8, Age9, Age10, Age11 (all different, 1 to 4)

### Constraints:
-   Charlie is 9 years old:
    This is a direct assignment constraint:
    Charlie == Age9.

-   Gracie has a wingspan of 114 inches:
    This is a direct assignment constraint:
    Gracie == Wingspan114.

-   The 11-year-old bird has a wingspan 8 inches shorter than Charlie:
    For this, we will need to add a constraint for each possible assignment of ages for the 11-year-old bird and Charlie, such that the 11-year-old bird's wingspan is 8 inches shorter than Charlie's wingspan. So, the constraints will be of the form:
    a1 == Age11 and a2 == Charlie => a1_to_int == a2_to_int - 8, for all a1, a2 in wingspans.

-   Angel is either the 8-year-old bird or the bird with a wingspan of 114 inches:
    This is a constraint that states that Angel is either the 8-year-old bird or the bird with a wingspan of 114 inches, but not both. So:
    Xor([Angel == Age8, Angel == Wingspan114]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of name, wingspan, and age)
# e.g. if angel == 1 and charlie == 1 and wingspan114 == 1, then Angel is the 8-year-old bird with a wingspan of 114 inches
angel, charlie, gracie, merlin = names = intvar(1, 4, shape=4)
wingspan102, wingspan106, wingspan110, wingspan114 = wingspans = intvar(1, 4, shape=4)
age8, age9, age10, age11 = ages = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
name_to_int = None  # N/A
wingspan_to_int = {wingspan102: 102, wingspan106: 106, wingspan110: 110, wingspan114: 114}  # in inches
age_to_int = {age8: 8, age9: 9, age10: 10, age11: 11}  # in years


# Helper functions (for formulating comparison constraints)
def wingspan_shorter_than(var1, var2, diff):
    """
    Formulate the constraint that var1's wingspan is diff inches shorter than var2's wingspan.
    """
    return [((w1 == var1) & (w2 == var2)).implies(wingspan_to_int[w1] == wingspan_to_int[w2] - diff)
            for w1 in wingspans for w2 in wingspans]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(names)
m += AllDifferent(wingspans)
m += AllDifferent(ages)

# Clue 1: Charlie is 9 years old:
m += charlie == age9

# Clue 2: Gracie has a wingspan of 114 inches:
m += gracie == wingspan114

# Clue 3: The 11-year-old bird has a wingspan 8 inches shorter than Charlie:
m += wingspan_shorter_than(age11, charlie, 8)

# Clue 4: Angel is either the 8-year-old bird or the bird with a wingspan of 114 inches:
m += Xor([angel == age8, angel == wingspan114])

```
True
True
True
Wrong: 0, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The TrustCo card has an APR of 11%.
The Southwest Inc card has a limit of $2,000.
The card with an APR of 11% is either the card with the $4,000 credit limit or the one with the $20,000 credit limit.
The card with an APR of 10% is either the card with the $4,000 credit limit or the TrustCo card.
The Credit Korp card has an APR 1 percent lower than the one with the $2,000 credit limit.

Entities:
credit cards: Credit Korp, Mid Atlantic, Southwest Inc, TrustCo
APR: 8%, 9%, 10%, 11%
credit limits: $2,000, $4,000, $5,000, $20,000
VAR (12-24): TrustCo card
OBJ_NAME (32-35): APR
PARAM (39-43): 11 %
VAR (50-63): Southwest Inc
CONST_DIR (75-80): limit
PARAM (86-91): 2,000
OBJ_NAME (111-114): APR
PARAM (118-122): 11 %
PARAM (153-158): 4,000
PARAM (194-200): 20,000
OBJ_NAME (233-236): APR
PARAM (240-244): 10 %
PARAM (275-280): 4,000
VAR (301-313): TrustCo card
VAR (320-336): Credit Korp card
OBJ_NAME (344-347): APR
PARAM (348-357): 1 percent
PARAM (388-393): 2,000
VAR (449-461): Mid Atlantic
VAR (464-477): Southwest Inc
OBJ_NAME (488-491): APR
PARAM (494-497): 8 %
PARAM (500-503): 9 %
PARAM (506-510): 10 %
PARAM (513-517): 11 %
CONST_DIR (525-531): limits
LIMIT (536-541): 2,000
PARAM (546-551): 4,000
PARAM (556-561): 5,000
LIMIT (566-572): 20,000

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if TrustCo == 1, and APR11 == 1, and Limit2000 == 1, then TrustCo card has an APR of 11% and a credit limit of $2,000.

### Decision variables:
-   Names of the credit cards: CreditKorp, MidAtlantic, SouthwestInc, TrustCo (all different, 1 to 4)
-   APR values: APR8, APR9, APR10, APR11 (all different, 1 to 4)
-   Credit limits: Limit2000, Limit4000, Limit5000, Limit20000 (all different, 1 to 4)

### Constraints:
-   The TrustCo card has an APR of 11%:
    This is a direct assignment constraint:
    TrustCo == APR11.

-   The Southwest Inc card has a limit of $2,000:
    This is a direct assignment constraint:
    SouthwestInc == Limit2000.

-   The card with an APR of 11% is either the card with the $4,000 credit limit or the one with the $20,000 credit limit:
    This is a constraint that states that the card with an APR of 11% is either the card with the $4,000 credit limit or the one with the $20,000 credit limit, but not both. So:
    Xor([APR11 == Limit4000, APR11 == Limit20000]).

-   The card with an APR of 10% is either the card with the $4,000 credit limit or the TrustCo card:
    This is a constraint that states that the card with an APR of 10% is either the card with the $4,000 credit limit or the TrustCo card, but not both. So:
    Xor([APR10 == Limit4000, APR10 == TrustCo]).

-   The Credit Korp card has an APR 1 percent lower than the one with the $2,000 credit limit:
    For this, we will need to add a constraint for each possible assignment of APR values for Credit Korp and the card with the $2,000 credit limit, such that Credit Korp's APR is 1 less than the other card's APR. So, the constraints will be of the form:
    APR1 == CreditKorp and APR2 == Limit2000 => APR1_to_int == APR2_to_int - 1, for all APR1, APR2 in APR values.

-   Define the limits for each card:
    This is a constraint that assigns each card to a specific credit limit:
    CreditKorp == Limit2000, MidAtlantic == Limit4000, SouthwestInc == Limit5000, TrustCo == Limit20000.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if TrustCo == 1, and APR11 == 1, and Limit2000 == 1, then TrustCo card has an APR of 11% and a credit limit of $2,000.

### Decision variables:
-   Names of the credit cards: CreditKorp, MidAtlantic, SouthwestInc, TrustCo (all different, 1 to 4)
-   APR values: APR8, APR9, APR10, APR11 (all different, 1 to 4)
-   Credit limits: Limit2000, Limit4000, Limit5000, Limit20000 (all different, 1 to 4)

### Constraints:
-   The TrustCo card has an APR of 11%:
    This is a direct assignment constraint:
    TrustCo == APR11.

-   The Southwest Inc card has a limit of $2,000:
    This is a direct assignment constraint:
    SouthwestInc == Limit2000.

-   The card with an APR of 11% is either the card with the $4,000 credit limit or the one with the $20,000 credit limit:
    This is a constraint that states that the card with an APR of 11% is either the card with the $4,000 credit limit or the one with the $20,000 credit limit, but not both. So:
    Xor([APR11 == Limit4000, APR11 == Limit20000]).

-   The card with an APR of 10% is either the card with the $4,000 credit limit or the TrustCo card:
    This is a constraint that states that the card with an APR of 10% is either the card with the $4,000 credit limit or the TrustCo card, but not both. So:
    Xor([APR10 == Limit4000, APR10 == TrustCo]).

-   The Credit Korp card has an APR 1 percent lower than the one with the $2,000 credit limit:
    For this, we will need to add a constraint for each possible assignment of APR values for Credit Korp and the card with the $2,000 credit limit, such that Credit Korp's APR is 1 less than the other card's APR. So, the constraints will be of the form:
    APR1 == CreditKorp and APR2 == Limit2000 => APR1_to_int == APR2_to_int - 1, for all APR1, APR2 in APR values.

-   Define the limits for each card:
    This is a constraint that assigns each card to a specific credit limit:
    CreditKorp == Limit2000, MidAtlantic == Limit4000, SouthwestInc == Limit5000, TrustCo == Limit20000.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of card, APR, and limit)
# e.g. if creditkorp == 1 and apr8 == 1 and limit2000 == 1, then Credit Korp card has an APR of 8% and a credit limit of $2,000
creditkorp, midatlantic, southwestinc, trustco = cards = intvar(1, 4, shape=4)
apr8, apr9, apr10, apr11 = aprs = intvar(1, 4, shape=4)
limit2000, limit4000, limit5000, limit20000 = limits = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
card_to_int = None  # N/A
apr_to_int = {apr8: 8, apr9: 9, apr10: 10, apr11: 11}  # in percent
limit_to_int = {limit2000: 2000, limit4000: 4000, limit5000: 5000, limit20000: 20000}  # in dollars


# Helper functions (for formulating comparison constraints)
def apr_is_either(var1, var2, var3):
    """
    Formulate the constraint that var1's APR is either var2's limit or var3's limit.
    """
    return [((a == var1) & (l1 == var2) & (l2 == var3)).implies((apr_to_int[a] == limit_to_int[l1]) | (apr_to_int[a] == limit_to_int[l2]))
            for a in aprs for l1 in limits for l2 in limits]


def apr_is_one_percent_lower(var1, var2):
    """
    Formulate the constraint that var1's APR is 1 percent lower than var2's APR.
    """
    return [((a1 == var1) & (a2 == var2)).implies(apr_to_int[a1] == apr_to_int[a2] - 1)
            for a1 in aprs for a2 in aprs]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(cards)
m += AllDifferent(aprs)
m += AllDifferent(limits)

# Clue 1: The TrustCo card has an APR of 11%:
m += trustco == apr11

# Clue 2: The Southwest Inc card has a limit of $2,000:
m += southwestinc == limit2000

# Clue 3: The card with an APR of 11% is either the card with the $4,000 credit limit or the one with the $20,000 credit limit:
m += apr_is_either(apr11, limit4000, limit20000)

# Clue 4: The card with an APR of 10% is either the card with the $4,000 credit limit or the TrustCo card:
m += apr_is_either(apr10, limit4000, trustco)

# Clue 5: The Credit Korp card has an APR 1 percent lower than the one with the $2,000 credit limit:
m += apr_is_one_percent_lower(creditkorp, limit2000)

# Define the limits for each card
m += [creditkorp == limit2000, midatlantic == limit4000, southwestinc == limit5000, trustco == limit20000]

```
False
False
False
Wrong: 3, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The title due on September 22 is either Rosa's book or "Dancing Well".
Ebony's book was due 1 week after Rosa's book.
Aimee's book was due on September 15.
Ebony's book was "Heaven's Seal".
"Heaven's Seal" was due 1 week after "Frogs of Iowa".

Entities:
borrowers: Aimee, Ebony, Jimmy, Rosa
due dates: September 1, September 8, September 15, September 22
titles: Dancing Well, Frogs of Iowa, Heaven's Seal, Time to Burn
LIMIT (35-37): 22
VAR (48-60): Rosa 's book
VAR (66-78): Dancing Well
VAR (83-91): Ebony 's
PARAM (105-106): 1
VAR (118-130): Rosa 's book
VAR (133-141): Aimee 's
PARAM (168-170): 15
VAR (173-178): Ebony
VAR (193-207): Heaven 's Seal
VAR (214-228): Heaven 's Seal
PARAM (239-240): 1
PARAM (346-347): 1
PARAM (360-361): 8
PARAM (374-376): 15
LIMIT (389-391): 22
VAR (401-413): Dancing Well
VAR (432-441): Heaven 's

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Aimee == 1, and September15 == 1, and DancingWell == 1, then Aimee's book was due on September 15 with the title Dancing Well.

### Decision variables:
-   Names of the borrowers: Aimee, Ebony, Jimmy, Rosa (all different, 1 to 4)
-   Due dates of the titles: September1, September8, September15, September22 (all different, 1 to 4)
-   Titles of the books: DancingWell, FrogsOfIowa, Heaven'sSeal, TimeToBurn (all different, 1 to 4)

### Constraints:
-   The title due on September 22 is either Rosa's book or "Dancing Well":
    This is a constraint that states that the title due on September 22 is either Rosa's book or "Dancing Well", but not both. So:
    Xor([September22 == RosaBook, September22 == DancingWell]).

-   Ebony's book was due 1 week after Rosa's book:
    For this, we will need to add a constraint for each possible assignment of the due dates for Ebony's book and Rosa's book, such that Ebony's book's due date is 1 more than Rosa's book's due date. So, the constraints will be of the form:
    d1 == Ebony and d2 == Rosa => d1_to_int == d2_to_int + 1, for all d1, d2 in due dates.

-   Aimee's book was due on September 15:
    This is a direct assignment constraint:
    Aimee == September15.

-   Ebony's book was "Heaven's Seal":
    This is a direct assignment constraint:
    Ebony == HeavenSeal.

-   "Heaven's Seal" was due 1 week after "Frogs of Iowa":
    For this, we will need to add a constraint for each possible assignment of the due dates for "Heaven's Seal" and "Frogs of Iowa", such that "Heaven's Seal"'s due date is 1 more than "Frogs of Iowa"'s due date. So, the constraints will be of the form:
    d1 == HeavenSeal and d2 == FrogsOfIowa => d1_to_int == d2_to_int + 1, for all d1, d2 in due dates.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Aimee == 1, and September15 == 1, and DancingWell == 1, then Aimee's book was due on September 15 with the title Dancing Well.

### Decision variables:
-   Names of the borrowers: Aimee, Ebony, Jimmy, Rosa (all different, 1 to 4)
-   Due dates of the titles: September1, September8, September15, September22 (all different, 1 to 4)
-   Titles of the books: DancingWell, FrogsOfIowa, Heaven'sSeal, TimeToBurn (all different, 1 to 4)

### Constraints:
-   The title due on September 22 is either Rosa's book or "Dancing Well":
    This is a constraint that states that the title due on September 22 is either Rosa's book or "Dancing Well", but not both. So:
    Xor([September22 == RosaBook, September22 == DancingWell]).

-   Ebony's book was due 1 week after Rosa's book:
    For this, we will need to add a constraint for each possible assignment of the due dates for Ebony's book and Rosa's book, such that Ebony's book's due date is 1 more than Rosa's book's due date. So, the constraints will be of the form:
    d1 == Ebony and d2 == Rosa => d1_to_int == d2_to_int + 1, for all d1, d2 in due dates.

-   Aimee's book was due on September 15:
    This is a direct assignment constraint:
    Aimee == September15.

-   Ebony's book was "Heaven's Seal":
    This is a direct assignment constraint:
    Ebony == HeavenSeal.

-   "Heaven's Seal" was due 1 week after "Frogs of Iowa":
    For this, we will need to add a constraint for each possible assignment of the due dates for "Heaven's Seal" and "Frogs of Iowa", such that "Heaven's Seal"'s due date is 1 more than "Frogs of Iowa"'s due date. So, the constraints will be of the form:
    d1 == HeavenSeal and d2 == FrogsOfIowa => d1_to_int == d2_to_int + 1, for all d1, d2 in due dates.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of borrower, due date, and title)
# e.g. if aimee == 1 and sept15 == 1 and dancing_well == 1, then Aimee's book was due on September 15 with the title Dancing Well
aimee, ebony, jimmy, rosa = borrowers = intvar(1, 4, shape=4)
sept1, sept8, sept15, sept22 = due_dates = intvar(1, 4, shape=4)
dancing_well, frogs_of_iowa, heavens_seal, time_to_burn = titles = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
borrower_to_int = None  # N/A
due_date_to_int = {sept1: 1, sept8: 8, sept15: 15, sept22: 22}  # in days
title_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def due_after_than(var1, var2):
    """
    Formulate the constraint that var1 is due after var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(due_date_to_int[d1] > due_date_to_int[d2])
            for d1 in due_dates for d2 in due_dates]


def due_exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 is due exactly diff days after var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(due_date_to_int[d1] == due_date_to_int[d2] + diff)
            for d1 in due_dates for d2 in due_dates]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(borrowers)
m += AllDifferent(due_dates)
m += AllDifferent(titles)

# Clue 1: The title due on September 22 is either Rosa's book or "Dancing Well":
m += Xor([sept22 == rosa, sept22 == dancing_well])

# Clue 2: Ebony's book was due 1 week after Rosa's book:
m += due_exactly_after_than(ebony, rosa, 1)

# Clue 3: Aimee's book was due on September 15:
m += aimee == sept15

# Clue 4: Ebony's book was "Heaven's Seal":
m += ebony == heavens_seal

# Clue 5: "Heaven's Seal" was due 1 week after "Frogs of Iowa":
m += due_exactly_after_than(heavens_seal, frogs_of_iowa, 1)

```
False
False
False
Wrong: 2, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The siren released in 1997 is 10 decibels louder than the siren released in 1996.
The siren released in 2009 is either the Armor-Stop or the Viking 5.
The siren released in 1997 is either the Soundarm or the Viking 5.
The Armor-Stop is louder than the siren released in 2009.
The Soundarm is 110 decibels loud.

Entities:
sirens: Armor-Stop, Rip Tide, Soundarm, Viking 5
decibels: 100 decibels, 105 decibels, 110 decibels, 115 decibels
years: 1996, 1997, 2000, 2009
VAR (30-34): 1997
PARAM (38-40): 10
VAR (84-88): 1996
VAR (113-117): 2009
VAR (132-144): Armor - Stop
VAR (152-160): Viking 5
VAR (185-189): 1997
OBJ_NAME (220-226): Viking
PARAM (227-228): 5
VAR (235-247): Armor - Stop
VAR (285-289): 2009
VAR (296-304): Soundarm
PARAM (308-311): 110
VAR (348-360): Armor - Stop
OBJ_NAME (385-391): Viking
PARAM (392-393): 5
PARAM (405-408): 100
PARAM (420-423): 105
PARAM (435-438): 110
PARAM (450-453): 115
VAR (471-475): 1996
PARAM (478-482): 1997
PARAM (485-489): 2000
LIMIT (492-496): 2009

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if ArmorStop == 1, and Decibels100 == 1, and Year1996 == 1, then Armor-Stop was released in 1996 with 100 decibels.

### Decision variables:
-   Names of the sirens: ArmorStop, RipTide, Soundarm, Viking5 (all different, 1 to 4)
-   Decibel levels: Decibels100, Decibels105, Decibels110, Decibels115 (all different, 1 to 4)
-   Years of release: Year1996, Year1997, Year2000, Year2009 (all different, 1 to 4)

### Constraints:
-   The siren released in 1997 is 10 decibels louder than the siren released in 1996:
    For this, we will need to add a constraint for each possible assignment of the decibel levels for the sirens released in 1996 and 1997, such that the decibel level of the siren released in 1997 is 10 more than the decibel level of the siren released in 1996. So, the constraints will be of the form:
    d1 == Year1997 and d2 == Year1996 => d1_to_int == d2_to_int + 10, for all d1, d2 in decibel levels.

-   The siren released in 2009 is either the Armor-Stop or the Viking 5:
    This is a constraint that states that the siren released in 2009 is either the Armor-Stop or the Viking 5, but not both. So:
    Xor([Year2009 == ArmorStop, Year2009 == Viking5]).

-   The siren released in 1997 is either the Soundarm or the Viking 5:
    This is a constraint that states that the siren released in 1997 is either the Soundarm or the Viking 5, but not both. So:
    Xor([Year1997 == Soundarm, Year1997 == Viking5]).

-   The Armor-Stop is louder than the siren released in 2009:
    For this, we will need to add a constraint for each possible assignment of the decibel levels for the Armor-Stop and the siren released in 2009, such that the decibel level of the Armor-Stop is greater than the decibel level of the siren released in 2009. So, the constraints will be of the form:
    d1 == ArmorStop and d2 == Year2009 => d1_to_int > d2_to_int, for all d1, d2 in decibel levels.

-   The Soundarm is 110 decibels loud:
    This is a direct assignment constraint:
    Soundarm == Decibels110.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if ArmorStop == 1, and Decibels100 == 1, and Year1996 == 1, then Armor-Stop was released in 1996 with 100 decibels.

### Decision variables:
-   Names of the sirens: ArmorStop, RipTide, Soundarm, Viking5 (all different, 1 to 4)
-   Decibel levels: Decibels100, Decibels105, Decibels110, Decibels115 (all different, 1 to 4)
-   Years of release: Year1996, Year1997, Year2000, Year2009 (all different, 1 to 4)

### Constraints:
-   The siren released in 1997 is 10 decibels louder than the siren released in 1996:
    For this, we will need to add a constraint for each possible assignment of the decibel levels for the sirens released in 1996 and 1997, such that the decibel level of the siren released in 1997 is 10 more than the decibel level of the siren released in 1996. So, the constraints will be of the form:
    d1 == Year1997 and d2 == Year1996 => d1_to_int == d2_to_int + 10, for all d1, d2 in decibel levels.

-   The siren released in 2009 is either the Armor-Stop or the Viking 5:
    This is a constraint that states that the siren released in 2009 is either the Armor-Stop or the Viking 5, but not both. So:
    Xor([Year2009 == ArmorStop, Year2009 == Viking5]).

-   The siren released in 1997 is either the Soundarm or the Viking 5:
    This is a constraint that states that the siren released in 1997 is either the Soundarm or the Viking 5, but not both. So:
    Xor([Year1997 == Soundarm, Year1997 == Viking5]).

-   The Armor-Stop is louder than the siren released in 2009:
    For this, we will need to add a constraint for each possible assignment of the decibel levels for the Armor-Stop and the siren released in 2009, such that the decibel level of the Armor-Stop is greater than the decibel level of the siren released in 2009. So, the constraints will be of the form:
    d1 == ArmorStop and d2 == Year2009 => d1_to_int > d2_to_int, for all d1, d2 in decibel levels.

-   The Soundarm is 110 decibels loud:
    This is a direct assignment constraint:
    Soundarm == Decibels110.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of siren, decibel, and year)
# e.g. if armor_stop == 1 and decibels100 == 1 and year1996 == 1, then Armor-Stop was released in 1996 with 100 decibels
armor_stop, rip_tide, soundarm, viking5 = sirens = intvar(1, 4, shape=4)
decibels100, decibels105, decibels110, decibels115 = decibels = intvar(1, 4, shape=4)
year1996, year1997, year2000, year2009 = years = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
siren_to_int = None  # N/A
decibel_to_int = {decibels100: 100, decibels105: 105, decibels110: 110, decibels115: 115}  # in decibels
year_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def louder_than(var1, var2):
    """
    Formulate the constraint that var1 is louder than var2.
    """
    return [((s1 == var1) & (s2 == var2)).implies(decibel_to_int[s1] > decibel_to_int[s2])
            for s1 in decibels for s2 in decibels]


def louder_exactly_than(var1, var2, diff):
    """
    Formulate the constraint that var1 is exactly diff decibels louder than var2.
    """
    return [((s1 == var1) & (s2 == var2)).implies(decibel_to_int[s1] == decibel_to_int[s2] + diff)
            for s1 in decibels for s2 in decibels]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(sirens)
m += AllDifferent(decibels)
m += AllDifferent(years)

# Clue 1: The siren released in 1997 is 10 decibels louder than the siren released in 1996:
m += louder_exactly_than(year1997, year1996, 10)

# Clue 2: The siren released in 2009 is either the Armor-Stop or the Viking 5:
m += Xor([year2009 == armor_stop, year2009 == viking5])

# Clue 3: The siren released in 1997 is either the Soundarm or the Viking 5:
m += Xor([year1997 == soundarm, year1997 == viking5])

# Clue 4: The Armor-Stop is louder than the siren released in 2009:
m += louder_than(armor_stop, year2009)

# Clue 5: The Soundarm is 110 decibels loud:
m += soundarm == decibels110

```
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The one who had the cafe americano paid 1 dollar more than the one who had the cafe latte.
Hope paid $8.
Norman paid less than Opal.
The one who had the cafe americano paid less than Linda.
The one who had the cafe mocha paid 2 dollars more than Norman.

Entities:
names: Hope, Linda, Norman, Opal
prices: $5, $6, $7, $8
drinks: cafe americano, cafe latte, cafe mocha, espresso
VAR (28-42): cafe americano
PARAM (48-49): 1
VAR (87-97): cafe latte
PARAM (112-113): 8
VAR (165-179): cafe americano
VAR (223-233): cafe mocha
PARAM (239-240): 2
OBJ_NAME (316-322): prices
PARAM (327-328): 5
PARAM (333-334): 6
PARAM (339-340): 7
PARAM (345-346): 8
VAR (356-370): cafe americano
VAR (373-383): cafe latte
VAR (386-396): cafe mocha

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Hope == 1, and Price8 == 1, and CafeAmericano == 1, then Hope paid $8 for a cafe americano.

### Decision variables:
-   Names of the individuals: Hope, Linda, Norman, Opal (all different, 1 to 4)
-   Prices paid: $5, $6, $7, $8 (all different, 1 to 4)
-   Types of drinks: CafeAmericano, CafeLatte, CafeMocha, Espresso (all different, 1 to 4)

### Constraints:
-   The one who had the cafe americano paid 1 dollar more than the one who had the cafe latte:
    For this, we will need to add a constraint for each possible assignment of prices for cafe americano and cafe latte, such that the price for cafe americano is 1 more than the price for cafe latte. So, the constraints will be of the form:
    p1 == CafeAmericano and p2 == CafeLatte => p1_to_int == p2_to_int + 1, for all p1, p2 in prices.

-   Hope paid $8:
    This is a direct assignment constraint:
    Hope == Price8.

-   Norman paid less than Opal:
    For this, we will need to add a constraint for each possible assignment of prices for Norman and Opal, such that Norman's price is less than Opal's price. So, the constraints will be of the form:
    p1 == Norman and p2 == Opal => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   The one who had the cafe americano paid less than Linda:
    For this, we will need to add a constraint for each possible assignment of prices for cafe americano and Linda, such that the price for cafe americano is less than the price for Linda. So, the constraints will be of the form:
    p1 == CafeAmericano and p2 == Linda => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   The one who had the cafe mocha paid 2 dollars more than Norman:
    For this, we will need to add a constraint for each possible assignment of prices for cafe mocha and Norman, such that the price for cafe mocha is 2 more than the price for Norman. So, the constraints will be of the form:
    p1 == CafeMocha and p2 == Norman => p1_to_int == p2_to_int + 2, for all p1, p2 in prices.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Hope == 1, and Price8 == 1, and CafeAmericano == 1, then Hope paid $8 for a cafe americano.

### Decision variables:
-   Names of the individuals: Hope, Linda, Norman, Opal (all different, 1 to 4)
-   Prices paid: $5, $6, $7, $8 (all different, 1 to 4)
-   Types of drinks: CafeAmericano, CafeLatte, CafeMocha, Espresso (all different, 1 to 4)

### Constraints:
-   The one who had the cafe americano paid 1 dollar more than the one who had the cafe latte:
    For this, we will need to add a constraint for each possible assignment of prices for cafe americano and cafe latte, such that the price for cafe americano is 1 more than the price for cafe latte. So, the constraints will be of the form:
    p1 == CafeAmericano and p2 == CafeLatte => p1_to_int == p2_to_int + 1, for all p1, p2 in prices.

-   Hope paid $8:
    This is a direct assignment constraint:
    Hope == Price8.

-   Norman paid less than Opal:
    For this, we will need to add a constraint for each possible assignment of prices for Norman and Opal, such that Norman's price is less than Opal's price. So, the constraints will be of the form:
    p1 == Norman and p2 == Opal => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   The one who had the cafe americano paid less than Linda:
    For this, we will need to add a constraint for each possible assignment of prices for cafe americano and Linda, such that the price for cafe americano is less than the price for Linda. So, the constraints will be of the form:
    p1 == CafeAmericano and p2 == Linda => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   The one who had the cafe mocha paid 2 dollars more than Norman:
    For this, we will need to add a constraint for each possible assignment of prices for cafe mocha and Norman, such that the price for cafe mocha is 2 more than the price for Norman. So, the constraints will be of the form:
    p1 == CafeMocha and p2 == Norman => p1_to_int == p2_to_int + 2, for all p1, p2 in prices.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of individual, price, and drink)
# e.g. if hope == 1 and price8 == 1 and cafe_americano == 1, then Hope paid $8 for a cafe americano
hope, linda, norman, opal = individuals = intvar(1, 4, shape=4)
price5, price6, price7, price8 = prices = intvar(1, 4, shape=4)
cafe_americano, cafe_latte, cafe_mocha, espresso = drinks = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
individual_to_int = None  # N/A
price_to_int = {price5: 5, price6: 6, price7: 7, price8: 8}  # in dollars
drink_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def paid_more_than(var1, var2):
    """
    Formulate the constraint that var1 paid more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] > price_to_int[p2])
            for p1 in prices for p2 in prices]


def paid_exactly_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 paid exactly diff dollars more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] + diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(individuals)
m += AllDifferent(prices)
m += AllDifferent(drinks)

# Clue 1: The one who had the cafe americano paid 1 dollar more than the one who had the cafe latte:
m += paid_exactly_more_than(cafe_americano, cafe_latte, 1)

# Clue 2: Hope paid $8:
m += hope == price8

# Clue 3: Norman paid less than Opal:
m += paid_more_than(norman, opal)

# Clue 4: The one who had the cafe americano paid less than Linda:
m += paid_more_than(cafe_americano, linda)

# Clue 5: The one who had the cafe mocha paid 2 dollars more than Norman:
m += paid_exactly_more_than(cafe_mocha, norman, 2)

```
False
False
False
Wrong: 2, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The ring with the aquamarine cost less than the piece with the diamond.
Opal's ring is either the piece that cost $1300 or the piece with the diamond.
The piece that cost $1400 is either the ring with the ruby or Hazel's ring.
Hazel's ring has the diamond.
Becky's piece cost more than the ring with the diamond.

Entities:
customers: Becky, Hazel, Opal, Yolanda
prices: $1100, $1200, $1300, $1400
stones: aquamarine, diamond, ruby, topaz
VAR (12-16): ring
VAR (26-36): aquamarine
PARAM (42-46): less
VAR (56-61): piece
VAR (71-78): diamond
VAR (81-88): Opal 's
PARAM (126-130): 1300
VAR (138-143): piece
VAR (153-160): diamond
PARAM (185-189): 1400
VAR (204-213): ring with
VAR (218-222): ruby
VAR (226-239): Hazel 's ring
VAR (242-255): Hazel 's ring
VAR (274-288): Becky 's piece
CONST_DIR (294-298): more
VAR (308-329): ring with the diamond
PARAM (397-401): 1100
PARAM (406-410): 1200
PARAM (415-419): 1300
PARAM (424-428): 1400

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Becky == 1, and Price1100 == 1, and Ring == 1, then Becky's piece, costing $1100, is a ring.

### Decision variables:
-   Names of the customers: Becky, Hazel, Opal, Yolanda (all different, 1 to 4)
-   Prices of the pieces: $1100, $1200, $1300, $1400 (all different, 1 to 4)
-   Stones in the pieces: aquamarine, diamond, ruby, topaz (all different, 1 to 4)
-   Types of the pieces: ring, piece (all different, 1 to 2)

### Constraints:
-   The ring with the aquamarine cost less than the piece with the diamond:
    For this, we will need to add a constraint for each possible assignment of the prices for the ring with the aquamarine and the piece with the diamond, such that the price of the ring with the aquamarine is less than the price of the piece with the diamond. So, the constraints will be of the form:
    p1 == aquamarine and p2 == diamond => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   Opal's ring is either the piece that cost $1300 or the piece with the diamond:
    This is a constraint that states that Opal's ring is either the piece that costs $1300 or the piece with the diamond, but not both. So:
    Xor([Opal == Price1300, Opal == diamond]).

-   The piece that cost $1400 is either the ring with the ruby or Hazel's ring:
    This is a constraint that states that the piece that costs $1400 is either the ring with the ruby or Hazel's ring, but not both. So:
    Xor([Price1400 == ring with ruby, Price1400 == Hazel's ring]).

-   Hazel's ring has the diamond:
    This is a direct assignment constraint:
    Hazel == diamond.

-   Becky's piece cost more than the ring with the diamond:
    For this, we will need to add a constraint for each possible assignment of the prices for Becky's piece and the ring with the diamond, such that the price of Becky's piece is more than the price of the ring with the diamond. So, the constraints will be of the form:
    p1 == Becky and p2 == diamond => p1_to_int > p2_to_int, for all p1, p2 in prices.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Becky == 1, and Price1100 == 1, and Ring == 1, then Becky's piece, costing $1100, is a ring.

### Decision variables:
-   Names of the customers: Becky, Hazel, Opal, Yolanda (all different, 1 to 4)
-   Prices of the pieces: $1100, $1200, $1300, $1400 (all different, 1 to 4)
-   Stones in the pieces: aquamarine, diamond, ruby, topaz (all different, 1 to 4)
-   Types of the pieces: ring, piece (all different, 1 to 2)

### Constraints:
-   The ring with the aquamarine cost less than the piece with the diamond:
    For this, we will need to add a constraint for each possible assignment of the prices for the ring with the aquamarine and the piece with the diamond, such that the price of the ring with the aquamarine is less than the price of the piece with the diamond. So, the constraints will be of the form:
    p1 == aquamarine and p2 == diamond => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   Opal's ring is either the piece that cost $1300 or the piece with the diamond:
    This is a constraint that states that Opal's ring is either the piece that costs $1300 or the piece with the diamond, but not both. So:
    Xor([Opal == Price1300, Opal == diamond]).

-   The piece that cost $1400 is either the ring with the ruby or Hazel's ring:
    This is a constraint that states that the piece that costs $1400 is either the ring with the ruby or Hazel's ring, but not both. So:
    Xor([Price1400 == ring with ruby, Price1400 == Hazel's ring]).

-   Hazel's ring has the diamond:
    This is a direct assignment constraint:
    Hazel == diamond.

-   Becky's piece cost more than the ring with the diamond:
    For this, we will need to add a constraint for each possible assignment of the prices for Becky's piece and the ring with the diamond, such that the price of Becky's piece is more than the price of the ring with the diamond. So, the constraints will be of the form:
    p1 == Becky and p2 == diamond => p1_to_int > p2_to_int, for all p1, p2 in prices.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of customer, price, and stone)
# e.g. if becky == 1 and price1100 == 1 and ring == 1, then Becky's piece, costing $1100, is a ring
becky, hazel, opal, yolanda = customers = intvar(1, 4, shape=4)
price1100, price1200, price1300, price1400 = prices = intvar(1, 4, shape=4)
aquamarine, diamond, ruby, topaz = stones = intvar(1, 4, shape=4)
ring, piece = types = intvar(1, 2, shape=2)

# Integer representation of the decision variables (for comparison constraints)
customer_to_int = None  # N/A
price_to_int = {price1100: 1100, price1200: 1200, price1300: 1300, price1400: 1400}  # in dollars
stone_to_int = None  # N/A
type_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def cost_less_than(var1, var2):
    """
    Formulate the constraint that var1 cost less than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] < price_to_int[p2])
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(customers)
m += AllDifferent(prices)
m += AllDifferent(stones)
m += AllDifferent(types)

# Clue 1: The ring with the aquamarine cost less than the piece with the diamond:
m += cost_less_than(aquamarine, diamond)

# Clue 2: Opal's ring is either the piece that cost $1300 or the piece with the diamond:
m += Xor([opal == price1300, opal == diamond])

# Clue 3: The piece that cost $1400 is either the ring with the ruby or Hazel's ring:
m += Xor([price1400 == ring, price1400 == hazel])

# Clue 4: Hazel's ring has the diamond:
m += hazel == diamond

# Clue 5: Becky's piece cost more than the ring with the diamond:
m += cost_less_than(diamond, becky)

```
False
True
False
Wrong: 8, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The wood frog was bought 1 month after Nettie's pet.
Ollie's pet is the wood frog.
The tree frog was bought 2 months after Ollie's pet.
Joann's pet is either the wood frog or the tree frog.
Ida's pet is either the animal bought in April or the bullfrog.

Entities:
names: Ida, Joann, Nettie, Ollie
months: January, February, March, April
amphibians: bullfrog, horned toad, tree frog, wood frog
VAR (17-21): frog
PARAM (33-34): 1
VAR (47-53): Nettie
VAR (63-68): Ollie
VAR (104-108): frog
PARAM (120-121): 2
VAR (135-143): Ollie 's
VAR (150-155): Joann
VAR (206-209): Ida
VAR (314-319): Ollie

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ida == 1, and January == 1, and Bullfrog == 1, then Ida's pet is the bullfrog bought in January.

### Decision variables:
-   Names of the individuals: Ida, Joann, Nettie, Ollie (all different, 1 to 4)
-   Months of purchase: January, February, March, April (all different, 1 to 4)
-   Types of amphibians: Bullfrog, HornedToad, TreeFrog, WoodFrog (all different, 1 to 4)

### Constraints:
-   The wood frog was bought 1 month after Nettie's pet:
    For this, we will need to add a constraint for each possible assignment of the months of purchase for the wood frog and Nettie's pet, such that the wood frog's month of purchase is 1 more than Nettie's pet's month of purchase. So, the constraints will be of the form:
    m1 == WoodFrog and m2 == Nettie => m1_to_int == m2_to_int + 1, for all m1, m2 in months of purchase.

-   Ollie's pet is the wood frog:
    This is a direct assignment constraint:
    Ollie == WoodFrog.

-   The tree frog was bought 2 months after Ollie's pet:
    For this, we will need to add a constraint for each possible assignment of the months of purchase for the tree frog and Ollie's pet, such that the tree frog's month of purchase is 2 more than Ollie's pet's month of purchase. So, the constraints will be of the form:
    m1 == TreeFrog and m2 == Ollie => m1_to_int == m2_to_int + 2, for all m1, m2 in months of purchase.

-   Joann's pet is either the wood frog or the tree frog:
    This is a constraint that states that Joann's pet is either the wood frog or the tree frog, but not both. So:
    Xor([Joann == WoodFrog, Joann == TreeFrog]).

-   Ida's pet is either the animal bought in April or the bullfrog:
    This is a constraint that states that Ida's pet is either the animal bought in April or the bullfrog, but not both. So:
    Xor([Ida == April, Ida == Bullfrog]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ida == 1, and January == 1, and Bullfrog == 1, then Ida's pet is the bullfrog bought in January.

### Decision variables:
-   Names of the individuals: Ida, Joann, Nettie, Ollie (all different, 1 to 4)
-   Months of purchase: January, February, March, April (all different, 1 to 4)
-   Types of amphibians: Bullfrog, HornedToad, TreeFrog, WoodFrog (all different, 1 to 4)

### Constraints:
-   The wood frog was bought 1 month after Nettie's pet:
    For this, we will need to add a constraint for each possible assignment of the months of purchase for the wood frog and Nettie's pet, such that the wood frog's month of purchase is 1 more than Nettie's pet's month of purchase. So, the constraints will be of the form:
    m1 == WoodFrog and m2 == Nettie => m1_to_int == m2_to_int + 1, for all m1, m2 in months of purchase.

-   Ollie's pet is the wood frog:
    This is a direct assignment constraint:
    Ollie == WoodFrog.

-   The tree frog was bought 2 months after Ollie's pet:
    For this, we will need to add a constraint for each possible assignment of the months of purchase for the tree frog and Ollie's pet, such that the tree frog's month of purchase is 2 more than Ollie's pet's month of purchase. So, the constraints will be of the form:
    m1 == TreeFrog and m2 == Ollie => m1_to_int == m2_to_int + 2, for all m1, m2 in months of purchase.

-   Joann's pet is either the wood frog or the tree frog:
    This is a constraint that states that Joann's pet is either the wood frog or the tree frog, but not both. So:
    Xor([Joann == WoodFrog, Joann == TreeFrog]).

-   Ida's pet is either the animal bought in April or the bullfrog:
    This is a constraint that states that Ida's pet is either the animal bought in April or the bullfrog, but not both. So:
    Xor([Ida == April, Ida == Bullfrog]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of name, month, and amphibian)
# e.g. if ida == 1 and january == 1 and bullfrog == 1, then Ida's pet is the bullfrog bought in January
ida, joann, nettie, ollie = names = intvar(1, 4, shape=4)
january, february, march, april = months = intvar(1, 4, shape=4)
bullfrog, horned_toad, tree_frog, wood_frog = amphibians = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
name_to_int = None  # N/A
month_to_int = {january: 1, february: 2, march: 3, april: 4}  # in months
amphibian_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def bought_after_than(var1, var2):
    """
    Formulate the constraint that var1 bought after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] > month_to_int[m2])
            for m1 in months for m2 in months]


def bought_exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 bought exactly diff months after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] == month_to_int[m2] + diff)
            for m1 in months for m2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(names)
m += AllDifferent(months)
m += AllDifferent(amphibians)

# Clue 1: The wood frog was bought 1 month after Nettie's pet:
m += bought_exactly_after_than(wood_frog, nettie, 1)

# Clue 2: Ollie's pet is the wood frog:
m += ollie == wood_frog

# Clue 3: The tree frog was bought 2 months after Ollie's pet:
m += bought_exactly_after_than(tree_frog, ollie, 2)

# Clue 4: Joann's pet is either the wood frog or the tree frog:
m += Xor([joann == wood_frog, joann == tree_frog])

# Clue 5: Ida's pet is either the animal bought in April or the bullfrog:
m += Xor([ida == april, ida == bullfrog])

```
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Winifred spoke for a somewhat shorter time than Omar.
Neal talked about Diocletian.
The four students were the presenter who spoke for 8 minutes, the student who gave the presentation on Galerius, Neal and Vickie.
The student who gave the presentation on Nero spoke 2 minutes more than Vickie.
Omar was either the presenter who gave the presentation on Nero or the presenter who spoke for 10 minutes.

Entities:
names: Neal, Omar, Vickie, Winifred
lengths: 6 minutes, 8 minutes, 10 minutes, 12 minutes
emperors: Diocletian, Galerius, Licinius, Nero
PARAM (145-146): 8
VAR (268-272): Nero
PARAM (279-280): 2
CONST_DIR (289-293): more
VAR (367-371): Nero
PARAM (403-405): 10
OBJ_NAME (458-466): Winifred
PARAM (477-478): 6
PARAM (489-490): 8
PARAM (501-503): 10
PARAM (514-516): 12
VAR (571-575): Nero

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Neal == 1, and Diocletian == 1, and 6Minutes == 1, then Neal talked about Diocletian for 6 minutes.

### Decision variables:
-   Names of the students: Neal, Omar, Vickie, Winifred (all different, 1 to 4)
-   Lengths of the presentations: 6 minutes, 8 minutes, 10 minutes, 12 minutes (all different, 1 to 4)
-   Emperors discussed: Diocletian, Galerius, Licinius, Nero (all different, 1 to 4)

### Constraints:
-   Winifred spoke for a somewhat shorter time than Omar:
    For this, we will need to add a constraint for each possible assignment of the lengths of Winifred and Omar's presentations, such that Winifred's presentation length is less than Omar's presentation length. So, the constraints will be of the form:
    l1 == Winifred and l2 == Omar => l1_to_int < l2_to_int, for all l1, l2 in lengths.

-   Neal talked about Diocletian:
    This is a direct assignment constraint:
    Neal == Diocletian.

-   The four students were the presenter who spoke for 8 minutes, the student who gave the presentation on Galerius, Neal, and Vickie:
    This is a constraint that states the four students who presented, thus:
    AllDifferent([8Minutes, Galerius, Neal, Vickie]).

-   The student who gave the presentation on Nero spoke 2 minutes more than Vickie:
    For this, we will need to add a constraint for each possible assignment of the lengths of the presentations for Nero and Vickie, such that Nero's presentation length is 2 more than Vickie's presentation length. So, the constraints will be of the form:
    l1 == Nero and l2 == Vickie => l1_to_int == l2_to_int + 2, for all l1, l2 in lengths.

-   Omar was either the presenter who gave the presentation on Nero or the presenter who spoke for 10 minutes:
    This is a constraint that states that Omar is either the presenter who gave the presentation on Nero or the presenter who spoke for 10 minutes, but not both. So:
    Xor([Omar == Nero, Omar == 10Minutes]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Neal == 1, and Diocletian == 1, and 6Minutes == 1, then Neal talked about Diocletian for 6 minutes.

### Decision variables:
-   Names of the students: Neal, Omar, Vickie, Winifred (all different, 1 to 4)
-   Lengths of the presentations: 6 minutes, 8 minutes, 10 minutes, 12 minutes (all different, 1 to 4)
-   Emperors discussed: Diocletian, Galerius, Licinius, Nero (all different, 1 to 4)

### Constraints:
-   Winifred spoke for a somewhat shorter time than Omar:
    For this, we will need to add a constraint for each possible assignment of the lengths of Winifred and Omar's presentations, such that Winifred's presentation length is less than Omar's presentation length. So, the constraints will be of the form:
    l1 == Winifred and l2 == Omar => l1_to_int < l2_to_int, for all l1, l2 in lengths.

-   Neal talked about Diocletian:
    This is a direct assignment constraint:
    Neal == Diocletian.

-   The four students were the presenter who spoke for 8 minutes, the student who gave the presentation on Galerius, Neal, and Vickie:
    This is a constraint that states the four students who presented, thus:
    AllDifferent([8Minutes, Galerius, Neal, Vickie]).

-   The student who gave the presentation on Nero spoke 2 minutes more than Vickie:
    For this, we will need to add a constraint for each possible assignment of the lengths of the presentations for Nero and Vickie, such that Nero's presentation length is 2 more than Vickie's presentation length. So, the constraints will be of the form:
    l1 == Nero and l2 == Vickie => l1_to_int == l2_to_int + 2, for all l1, l2 in lengths.

-   Omar was either the presenter who gave the presentation on Nero or the presenter who spoke for 10 minutes:
    This is a constraint that states that Omar is either the presenter who gave the presentation on Nero or the presenter who spoke for 10 minutes, but not both. So:
    Xor([Omar == Nero, Omar == 10Minutes]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of student, length, and emperor)
# e.g. if neal == 1 and diocletian == 1 and 6minutes == 1, then Neal talked about Diocletian for 6 minutes
neal, omar, vickie, winifred = students = intvar(1, 4, shape=4)
minutes6, minutes8, minutes10, minutes12 = lengths = intvar(1, 4, shape=4)
diocletian, galerius, licinius, nero = emperors = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
student_to_int = None  # N/A
length_to_int = {minutes6: 6, minutes8: 8, minutes10: 10, minutes12: 12}  # in minutes
emperor_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def shorter_than(var1, var2):
    """
    Formulate the constraint that var1 is shorter than var2.
    """
    return [((l1 == var1) & (l2 == var2)).implies(length_to_int[l1] < length_to_int[l2])
            for l1 in lengths for l2 in lengths]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(students)
m += AllDifferent(lengths)
m += AllDifferent(emperors)

# Clue 1: Winifred spoke for a somewhat shorter time than Omar:
m += shorter_than(winifred, omar)

# Clue 2: Neal talked about Diocletian:
m += neal == diocletian

# Clue 3: The four students were the presenter who spoke for 8 minutes, the student who gave the presentation on Galerius, Neal, and Vickie:
m += AllDifferent([minutes8, galerius, neal, vickie])

# Clue 4: The student who gave the presentation on Nero spoke 2 minutes more than Vickie:
m += [(nero == minutes10) & (vickie == minutes8) >> (length_to_int[nero] == length_to_int[vickie] + 2)]

# Clue 5: Omar was either the presenter who gave the presentation on Nero or the presenter who spoke for 10 minutes:
m += Xor([omar == nero, omar == minutes10])

```
Error: name 'IV6215' is not defined
False
False
Error: name 'IV6239' is not defined
---------------------------------------------------------------------------------------------

Clues:
Rosa paid somewhat more than the customer who got picked up at the Smith Tower.
The client with the $9 fare was picked up at the Smith Tower.
Neil paid 3 dollars more than Rosa.
The customer who got picked up at the Fremont Library was either the client with the $9 fare or Della.
The person with the $15 fare was picked up at the Neptune Theatre.

Entities:
customers: Della, Neil, Rosa, Sara
fares: $6, $9, $12, $15
pickup points: Arctic Building, Fremont Library, Neptune Theatre, Smith Tower
VAR (75-86): Smith Tower
PARAM (111-112): 9
VAR (139-150): Smith Tower
PARAM (163-164): 3
VAR (228-243): Fremont Library
PARAM (277-278): 9
PARAM (317-319): 15
VAR (346-361): Neptune Theatre
PARAM (424-425): 6
PARAM (430-431): 9
PARAM (436-438): 12
PARAM (443-445): 15
VAR (480-495): Fremont Library
VAR (516-521): Smith

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Della == 1, and $6 == 1, and ArcticBuilding == 1, then Della paid $6 and was picked up at the Arctic Building.

### Decision variables:
-   Names of the customers: Della, Neil, Rosa, Sara (all different, 1 to 4)
-   Fares paid: $6, $9, $12, $15 (all different, 1 to 4)
-   Pickup points: ArcticBuilding, FremontLibrary, NeptuneTheatre, SmithTower (all different, 1 to 4)

### Constraints:
-   Rosa paid somewhat more than the customer who got picked up at the Smith Tower:
    For this, we will need to add a constraint for each possible assignment of fares to Rosa and the customer picked up at the Smith Tower, such that Rosa's fare is greater than the fare of the customer picked up at the Smith Tower. So, the constraints will be of the form:
    f1 == Rosa and f2 == SmithTower => f1_to_int > f2_to_int, for all f1, f2 in fares.

-   The client with the $9 fare was picked up at the Smith Tower:
    This is a direct assignment constraint:
    $9 == SmithTower.

-   Neil paid 3 dollars more than Rosa:
    For this, we will need to add a constraint for each possible assignment of fares to Neil and Rosa, such that Neil's fare is 3 dollars more than Rosa's fare. So, the constraints will be of the form:
    f1 == Neil and f2 == Rosa => f1_to_int == f2_to_int + 3, for all f1, f2 in fares.

-   The customer who got picked up at the Fremont Library was either the client with the $9 fare or Della:
    This is a constraint that states that the customer picked up at the Fremont Library is either the one with the $9 fare or Della, but not both. So:
    Xor([FremontLibrary == $9, FremontLibrary == Della]).

-   The person with the $15 fare was picked up at the Neptune Theatre:
    This is a direct assignment constraint:
    $15 == NeptuneTheatre.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Della == 1, and $6 == 1, and ArcticBuilding == 1, then Della paid $6 and was picked up at the Arctic Building.

### Decision variables:
-   Names of the customers: Della, Neil, Rosa, Sara (all different, 1 to 4)
-   Fares paid: $6, $9, $12, $15 (all different, 1 to 4)
-   Pickup points: ArcticBuilding, FremontLibrary, NeptuneTheatre, SmithTower (all different, 1 to 4)

### Constraints:
-   Rosa paid somewhat more than the customer who got picked up at the Smith Tower:
    For this, we will need to add a constraint for each possible assignment of fares to Rosa and the customer picked up at the Smith Tower, such that Rosa's fare is greater than the fare of the customer picked up at the Smith Tower. So, the constraints will be of the form:
    f1 == Rosa and f2 == SmithTower => f1_to_int > f2_to_int, for all f1, f2 in fares.

-   The client with the $9 fare was picked up at the Smith Tower:
    This is a direct assignment constraint:
    $9 == SmithTower.

-   Neil paid 3 dollars more than Rosa:
    For this, we will need to add a constraint for each possible assignment of fares to Neil and Rosa, such that Neil's fare is 3 dollars more than Rosa's fare. So, the constraints will be of the form:
    f1 == Neil and f2 == Rosa => f1_to_int == f2_to_int + 3, for all f1, f2 in fares.

-   The customer who got picked up at the Fremont Library was either the client with the $9 fare or Della:
    This is a constraint that states that the customer picked up at the Fremont Library is either the one with the $9 fare or Della, but not both. So:
    Xor([FremontLibrary == $9, FremontLibrary == Della]).

-   The person with the $15 fare was picked up at the Neptune Theatre:
    This is a direct assignment constraint:
    $15 == NeptuneTheatre.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of customer, fare, and pickup point)
# e.g. if della == 1 and fare6 == 1 and arctic_building == 1, then Della paid $6 and was picked up at the Arctic Building
della, neil, rosa, sara = customers = intvar(1, 4, shape=4)
fare6, fare9, fare12, fare15 = fares = intvar(1, 4, shape=4)
arctic_building, fremont_library, neptune_theatre, smith_tower = pickup_points = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
customer_to_int = None  # N/A
fare_to_int = {fare6: 6, fare9: 9, fare12: 12, fare15: 15}  # in dollars
pickup_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def paid_more_than(var1, var2):
    """
    Formulate the constraint that var1 paid more than var2.
    """
    return [((f1 == var1) & (f2 == var2)).implies(fare_to_int[f1] > fare_to_int[f2])
            for f1 in fares for f2 in fares]


def paid_exactly_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 paid exactly diff dollars more than var2.
    """
    return [((f1 == var1) & (f2 == var2)).implies(fare_to_int[f1] == fare_to_int[f2] + diff)
            for f1 in fares for f2 in fares]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(customers)
m += AllDifferent(fares)
m += AllDifferent(pickup_points)

# Clue 1: Rosa paid somewhat more than the customer who got picked up at the Smith Tower:
m += paid_more_than(rosa, smith_tower)

# Clue 2: The client with the $9 fare was picked up at the Smith Tower:
m += fare9 == smith_tower

# Clue 3: Neil paid 3 dollars more than Rosa:
m += paid_exactly_more_than(neil, rosa, 3)

# Clue 4: The customer who got picked up at the Fremont Library was either the client with the $9 fare or Della:
m += Xor([fremont_library == fare9, fremont_library == della])

# Clue 5: The person with the $15 fare was picked up at the Neptune Theatre:
m += fare15 == neptune_theatre

```
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The facility scheduled to go online in 2019 is either the Egert Facility or the project headed by Dr. Alvarez.
The project headed by Dr. Morgan is either the Zynga Complex or the facility scheduled to go online in 2019.
The project headed by Dr. Salinas will go online 1 year before the Egert Facility.
The project headed by Dr. Alvarez will go online sometime after the project headed by Dr. Noble.
The project headed by Dr. Salinas will go online sometime before the project headed by Dr. Noble.
The project headed by Dr. Morgan will go online sometime after the Bale-Hahn SSC.

Entities:
names: Bale-Hahn SSC, Egert Facility, Lectra 4C, Zynga Complex
years: 2016, 2017, 2018, 2019
scientists: Dr. Alvarez, Dr. Morgan, Dr. Noble, Dr. Salinas
VAR (66-80): Egert Facility
VAR (167-180): Zynga Complex
VAR (297-311): Egert Facility
VAR (578-593): Bale - Hahn SSC
VAR (615-630): Bale - Hahn SSC
VAR (633-647): Egert Facility
PARAM (657-659): 4C

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if BaleHahnSSC == 1, and 2016 == 1, and DrAlvarez == 1, then Bale-Hahn SSC, scheduled to go online in 2016, is headed by Dr. Alvarez.

### Decision variables:
-   Names of the facilities: BaleHahnSSC, EgertFacility, Lectra4C, ZyngaComplex (all different, 1 to 4)
-   Years of going online: 2016, 2017, 2018, 2019 (all different, 1 to 4)
-   Names of the scientists: DrAlvarez, DrMorgan, DrNoble, DrSalinas (all different, 1 to 4)

### Constraints:
-   The facility scheduled to go online in 2019 is either the Egert Facility or the project headed by Dr. Alvarez:
    This is a constraint that states that the facility scheduled to go online in 2019 is either the Egert Facility or the project headed by Dr. Alvarez, but not both. So:
    Xor([2019 == EgertFacility, 2019 == DrAlvarez]).

-   The project headed by Dr. Morgan is either the Zynga Complex or the facility scheduled to go online in 2019:
    This is a constraint that states that the project headed by Dr. Morgan is either the Zynga Complex or the facility scheduled to go online in 2019, but not both. So:
    Xor([DrMorgan == ZyngaComplex, DrMorgan == 2019]).

-   The project headed by Dr. Salinas will go online 1 year before the Egert Facility:
    For this, we will need to add a constraint for each possible assignment of the years for the project headed by Dr. Salinas and the Egert Facility, such that Dr. Salinas's project's year is 1 less than the Egert Facility's year. So, the constraints will be of the form:
    y1 == DrSalinas and y2 == EgertFacility => y1_to_int == y2_to_int - 1, for all y1, y2 in years.

-   The project headed by Dr. Alvarez will go online sometime after the project headed by Dr. Noble:
    This is a constraint that states that the project headed by Dr. Alvarez will go online after the project headed by Dr. Noble, thus:
    DrAlvarez > DrNoble.

-   The project headed by Dr. Salinas will go online sometime before the project headed by Dr. Noble:
    This is a constraint that states that the project headed by Dr. Salinas will go online before the project headed by Dr. Noble, thus:
    DrSalinas < DrNoble.

-   The project headed by Dr. Morgan will go online sometime after the Bale-Hahn SSC:
    This is a constraint that states that the project headed by Dr. Morgan will go online after the Bale-Hahn SSC, thus:
    DrMorgan > BaleHahnSSC.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if BaleHahnSSC == 1, and 2016 == 1, and DrAlvarez == 1, then Bale-Hahn SSC, scheduled to go online in 2016, is headed by Dr. Alvarez.

### Decision variables:
-   Names of the facilities: BaleHahnSSC, EgertFacility, Lectra4C, ZyngaComplex (all different, 1 to 4)
-   Years of going online: 2016, 2017, 2018, 2019 (all different, 1 to 4)
-   Names of the scientists: DrAlvarez, DrMorgan, DrNoble, DrSalinas (all different, 1 to 4)

### Constraints:
-   The facility scheduled to go online in 2019 is either the Egert Facility or the project headed by Dr. Alvarez:
    This is a constraint that states that the facility scheduled to go online in 2019 is either the Egert Facility or the project headed by Dr. Alvarez, but not both. So:
    Xor([2019 == EgertFacility, 2019 == DrAlvarez]).

-   The project headed by Dr. Morgan is either the Zynga Complex or the facility scheduled to go online in 2019:
    This is a constraint that states that the project headed by Dr. Morgan is either the Zynga Complex or the facility scheduled to go online in 2019, but not both. So:
    Xor([DrMorgan == ZyngaComplex, DrMorgan == 2019]).

-   The project headed by Dr. Salinas will go online 1 year before the Egert Facility:
    For this, we will need to add a constraint for each possible assignment of the years for the project headed by Dr. Salinas and the Egert Facility, such that Dr. Salinas's project's year is 1 less than the Egert Facility's year. So, the constraints will be of the form:
    y1 == DrSalinas and y2 == EgertFacility => y1_to_int == y2_to_int - 1, for all y1, y2 in years.

-   The project headed by Dr. Alvarez will go online sometime after the project headed by Dr. Noble:
    This is a constraint that states that the project headed by Dr. Alvarez will go online after the project headed by Dr. Noble, thus:
    DrAlvarez > DrNoble.

-   The project headed by Dr. Salinas will go online sometime before the project headed by Dr. Noble:
    This is a constraint that states that the project headed by Dr. Salinas will go online before the project headed by Dr. Noble, thus:
    DrSalinas < DrNoble.

-   The project headed by Dr. Morgan will go online sometime after the Bale-Hahn SSC:
    This is a constraint that states that the project headed by Dr. Morgan will go online after the Bale-Hahn SSC, thus:
    DrMorgan > BaleHahnSSC.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of facility, year, and scientist)
# e.g. if bale_hahn == 1 and year_2016 == 1 and dr_alvarez == 1, then Bale-Hahn SSC, scheduled to go online in 2016, is headed by Dr. Alvarez
bale_hahn, egert, lectra, zynga = facilities = intvar(1, 4, shape=4)
year_2016, year_2017, year_2018, year_2019 = years = intvar(1, 4, shape=4)
dr_alvarez, dr_morgan, dr_noble, dr_salinas = scientists = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
facility_to_int = None  # N/A
year_to_int = {year_2016: 2016, year_2017: 2017, year_2018: 2018, year_2019: 2019}  # in years
scientist_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def online_before_than(var1, var2):
    """
    Formulate the constraint that var1 goes online before var2.
    """
    return [((f1 == var1) & (f2 == var2)).implies(year_to_int[f1] < year_to_int[f2])
            for f1 in years for f2 in years]


def online_exactly_before_than(var1, var2, diff):
    """
    Formulate the constraint that var1 goes online exactly diff years before var2.
    """
    return [((f1 == var1) & (f2 == var2)).implies(year_to_int[f1] == year_to_int[f2] - diff)
            for f1 in years for f2 in years]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(facilities)
m += AllDifferent(years)
m += AllDifferent(scientists)

# Clue 1: The facility scheduled to go online in 2019 is either the Egert Facility or the project headed by Dr. Alvarez:
m += Xor([year_2019 == egert, year_2019 == dr_alvarez])

# Clue 2: The project headed by Dr. Morgan is either the Zynga Complex or the facility scheduled to go online in 2019:
m += Xor([dr_morgan == zynga, dr_morgan == year_2019])

# Clue 3: The project headed by Dr. Salinas will go online 1 year before the Egert Facility:
m += online_exactly_before_than(dr_salinas, egert, 1)

# Clue 4: The project headed by Dr. Alvarez will go online sometime after the project headed by Dr. Noble:
m += dr_alvarez > dr_noble

# Clue 5: The project headed by Dr. Salinas will go online sometime before the project headed by Dr. Noble:
m += dr_salinas < dr_noble

# Clue 6: The project headed by Dr. Morgan will go online sometime after the Bale-Hahn SSC:
m += dr_morgan > bale_hahn

```
False
True
False
Wrong: 3, Total: 9
---------------------------------------------------------------------------------------------

Clues:
Lillian scored 6 points higher than Bessie.
The dancer who performed first scored 3 points lower than the dancer who performed ninth.
Verna scored somewhat higher than the person who danced third.
The dancer who performed seventh scored 6 points higher than the person who danced ninth.

Entities:
names: Bessie, Clara, Lillian, Verna
points: 181 points, 184 points, 187 points, 190 points
orders: first, third, seventh, ninth
PARAM (23-24): 6
VAR (78-83): first
PARAM (91-92): 3
VAR (136-141): ninth
VAR (200-205): third
VAR (233-240): seventh
PARAM (248-249): 6
VAR (291-296): ninth
OBJ_NAME (351-357): points
PARAM (360-363): 181
PARAM (373-376): 184
PARAM (386-389): 187
PARAM (399-402): 190
VAR (435-442): seventh
VAR (445-450): ninth

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Bessie == 1, and 181Points == 1, and First == 1, then Bessie scored 181 points and performed first.

### Decision variables:
-   Names of the dancers: Bessie, Clara, Lillian, Verna (all different, 1 to 4)
-   Points scored: 181 points, 184 points, 187 points, 190 points (all different, 1 to 4)
-   Orders of performance: First, Third, Seventh, Ninth (all different, 1 to 4)

### Constraints:
-   Lillian scored 6 points higher than Bessie:
    For this, we will need to add a constraint for each possible assignment of points for Lillian and Bessie, such that Lillian's points are 6 more than Bessie's points. So, the constraints will be of the form:
    p1 == Lillian and p2 == Bessie => p1_to_int == p2_to_int + 6, for all p1, p2 in points.

-   The dancer who performed first scored 3 points lower than the dancer who performed ninth:
    For this, we will need to add a constraint for each possible assignment of points for the dancer who performed first and the dancer who performed ninth, such that the first dancer's points are 3 less than the ninth dancer's points. So, the constraints will be of the form:
    p1 == First and p2 == Ninth => p1_to_int == p2_to_int - 3, for all p1, p2 in points.

-   Verna scored somewhat higher than the person who danced third:
    For this, we will need to add a constraint for each possible assignment of points for Verna and the person who danced third, such that Verna's points are somewhat higher than the third dancer's points. So, the constraints will be of the form:
    p1 == Verna and p2 == Third => p1_to_int > p2_to_int, for all p1, p2 in points.

-   The dancer who performed seventh scored 6 points higher than the person who danced ninth:
    For this, we will need to add a constraint for each possible assignment of points for the dancer who performed seventh and the dancer who danced ninth, such that the seventh dancer's points are 6 more than the ninth dancer's points. So, the constraints will be of the form:
    p1 == Seventh and p2 == Ninth => p1_to_int == p2_to_int + 6, for all p1, p2 in points.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Bessie == 1, and 181Points == 1, and First == 1, then Bessie scored 181 points and performed first.

### Decision variables:
-   Names of the dancers: Bessie, Clara, Lillian, Verna (all different, 1 to 4)
-   Points scored: 181 points, 184 points, 187 points, 190 points (all different, 1 to 4)
-   Orders of performance: First, Third, Seventh, Ninth (all different, 1 to 4)

### Constraints:
-   Lillian scored 6 points higher than Bessie:
    For this, we will need to add a constraint for each possible assignment of points for Lillian and Bessie, such that Lillian's points are 6 more than Bessie's points. So, the constraints will be of the form:
    p1 == Lillian and p2 == Bessie => p1_to_int == p2_to_int + 6, for all p1, p2 in points.

-   The dancer who performed first scored 3 points lower than the dancer who performed ninth:
    For this, we will need to add a constraint for each possible assignment of points for the dancer who performed first and the dancer who performed ninth, such that the first dancer's points are 3 less than the ninth dancer's points. So, the constraints will be of the form:
    p1 == First and p2 == Ninth => p1_to_int == p2_to_int - 3, for all p1, p2 in points.

-   Verna scored somewhat higher than the person who danced third:
    For this, we will need to add a constraint for each possible assignment of points for Verna and the person who danced third, such that Verna's points are somewhat higher than the third dancer's points. So, the constraints will be of the form:
    p1 == Verna and p2 == Third => p1_to_int > p2_to_int, for all p1, p2 in points.

-   The dancer who performed seventh scored 6 points higher than the person who danced ninth:
    For this, we will need to add a constraint for each possible assignment of points for the dancer who performed seventh and the dancer who danced ninth, such that the seventh dancer's points are 6 more than the ninth dancer's points. So, the constraints will be of the form:
    p1 == Seventh and p2 == Ninth => p1_to_int == p2_to_int + 6, for all p1, p2 in points.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of name, points, and order)
# e.g. if bessie == 1 and points181 == 1 and first == 1, then Bessie scored 181 points and performed first
bessie, clara, lillian, verna = names = intvar(1, 4, shape=4)
points181, points184, points187, points190 = points = intvar(1, 4, shape=4)
first, third, seventh, ninth = orders = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
name_to_int = None  # N/A
points_to_int = {points181: 181, points184: 184, points187: 187, points190: 190}  # in points
order_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def scored_higher_than(var1, var2, diff):
    """
    Formulate the constraint that var1 scored diff points higher than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(points_to_int[p1] == points_to_int[p2] + diff)
            for p1 in points for p2 in points]


def scored_lower_than(var1, var2, diff):
    """
    Formulate the constraint that var1 scored diff points lower than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(points_to_int[p1] == points_to_int[p2] - diff)
            for p1 in points for p2 in points]


def scored_higher_than_other(var1, var2):
    """
    Formulate the constraint that var1 scored higher than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(points_to_int[p1] > points_to_int[p2])
            for p1 in points for p2 in points]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(names)
m += AllDifferent(points)
m += AllDifferent(orders)

# Clue 1: Lillian scored 6 points higher than Bessie:
m += scored_higher_than(lillian, bessie, 6)

# Clue 2: The dancer who performed first scored 3 points lower than the dancer who performed ninth:
m += scored_lower_than(first, ninth, 3)

# Clue 3: Verna scored somewhat higher than the person who danced third:
m += scored_higher_than_other(verna, third)

# Clue 4: The dancer who performed seventh scored 6 points higher than the person who danced ninth:
m += scored_higher_than(seventh, ninth, 6)

```
True
True
True
Wrong: 0, Total: 7
---------------------------------------------------------------------------------------------

Clues:
Evan threw the orange darts.
The player who threw the violet darts scored 7 points higher than Ira.
Ira finished with 41 points.
The player who threw the white darts finished 14 points lower than Rudy.

Entities:
players: Evan, Ira, Rudy, Zachary
scores: 41, 48, 55, 62
colors: gray, orange, violet, white
VAR (23-35): orange darts
VAR (63-75): violet darts
PARAM (83-84): 7
OBJ_NAME (85-91): points
PARAM (128-130): 41
OBJ_NAME (131-137): points
VAR (165-176): white darts
PARAM (186-188): 14
OBJ_NAME (189-195): points
PARAM (272-274): 41
PARAM (277-279): 48
PARAM (282-284): 55
PARAM (287-289): 62

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Evan == 1, and OrangeDarts == 1, and 41 == 1, then Evan threw the orange darts and scored 41 points.

### Decision variables:
-   Names of the players: Evan, Ira, Rudy, Zachary (all different, 1 to 4)
-   Types of darts thrown: Gray, Orange, Violet, White (all different, 1 to 4)
-   Scores: 41, 48, 55, 62 (all different, 1 to 4)

### Constraints:
-   Evan threw the orange darts:
    This is a direct assignment constraint:
    Evan == OrangeDarts.

-   The player who threw the violet darts scored 7 points higher than Ira:
    For this, we will need to add a constraint for each possible assignment of scores for the player who threw the violet darts and Ira, such that the player who threw the violet darts scored 7 points higher than Ira. So, the constraints will be of the form:
    s1 == VioletDarts and s2 == Ira => s1_to_int == s2_to_int + 7, for all s1, s2 in scores.

-   Ira finished with 41 points:
    This is a direct assignment constraint:
    Ira == 41.

-   The player who threw the white darts finished 14 points lower than Rudy:
    For this, we will need to add a constraint for each possible assignment of scores for the player who threw the white darts and Rudy, such that the player who threw the white darts scored 14 points lower than Rudy. So, the constraints will be of the form:
    s1 == WhiteDarts and s2 == Rudy => s1_to_int == s2_to_int - 14, for all s1, s2 in scores.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Evan == 1, and OrangeDarts == 1, and 41 == 1, then Evan threw the orange darts and scored 41 points.

### Decision variables:
-   Names of the players: Evan, Ira, Rudy, Zachary (all different, 1 to 4)
-   Types of darts thrown: Gray, Orange, Violet, White (all different, 1 to 4)
-   Scores: 41, 48, 55, 62 (all different, 1 to 4)

### Constraints:
-   Evan threw the orange darts:
    This is a direct assignment constraint:
    Evan == OrangeDarts.

-   The player who threw the violet darts scored 7 points higher than Ira:
    For this, we will need to add a constraint for each possible assignment of scores for the player who threw the violet darts and Ira, such that the player who threw the violet darts scored 7 points higher than Ira. So, the constraints will be of the form:
    s1 == VioletDarts and s2 == Ira => s1_to_int == s2_to_int + 7, for all s1, s2 in scores.

-   Ira finished with 41 points:
    This is a direct assignment constraint:
    Ira == 41.

-   The player who threw the white darts finished 14 points lower than Rudy:
    For this, we will need to add a constraint for each possible assignment of scores for the player who threw the white darts and Rudy, such that the player who threw the white darts scored 14 points lower than Rudy. So, the constraints will be of the form:
    s1 == WhiteDarts and s2 == Rudy => s1_to_int == s2_to_int - 14, for all s1, s2 in scores.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of player, dart color, and score)
# e.g. if evan == 1 and orange == 1 and forty_one == 1, then Evan threw the orange darts and scored 41 points
evan, ira, rudy, zachary = players = intvar(1, 4, shape=4)
gray, orange, violet, white = darts = intvar(1, 4, shape=4)
forty_one, forty_eight, fifty_five, sixty_two = scores = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
player_to_int = None  # N/A
dart_to_int = None  # N/A
score_to_int = {forty_one: 41, forty_eight: 48, fifty_five: 55, sixty_two: 62}  # in points


# Helper functions (for formulating comparison constraints)
def scored_higher_than(var1, var2, diff):
    """
    Formulate the constraint that var1 scored diff points higher than var2.
    """
    return [((s1 == var1) & (s2 == var2)).implies(score_to_int[s1] == score_to_int[s2] + diff)
            for s1 in scores for s2 in scores]


def scored_lower_than(var1, var2, diff):
    """
    Formulate the constraint that var1 scored diff points lower than var2.
    """
    return [((s1 == var1) & (s2 == var2)).implies(score_to_int[s1] == score_to_int[s2] - diff)
            for s1 in scores for s2 in scores]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(players)
m += AllDifferent(darts)
m += AllDifferent(scores)

# Clue 1: Evan threw the orange darts:
m += evan == orange

# Clue 2: The player who threw the violet darts scored 7 points higher than Ira:
m += scored_higher_than(violet, ira, 7)

# Clue 3: Ira finished with 41 points:
m += ira == forty_one

# Clue 4: The player who threw the white darts finished 14 points lower than Rudy:
m += scored_lower_than(white, rudy, 14

```
Error: invalid syntax (<string>, line 1)
False
False
Error: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
The 200 page project is either the book published in 2011 or the book published in 2010.
The book published in 2011 is either Orlando's project or Jan's project.
The book published in 2007 is 25 pages shorter than the book published in 2002.
The four projects are the book published in 2007, the 225 page assignment, Suzanne's project and the 175 page assignment.
Jan's assignment is 175 pages long.

Entities:
translators: Ebony, Jan, Orlando, Suzanne
pages: 150 pages, 175 pages, 200 pages, 225 pages
years: 2002, 2007, 2010, 2011
LIMIT (12-15): 200
CONST_DIR (21-28): project
VAR (43-47): book
PARAM (61-65): 2011
VAR (73-77): book
PARAM (91-95): 2010
VAR (178-182): book
VAR (196-200): 2007
PARAM (204-206): 25
VAR (230-234): book
VAR (248-252): 2002
VAR (281-285): book
PARAM (299-303): 2007
PARAM (310-313): 225
VAR (332-339): Suzanne
PARAM (359-362): 175
VAR (381-384): Jan
PARAM (402-405): 175
PARAM (484-487): 150
PARAM (496-499): 175
PARAM (508-511): 200
PARAM (520-523): 225
PARAM (538-542): 2002
PARAM (545-549): 2007
PARAM (552-556): 2010
PARAM (559-563): 2011

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ebony == 1, and 150Pages == 1, and 2002 == 1, then Ebony's project is the book published in 2002 with 150 pages.

### Decision variables:
-   Names of the translators: Ebony, Jan, Orlando, Suzanne (all different, 1 to 4)
-   Number of pages: 150 pages, 175 pages, 200 pages, 225 pages (all different, 1 to 4)
-   Years of publication: 2002, 2007, 2010, 2011 (all different, 1 to 4)

### Constraints:
-   The 200 page project is either the book published in 2011 or the book published in 2010:
    This is a constraint that states that the 200 page project is either the book published in 2011 or the book published in 2010, but not both. So:
    Xor([200Pages == 2011, 200Pages == 2010]).

-   The book published in 2011 is either Orlando's project or Jan's project:
    This is a constraint that states that the book published in 2011 is either Orlando's project or Jan's project, but not both. So:
    Xor([2011 == Orlando, 2011 == Jan]).

-   The book published in 2007 is 25 pages shorter than the book published in 2002:
    For this, we will need to add a constraint for each possible assignment of the number of pages for the books published in 2007 and 2002, such that the book published in 2007 has 25 pages less than the book published in 2002. So, the constraints will be of the form:
    p1 == 2007 and p2 == 2002 => p1_to_int == p2_to_int - 25, for all p1, p2 in number of pages.

-   The four projects are the book published in 2007, the 225 page assignment, Suzanne's project, and the 175 page assignment:
    This is a constraint that states that the four projects are the book published in 2007, the 225 page assignment, Suzanne's project, and the 175 page assignment, thus:
    AllDifferent([2007, 225Pages, Suzanne, 175Pages]).

-   Jan's assignment is 175 pages long:
    This is a direct assignment constraint:
    Jan == 175Pages.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ebony == 1, and 150Pages == 1, and 2002 == 1, then Ebony's project is the book published in 2002 with 150 pages.

### Decision variables:
-   Names of the translators: Ebony, Jan, Orlando, Suzanne (all different, 1 to 4)
-   Number of pages: 150 pages, 175 pages, 200 pages, 225 pages (all different, 1 to 4)
-   Years of publication: 2002, 2007, 2010, 2011 (all different, 1 to 4)

### Constraints:
-   The 200 page project is either the book published in 2011 or the book published in 2010:
    This is a constraint that states that the 200 page project is either the book published in 2011 or the book published in 2010, but not both. So:
    Xor([200Pages == 2011, 200Pages == 2010]).

-   The book published in 2011 is either Orlando's project or Jan's project:
    This is a constraint that states that the book published in 2011 is either Orlando's project or Jan's project, but not both. So:
    Xor([2011 == Orlando, 2011 == Jan]).

-   The book published in 2007 is 25 pages shorter than the book published in 2002:
    For this, we will need to add a constraint for each possible assignment of the number of pages for the books published in 2007 and 2002, such that the book published in 2007 has 25 pages less than the book published in 2002. So, the constraints will be of the form:
    p1 == 2007 and p2 == 2002 => p1_to_int == p2_to_int - 25, for all p1, p2 in number of pages.

-   The four projects are the book published in 2007, the 225 page assignment, Suzanne's project, and the 175 page assignment:
    This is a constraint that states that the four projects are the book published in 2007, the 225 page assignment, Suzanne's project, and the 175 page assignment, thus:
    AllDifferent([2007, 225Pages, Suzanne, 175Pages]).

-   Jan's assignment is 175 pages long:
    This is a direct assignment constraint:
    Jan == 175Pages.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of translator, pages, and year)
# e.g. if ebony == 1 and pages150 == 1 and year2002 == 1, then Ebony's project is the book published in 2002 with 150 pages
ebony, jan, orlando, suzanne = translators = intvar(1, 4, shape=4)
pages150, pages175, pages200, pages225 = pages = intvar(1, 4, shape=4)
year2002, year2007, year2010, year2011 = years = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
translator_to_int = None  # N/A
pages_to_int = {pages150: 150, pages175: 175, pages200: 200, pages225: 225}  # in pages
year_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def shorter_than(var1, var2, diff):
    """
    Formulate the constraint that var1 is diff pages shorter than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(pages_to_int[p1] == pages_to_int[p2] - diff)
            for p1 in pages for p2 in pages]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(translators)
m += AllDifferent(pages)
m += AllDifferent(years)

# Clue 1: The 200 page project is either the book published in 2011 or the book published in 2010:
m += Xor([pages200 == year2011, pages200 == year2010])

# Clue 2: The book published in 2011 is either Orlando's project or Jan's project:
m += Xor([year2011 == orlando, year2011 == jan])

# Clue 3: The book published in 2007 is 25 pages shorter than the book published in 2002:
m += shorter_than(year2007, year2002, 25)

# Clue 4: The four projects are the book published in 2007, the 225 page assignment, Suzanne's project, and the 175 page assignment:
m += AllDifferent([year2007, pages225, suzanne, pages175])

# Clue 5: Jan's assignment is 175 pages long:
m += jan == pages175

```
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Mrs. Danielson's cake will be delivered 1 day before the order shaped like a sports car.
The order shaped like a turtle will be delivered 2 days before Mrs. Ingram's cake.
The cake shaped like a bowling pin is either the October 5 delivery or Mrs. Ingram's cake.
Mrs. Nolan's cake will be in the shape of a sports car.
The October 7 delivery will be in the shape of a bowling pin.

Entities:
customers: Danielson, Estrada, Ingram, Nolan
delivery dates: October 5, October 6, October 7, October 8
cake shapes: baseball glove, bowling pin, sports car, turtle
VAR (13-25): Danielson 's
PARAM (49-50): 1
VAR (86-96): sports car
VAR (123-129): turtle
PARAM (148-149): 2
VAR (162-166): Mrs.
VAR (167-176): Ingram 's
VAR (233-242): October 5
VAR (255-259): Mrs.
VAR (260-269): Ingram 's
VAR (277-281): Mrs.
VAR (282-290): Nolan 's
VAR (329-332): car
VAR (347-348): 7
PARAM (483-484): 5
PARAM (495-496): 6
PARAM (507-508): 7
PARAM (519-520): 8

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Danielson == 1, and October5 == 1, and BaseballGlove == 1, then Mrs. Danielson's baseball glove cake will be delivered on October 5.

### Decision variables:
-   Names of the customers: Danielson, Estrada, Ingram, Nolan (all different, 1 to 4)
-   Delivery dates: October5, October6, October7, October8 (all different, 1 to 4)
-   Cake shapes: BaseballGlove, BowlingPin, SportsCar, Turtle (all different, 1 to 4)

### Constraints:
-   Mrs. Danielson's cake will be delivered 1 day before the order shaped like a sports car:
    For this, we will need to add a constraint for each possible assignment of the delivery dates for Mrs. Danielson's cake and the sports car cake, such that Mrs. Danielson's cake delivery date is 1 less than the sports car cake delivery date. So, the constraints will be of the form:
    d1 == Danielson and d2 == SportsCar => d1_to_int == d2_to_int - 1, for all d1, d2 in delivery dates.

-   The order shaped like a turtle will be delivered 2 days before Mrs. Ingram's cake:
    For this, we will need to add a constraint for each possible assignment of the cake shapes for the turtle and Mrs. Ingram's cake, such that the turtle cake delivery date is 2 less than Mrs. Ingram's cake delivery date. So, the constraints will be of the form:
    c1 == Turtle and c2 == Ingram => c1_to_int == c2_to_int - 2, for all c1, c2 in cake shapes.

-   The cake shaped like a bowling pin is either the October 5 delivery or Mrs. Ingram's cake:
    This is a constraint that states that the cake shaped like a bowling pin is either delivered on October 5 or is Mrs. Ingram's cake, but not both. So:
    Xor([BowlingPin == October5, BowlingPin == Ingram]).

-   Mrs. Nolan's cake will be in the shape of a sports car:
    This is a direct assignment constraint:
    Nolan == SportsCar.

-   The October 7 delivery will be in the shape of a bowling pin:
    This is a direct assignment constraint:
    October7 == BowlingPin.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Danielson == 1, and October5 == 1, and BaseballGlove == 1, then Mrs. Danielson's baseball glove cake will be delivered on October 5.

### Decision variables:
-   Names of the customers: Danielson, Estrada, Ingram, Nolan (all different, 1 to 4)
-   Delivery dates: October5, October6, October7, October8 (all different, 1 to 4)
-   Cake shapes: BaseballGlove, BowlingPin, SportsCar, Turtle (all different, 1 to 4)

### Constraints:
-   Mrs. Danielson's cake will be delivered 1 day before the order shaped like a sports car:
    For this, we will need to add a constraint for each possible assignment of the delivery dates for Mrs. Danielson's cake and the sports car cake, such that Mrs. Danielson's cake delivery date is 1 less than the sports car cake delivery date. So, the constraints will be of the form:
    d1 == Danielson and d2 == SportsCar => d1_to_int == d2_to_int - 1, for all d1, d2 in delivery dates.

-   The order shaped like a turtle will be delivered 2 days before Mrs. Ingram's cake:
    For this, we will need to add a constraint for each possible assignment of the cake shapes for the turtle and Mrs. Ingram's cake, such that the turtle cake delivery date is 2 less than Mrs. Ingram's cake delivery date. So, the constraints will be of the form:
    c1 == Turtle and c2 == Ingram => c1_to_int == c2_to_int - 2, for all c1, c2 in cake shapes.

-   The cake shaped like a bowling pin is either the October 5 delivery or Mrs. Ingram's cake:
    This is a constraint that states that the cake shaped like a bowling pin is either delivered on October 5 or is Mrs. Ingram's cake, but not both. So:
    Xor([BowlingPin == October5, BowlingPin == Ingram]).

-   Mrs. Nolan's cake will be in the shape of a sports car:
    This is a direct assignment constraint:
    Nolan == SportsCar.

-   The October 7 delivery will be in the shape of a bowling pin:
    This is a direct assignment constraint:
    October7 == BowlingPin.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of customer, delivery date, and cake shape)
# e.g. if danielson == 1 and oct5 == 1 and baseball_glove == 1, then Mrs. Danielson's baseball glove cake will be delivered on October 5
danielson, estrada, ingram, nolan = customers = intvar(1, 4, shape=4)
oct5, oct6, oct7, oct8 = delivery_dates = intvar(1, 4, shape=4)
baseball_glove, bowling_pin, sports_car, turtle = cake_shapes = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
customer_to_int = None  # N/A
delivery_date_to_int = {oct5: 5, oct6: 6, oct7: 7, oct8: 8}  # in days
cake_shape_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def delivered_before_than(var1, var2):
    """
    Formulate the constraint that var1 delivered before var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(delivery_date_to_int[d1] < delivery_date_to_int[d2])
            for d1 in delivery_dates for d2 in delivery_dates]


def delivered_exactly_before_than(var1, var2, diff):
    """
    Formulate the constraint that var1 delivered exactly diff days before var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(delivery_date_to_int[d1] == delivery_date_to_int[d2] - diff)
            for d1 in delivery_dates for d2 in delivery_dates]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(customers)
m += AllDifferent(delivery_dates)
m += AllDifferent(cake_shapes)

# Clue 1: Mrs. Danielson's cake will be delivered 1 day before the order shaped like a sports car:
m += delivered_exactly_before_than(danielson, sports_car, 1)

# Clue 2: The order shaped like a turtle will be delivered 2 days before Mrs. Ingram's cake:
m += delivered_exactly_before_than(turtle, ingram, 2)

# Clue 3: The cake shaped like a bowling pin is either the October 5 delivery or Mrs. Ingram's cake:
m += Xor([bowling_pin == oct5, bowling_pin == ingram])

# Clue 4: Mrs. Nolan's cake will be in the shape of a sports car:
m += nolan == sports_car

# Clue 5: The October 7 delivery will be in the shape of a bowling pin:
m += oct7 == bowling_pin

```
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Of Ingram Arena and Noble Arena, one holds 150 people and the other is set up for rugby games.
The lacrosse facility holds 40 more people than Wilcox Arena.
Ingram Arena holds 230 people.
Wilcox Arena holds 80 fewer people than the soccer facility.

Entities:
arenas: Frederick, Ingram, Noble, Wilcox
capacities: 110, 150, 190, 230
sports: basketball, lacrosse, rugby, soccer
VAR (11-23): Ingram Arena
VAR (28-39): Noble Arena
PARAM (52-55): 150
VAR (109-126): lacrosse facility
PARAM (133-135): 40
VAR (153-165): Wilcox Arena
VAR (168-180): Ingram Arena
PARAM (187-190): 230
VAR (200-212): Wilcox Arena
PARAM (219-221): 80
PARAM (331-334): 110
PARAM (337-340): 150
PARAM (343-346): 190
PARAM (349-352): 230

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Frederick == 1, and 110 == 1, and basketball == 1, then Frederick Arena holds 110 people for basketball games.

### Decision variables:
-   Names of the arenas: Frederick, Ingram, Noble, Wilcox (all different, 1 to 4)
-   Capacities of the arenas: 110, 150, 190, 230 (all different, 1 to 4)
-   Sports played in the arenas: basketball, lacrosse, rugby, soccer (all different, 1 to 4)

### Constraints:
-   Of Ingram Arena and Noble Arena, one holds 150 people and the other is set up for rugby games:
    This is a constraint that states that one of the arenas holds 150 people and the other is set up for rugby games. So, the constraints will be:
    (Ingram == 150 and Noble == rugby) or (Ingram == rugby and Noble == 150).

-   The lacrosse facility holds 40 more people than Wilcox Arena:
    For this, we will need to add a constraint for each possible assignment of capacities for the lacrosse facility and Wilcox Arena, such that the lacrosse facility's capacity is 40 more than Wilcox Arena's capacity. So, the constraints will be of the form:
    c1 == lacrosse and c2 == Wilcox => c1_to_int == c2_to_int + 40, for all c1, c2 in capacities.

-   Ingram Arena holds 230 people:
    This is a direct assignment constraint:
    Ingram == 230.

-   Wilcox Arena holds 80 fewer people than the soccer facility:
    For this, we will need to add a constraint for each possible assignment of capacities for Wilcox Arena and the soccer facility, such that Wilcox Arena's capacity is 80 fewer than the soccer facility's capacity. So, the constraints will be of the form:
    c1 == Wilcox and c2 == soccer => c1_to_int == c2_to_int - 80, for all c1, c2 in capacities.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Frederick == 1, and 110 == 1, and basketball == 1, then Frederick Arena holds 110 people for basketball games.

### Decision variables:
-   Names of the arenas: Frederick, Ingram, Noble, Wilcox (all different, 1 to 4)
-   Capacities of the arenas: 110, 150, 190, 230 (all different, 1 to 4)
-   Sports played in the arenas: basketball, lacrosse, rugby, soccer (all different, 1 to 4)

### Constraints:
-   Of Ingram Arena and Noble Arena, one holds 150 people and the other is set up for rugby games:
    This is a constraint that states that one of the arenas holds 150 people and the other is set up for rugby games. So, the constraints will be:
    (Ingram == 150 and Noble == rugby) or (Ingram == rugby and Noble == 150).

-   The lacrosse facility holds 40 more people than Wilcox Arena:
    For this, we will need to add a constraint for each possible assignment of capacities for the lacrosse facility and Wilcox Arena, such that the lacrosse facility's capacity is 40 more than Wilcox Arena's capacity. So, the constraints will be of the form:
    c1 == lacrosse and c2 == Wilcox => c1_to_int == c2_to_int + 40, for all c1, c2 in capacities.

-   Ingram Arena holds 230 people:
    This is a direct assignment constraint:
    Ingram == 230.

-   Wilcox Arena holds 80 fewer people than the soccer facility:
    For this, we will need to add a constraint for each possible assignment of capacities for Wilcox Arena and the soccer facility, such that Wilcox Arena's capacity is 80 fewer than the soccer facility's capacity. So, the constraints will be of the form:
    c1 == Wilcox and c2 == soccer => c1_to_int == c2_to_int - 80, for all c1, c2 in capacities.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of arena, capacity, and sport)
# e.g. if frederick == 1 and capacity110 == 1 and basketball == 1, then Frederick Arena holds 110 people for basketball games
frederick, ingram, noble, wilcox = arenas = intvar(1, 4, shape=4)
capacity110, capacity150, capacity190, capacity230 = capacities = intvar(1, 4, shape=4)
basketball, lacrosse, rugby, soccer = sports = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
arena_to_int = None  # N/A
capacity_to_int = {capacity110: 110, capacity150: 150, capacity190: 190, capacity230: 230}  # in people
sport_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def holds_people_and_sport(var1, var2, people, sport):
    """
    Formulate the constraint that var1 holds people and var2 is set up for a specific sport.
    """
    return [((a1 == var1) & (a2 == var2)).implies((capacity_to_int[a1] == people) & (a2 == sport))
            for a1 in capacities for a2 in sports]


def holds_more_people_than(var1, var2, diff):
    """
    Formulate the constraint that var1 holds more people than var2 by a specific difference.
    """
    return [((c1 == var1) & (c2 == var2)).implies(capacity_to_int[c1] == capacity_to_int[c2] + diff)
            for c1 in capacities for c2 in capacities]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(arenas)
m += AllDifferent(capacities)
m += AllDifferent(sports)

# Clue 1: Of Ingram Arena and Noble Arena, one holds 150 people and the other is set up for rugby games:
m += (holds_people_and_sport(ingram, noble, 150, rugby) | holds_people_and_sport(ingram, noble, rugby, 150))

# Clue 2: The lacrosse facility holds 40 more people than Wilcox Arena:
m += holds_more_people_than(lacrosse, wilcox, 40)

# Clue 3: Ingram Arena holds 230 people:
m += ingram == capacity230

# Clue 4: Wilcox Arena holds 80 fewer people than the soccer facility:
m += holds_more_people_than(soccer, wilcox, 80)

```
Error: invalid syntax (<string>, line 1)
False
False
Error: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
The $35,000 structure is 15 sq ft smaller than the $29,000 home.
The Whitehead's structure sold for $29,000.
The Kirby's house is 15 sq ft smaller than the $35,000 house.
The $36,000 house is somewhat smaller than the Gillespie's structure.
Of the 110 sq ft home and the 140 sq ft home, one sold for $35,000 and the other is for the Gillespies.

Entities:
customers: Gillespie, Kirby, Pratt, Whitehead
sq footage: 95 sq ft, 110 sq ft, 125 sq ft, 140 sq ft
prices: $25,000, $29,000, $35,000, $36,000
PARAM (14-20): 35,000
PARAM (34-36): 15
PARAM (62-68): 29,000
VAR (80-89): Whitehead
PARAM (114-120): 29,000
VAR (127-135): Kirby 's
PARAM (145-147): 15
PARAM (173-179): 35,000
PARAM (194-200): 36,000
VAR (236-248): Gillespie 's
LIMIT (268-271): 110
LIMIT (291-294): 140
PARAM (323-329): 35,000
VAR (355-365): Gillespies
VAR (403-408): Kirby
VAR (419-428): Whitehead
PARAM (442-444): 95
PARAM (453-456): 110
PARAM (465-468): 125
PARAM (477-480): 140
PARAM (498-504): 25,000
PARAM (509-515): 29,000
PARAM (520-526): 35,000
PARAM (531-537): 36,000

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Gillespie == 1, and 110sqft == 1, and $35,000 == 1, then Gillespie's structure with 110 sq ft was sold for $35,000.

### Decision variables:
-   Names of the customers: Gillespie, Kirby, Pratt, Whitehead (all different, 1 to 4)
-   Square footage of the homes: 95 sq ft, 110 sq ft, 125 sq ft, 140 sq ft (all different, 1 to 4)
-   Prices of the homes: $25,000, $29,000, $35,000, $36,000 (all different, 1 to 4)

### Constraints:
-   The $35,000 structure is 15 sq ft smaller than the $29,000 home:
    For this, we will need to add a constraint for each possible assignment of prices to the $35,000 structure and the $29,000 home, such that the $35,000 structure is 15 sq ft smaller than the $29,000 home. So, the constraints will be of the form:
    p1 == $35,000 and p2 == $29,000 => p1_to_int == p2_to_int - 15, for all p1, p2 in prices.

-   The Whitehead's structure sold for $29,000:
    This is a direct assignment constraint:
    Whitehead == $29,000.

-   The Kirby's house is 15 sq ft smaller than the $35,000 house:
    For this, we will need to add a constraint for each possible assignment of prices to the Kirby's house and the $35,000 house, such that the Kirby's house is 15 sq ft smaller than the $35,000 house. So, the constraints will be of the form:
    p1 == Kirby and p2 == $35,000 => p1_to_int == p2_to_int - 15, for all p1, p2 in prices.

-   The $36,000 house is somewhat smaller than the Gillespie's structure:
    This is a constraint that states that the $36,000 house is smaller than the Gillespie's structure, thus:
    Gillespie == $36,000.

-   Of the 110 sq ft home and the 140 sq ft home, one sold for $35,000 and the other is for the Gillespies:
    This is a constraint that states that one of the homes with 110 sq ft and 140 sq ft was sold for $35,000 and the other belongs to the Gillespies. So, we need to add constraints to represent this relationship.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Gillespie == 1, and 110sqft == 1, and $35,000 == 1, then Gillespie's structure with 110 sq ft was sold for $35,000.

### Decision variables:
-   Names of the customers: Gillespie, Kirby, Pratt, Whitehead (all different, 1 to 4)
-   Square footage of the homes: 95 sq ft, 110 sq ft, 125 sq ft, 140 sq ft (all different, 1 to 4)
-   Prices of the homes: $25,000, $29,000, $35,000, $36,000 (all different, 1 to 4)

### Constraints:
-   The $35,000 structure is 15 sq ft smaller than the $29,000 home:
    For this, we will need to add a constraint for each possible assignment of prices to the $35,000 structure and the $29,000 home, such that the $35,000 structure is 15 sq ft smaller than the $29,000 home. So, the constraints will be of the form:
    p1 == $35,000 and p2 == $29,000 => p1_to_int == p2_to_int - 15, for all p1, p2 in prices.

-   The Whitehead's structure sold for $29,000:
    This is a direct assignment constraint:
    Whitehead == $29,000.

-   The Kirby's house is 15 sq ft smaller than the $35,000 house:
    For this, we will need to add a constraint for each possible assignment of prices to the Kirby's house and the $35,000 house, such that the Kirby's house is 15 sq ft smaller than the $35,000 house. So, the constraints will be of the form:
    p1 == Kirby and p2 == $35,000 => p1_to_int == p2_to_int - 15, for all p1, p2 in prices.

-   The $36,000 house is somewhat smaller than the Gillespie's structure:
    This is a constraint that states that the $36,000 house is smaller than the Gillespie's structure, thus:
    Gillespie == $36,000.

-   Of the 110 sq ft home and the 140 sq ft home, one sold for $35,000 and the other is for the Gillespies:
    This is a constraint that states that one of the homes with 110 sq ft and 140 sq ft was sold for $35,000 and the other belongs to the Gillespies. So, we need to add constraints to represent this relationship.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of customer, sq footage, and price)
# e.g. if gillespie == 1 and sq110 == 1 and price35k == 1, then Gillespie's structure with 110 sq ft was sold for $35,000
gillespie, kirby, pratt, whitehead = customers = intvar(1, 4, shape=4)
sq95, sq110, sq125, sq140 = sq_footage = intvar(1, 4, shape=4)
price25k, price29k, price35k, price36k = prices = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
customer_to_int = None  # N/A
sq_footage_to_int = {sq95: 95, sq110: 110, sq125: 125, sq140: 140}  # in sq ft
price_to_int = {price25k: 25000, price29k: 29000, price35k: 35000, price36k: 36000}  # in dollars


# Helper functions (for formulating comparison constraints)
def smaller_by_than(var1, var2, diff):
    """
    Formulate the constraint that var1 is smaller than var2 by diff sq ft.
    """
    return [((v1 == var1) & (v2 == var2)).implies(sq_footage_to_int[v1] == sq_footage_to_int[v2] - diff)
            for v1 in sq_footage for v2 in sq_footage]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(customers)
m += AllDifferent(sq_footage)
m += AllDifferent(prices)

# Clue 1: The $35,000 structure is 15 sq ft smaller than the $29,000 home:
m += smaller_by_than(price35k, price29k, 15)

# Clue 2: The Whitehead's structure sold for $29,000:
m += whitehead == price29k

# Clue 3: The Kirby's house is 15 sq ft smaller than the $35,000 house:
m += smaller_by_than(kirby, price35k, 15)

# Clue 4: The $36,000 house is somewhat smaller than the Gillespie's structure:
m += gillespie == price36k

# Clue 5: Of the 110 sq ft home and the 140 sq ft home, one sold for $35,000 and the other is for the Gillespies:
m += ((sq110 == price35k) & (sq140 == gillespie)) | ((sq110 == gillespie) & (sq140 == price35k)

```
Error: invalid syntax (<string>, line 1)
False
False
Error: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
The Nielsen's house is 30 sq ft larger than the $35,000 structure.
The 125 sq ft home is either the Whitehead's home or the $32,250 home.
The Whitehead's house sold for $29,000.
The Ewing's home sold for $32,250.
The $29,000 house is somewhat smaller than the $32,250 structure.

Entities:
customers: Ewing, Kirby, Nielsen, Whitehead
sq footage: 95 sq ft, 110 sq ft, 125 sq ft, 140 sq ft
prices: $27,500, $29,000, $32,250, $35,000
VAR (12-28): Nielsen 's house
PARAM (32-34): 30
PARAM (59-65): 35,000
LIMIT (82-85): 125
VAR (111-128): Whitehead 's home
PARAM (138-144): 32,250
VAR (156-174): Whitehead 's house
OBJ_NAME (175-179): sold
PARAM (186-192): 29,000
VAR (199-212): Ewing 's home
OBJ_NAME (213-217): sold
PARAM (224-230): 32,250
PARAM (239-245): 29,000
PARAM (283-289): 32,250
VAR (351-360): Whitehead
PARAM (374-376): 95
PARAM (385-388): 110
PARAM (397-400): 125
PARAM (409-412): 140
PARAM (430-436): 27,500
PARAM (441-447): 29,000
PARAM (452-458): 32,250
PARAM (463-469): 35,000

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ewing == 1, and 95sqft == 1, and $27,500 == 1, then Ewing's home with 95 sq ft was sold for $27,500.

### Decision variables:
-   Names of the customers: Ewing, Kirby, Nielsen, Whitehead (all different, 1 to 4)
-   Square footage of the homes: 95 sq ft, 110 sq ft, 125 sq ft, 140 sq ft (all different, 1 to 4)
-   Prices of the homes: $27,500, $29,000, $32,250, $35,000 (all different, 1 to 4)

### Constraints:
-   The Nielsen's house is 30 sq ft larger than the $35,000 structure:
    For this, we will need to add a constraint for each possible assignment of square footage for Nielsen's house and the $35,000 structure, such that Nielsen's house's square footage is 30 sq ft larger than the $35,000 structure's square footage. So, the constraints will be of the form:
    sq1 == Nielsen and sq2 == $35,000 => sq1_to_int == sq2_to_int + 30, for all sq1, sq2 in square footage.

-   The 125 sq ft home is either the Whitehead's home or the $32,250 home:
    This is a constraint that states that the 125 sq ft home is either Whitehead's home or the $32,250 home, but not both. So:
    Xor([125sqft == Whitehead, 125sqft == $32,250]).

-   The Whitehead's house sold for $29,000:
    This is a direct assignment constraint:
    Whitehead == $29,000.

-   The Ewing's home sold for $32,250:
    This is a direct assignment constraint:
    Ewing == $32,250.

-   The $29,000 house is somewhat smaller than the $32,250 structure:
    For this, we will need to add a constraint for each possible assignment of prices for the $29,000 house and the $32,250 structure, such that the $29,000 house is somewhat smaller than the $32,250 structure. So, the constraints will be of the form:
    price1 == $29,000 and price2 == $32,250 => price1_to_int < price2_to_int, for all price1, price2 in prices.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ewing == 1, and 95sqft == 1, and $27,500 == 1, then Ewing's home with 95 sq ft was sold for $27,500.

### Decision variables:
-   Names of the customers: Ewing, Kirby, Nielsen, Whitehead (all different, 1 to 4)
-   Square footage of the homes: 95 sq ft, 110 sq ft, 125 sq ft, 140 sq ft (all different, 1 to 4)
-   Prices of the homes: $27,500, $29,000, $32,250, $35,000 (all different, 1 to 4)

### Constraints:
-   The Nielsen's house is 30 sq ft larger than the $35,000 structure:
    For this, we will need to add a constraint for each possible assignment of square footage for Nielsen's house and the $35,000 structure, such that Nielsen's house's square footage is 30 sq ft larger than the $35,000 structure's square footage. So, the constraints will be of the form:
    sq1 == Nielsen and sq2 == $35,000 => sq1_to_int == sq2_to_int + 30, for all sq1, sq2 in square footage.

-   The 125 sq ft home is either the Whitehead's home or the $32,250 home:
    This is a constraint that states that the 125 sq ft home is either Whitehead's home or the $32,250 home, but not both. So:
    Xor([125sqft == Whitehead, 125sqft == $32,250]).

-   The Whitehead's house sold for $29,000:
    This is a direct assignment constraint:
    Whitehead == $29,000.

-   The Ewing's home sold for $32,250:
    This is a direct assignment constraint:
    Ewing == $32,250.

-   The $29,000 house is somewhat smaller than the $32,250 structure:
    For this, we will need to add a constraint for each possible assignment of prices for the $29,000 house and the $32,250 structure, such that the $29,000 house is somewhat smaller than the $32,250 structure. So, the constraints will be of the form:
    price1 == $29,000 and price2 == $32,250 => price1_to_int < price2_to_int, for all price1, price2 in prices.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of customer, sq footage, and price)
# e.g. if ewing == 1 and sq95 == 1 and price27500 == 1, then Ewing's home with 95 sq ft was sold for $27,500
ewing, kirby, nielsen, whitehead = customers = intvar(1, 4, shape=4)
sq95, sq110, sq125, sq140 = sq_footage = intvar(1, 4, shape=4)
price27500, price29000, price32250, price35000 = prices = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
customer_to_int = None  # N/A
sq_footage_to_int = {sq95: 95, sq110: 110, sq125: 125, sq140: 140}  # in sq ft
price_to_int = {price27500: 27500, price29000: 29000, price32250: 32250, price35000: 35000}  # in dollars


# Helper functions (for formulating comparison constraints)
def larger_than(var1, var2, diff):
    """
    Formulate the constraint that var1 is diff sq ft larger than var2.
    """
    return [((s1 == var1) & (s2 == var2)).implies(sq_footage_to_int[s1] == sq_footage_to_int[s2] + diff)
            for s1 in sq_footage for s2 in sq_footage]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(customers)
m += AllDifferent(sq_footage)
m += AllDifferent(prices)

# Clue 1: The Nielsen's house is 30 sq ft larger than the $35,000 structure:
m += larger_than(nielsen, price35000, 30)

# Clue 2: The 125 sq ft home is either the Whitehead's home or the $32,250 home:
m += Xor([sq125 == whitehead, sq125 == price32250])

# Clue 3: The Whitehead's house sold for $29,000:
m += whitehead == price29000

# Clue 4: The Ewing's home sold for $32,250:
m += ewing == price32250

# Clue 5: The $29,000 house is somewhat smaller than the $32,250 structure:
m += price29000 < price32250

```
True
False
False
Wrong: 1, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Paulette's pair was a size 7.
Estelle's pair was by Cormano.
The Manzarita footwear was either the size 4 set or Whitney's pair.
Of Lucia's pair and the Schtillet footwear, one was a size 7 and the other was a size 6.

Entities:
customers: Estelle, Lucia, Paulette, Whitney
shoe sizes: 4, 5, 6, 7
brands: Cormano, Manzarita, Schtillet, Williford
VAR (8-24): Paulette 's pair
PARAM (36-37): 7
VAR (40-50): Estelle 's
VAR (77-95): Manzarita footwear
PARAM (116-117): 4
VAR (125-140): Whitney 's pair
VAR (146-159): Lucia 's pair
VAR (168-186): Schtillet footwear
PARAM (204-205): 7
PARAM (231-232): 6
VAR (258-265): Estelle
VAR (276-284): Paulette
VAR (287-299): Whitney shoe
PARAM (308-309): 4
PARAM (312-313): 5
PARAM (316-317): 6
PARAM (320-321): 7
VAR (341-350): Manzarita
VAR (353-362): Schtillet

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Estelle == 1, and Size7 == 1, and Cormano == 1, then Estelle's pair is size 7 and by Cormano.

### Decision variables:
-   Names of the customers: Estelle, Lucia, Paulette, Whitney (all different, 1 to 4)
-   Shoe sizes: Size4, Size5, Size6, Size7 (all different, 1 to 4)
-   Brands of the shoes: Cormano, Manzarita, Schtillet, Williford (all different, 1 to 4)

### Constraints:
-   Paulette's pair was a size 7:
    This is a direct assignment constraint:
    Paulette == Size7.

-   Estelle's pair was by Cormano:
    This is a direct assignment constraint:
    Estelle == Cormano.

-   The Manzarita footwear was either the size 4 set or Whitney's pair:
    This is a constraint that states that the Manzarita footwear is either size 4 or Whitney's pair, but not both. So:
    Xor([Manzarita == Size4, Manzarita == Whitney]).

-   Of Lucia's pair and the Schtillet footwear, one was a size 7 and the other was a size 6:
    This is a constraint that states that Lucia's pair is size 7 and Schtillet footwear is size 6, or vice versa. So:
    (Lucia == Size7 and Schtillet == Size6) or (Lucia == Size6 and Schtillet == Size7).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Estelle == 1, and Size7 == 1, and Cormano == 1, then Estelle's pair is size 7 and by Cormano.

### Decision variables:
-   Names of the customers: Estelle, Lucia, Paulette, Whitney (all different, 1 to 4)
-   Shoe sizes: Size4, Size5, Size6, Size7 (all different, 1 to 4)
-   Brands of the shoes: Cormano, Manzarita, Schtillet, Williford (all different, 1 to 4)

### Constraints:
-   Paulette's pair was a size 7:
    This is a direct assignment constraint:
    Paulette == Size7.

-   Estelle's pair was by Cormano:
    This is a direct assignment constraint:
    Estelle == Cormano.

-   The Manzarita footwear was either the size 4 set or Whitney's pair:
    This is a constraint that states that the Manzarita footwear is either size 4 or Whitney's pair, but not both. So:
    Xor([Manzarita == Size4, Manzarita == Whitney]).

-   Of Lucia's pair and the Schtillet footwear, one was a size 7 and the other was a size 6:
    This is a constraint that states that Lucia's pair is size 7 and Schtillet footwear is size 6, or vice versa. So:
    (Lucia == Size7 and Schtillet == Size6) or (Lucia == Size6 and Schtillet == Size7).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of customer, shoe size, and brand)
# e.g. if estelle == 1 and size7 == 1 and cormano == 1, then Estelle's pair is size 7 and by Cormano
estelle, lucia, paulette, whitney = customers = intvar(1, 4, shape=4)
size4, size5, size6, size7 = shoe_sizes = intvar(1, 4, shape=4)
cormano, manzarita, schtillet, williford = brands = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
customer_to_int = None  # N/A
size_to_int = {size4: 4, size5: 5, size6: 6, size7: 7}  # in sizes
brand_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def pair_size(var1, var2, size1, size2):
    """
    Formulate the constraint that var1's pair is size1 and var2's pair is size2.
    """
    return [(var1 == size1) & (var2 == size2) | (var1 == size2) & (var2 == size1)]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(customers)
m += AllDifferent(shoe_sizes)
m += AllDifferent(brands)

# Clue 1: Paulette's pair was a size 7:
m += paulette == size7

# Clue 2: Estelle's pair was by Cormano:
m += estelle == cormano

# Clue 3: The Manzarita footwear was either the size 4 set or Whitney's pair:
m += Xor([manzarita == size4, manzarita == whitney])

# Clue 4: Of Lucia's pair and the Schtillet footwear, one was a size 7 and the other was a size 6:
m += pair_size(lucia, schtillet, size7, size6)

```
True
True
True
Wrong: 1, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The project on the Serenity starts 1 month after Stacy's project.
Darryl's project starts 1 month after Gene's assignment.
The study beginning in April is either the study on the Liberty or the project on the Pegasus.
Lauren's project is on the Pegasus.

Entities:
students: Darryl, Gene, Lauren, Stacy
months: March, April, May, June
ships: Liberty, Osprey, Pegasus, Serenity
VAR (27-35): Serenity
VAR (192-199): Liberty
VAR (222-229): Pegasus
VAR (260-267): Pegasus
OBJ_NAME (396-404): Serenity

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Darryl == 1, and March == 1, and Liberty == 1, then Darryl's project starts in March on the Liberty.

### Decision variables:
-   Names of the students: Darryl, Gene, Lauren, Stacy (all different, 1 to 4)
-   Months of project start: March, April, May, June (all different, 1 to 4)
-   Names of the ships: Liberty, Osprey, Pegasus, Serenity (all different, 1 to 4)

### Constraints:
-   The project on the Serenity starts 1 month after Stacy's project:
    For this, we will need to add a constraint for each possible assignment of the months for Stacy's project and the project on the Serenity, such that the project on the Serenity starts 1 month after Stacy's project. So, the constraints will be of the form:
    m1 == Stacy and m2 == Serenity => m1_to_int + 1 == m2_to_int, for all m1, m2 in months.

-   Darryl's project starts 1 month after Gene's assignment:
    For this, we will need to add a constraint for each possible assignment of the months for Darryl's project and Gene's assignment, such that Darryl's project starts 1 month after Gene's assignment. So, the constraints will be of the form:
    m1 == Darryl and m2 == Gene => m1_to_int == m2_to_int + 1, for all m1, m2 in months.

-   The study beginning in April is either the study on the Liberty or the project on the Pegasus:
    This is a constraint that states that the study beginning in April is either on the Liberty or the Pegasus, but not both. So:
    Xor([April == Liberty, April == Pegasus]).

-   Lauren's project is on the Pegasus:
    This is a direct assignment constraint:
    Lauren == Pegasus.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Darryl == 1, and March == 1, and Liberty == 1, then Darryl's project starts in March on the Liberty.

### Decision variables:
-   Names of the students: Darryl, Gene, Lauren, Stacy (all different, 1 to 4)
-   Months of project start: March, April, May, June (all different, 1 to 4)
-   Names of the ships: Liberty, Osprey, Pegasus, Serenity (all different, 1 to 4)

### Constraints:
-   The project on the Serenity starts 1 month after Stacy's project:
    For this, we will need to add a constraint for each possible assignment of the months for Stacy's project and the project on the Serenity, such that the project on the Serenity starts 1 month after Stacy's project. So, the constraints will be of the form:
    m1 == Stacy and m2 == Serenity => m1_to_int + 1 == m2_to_int, for all m1, m2 in months.

-   Darryl's project starts 1 month after Gene's assignment:
    For this, we will need to add a constraint for each possible assignment of the months for Darryl's project and Gene's assignment, such that Darryl's project starts 1 month after Gene's assignment. So, the constraints will be of the form:
    m1 == Darryl and m2 == Gene => m1_to_int == m2_to_int + 1, for all m1, m2 in months.

-   The study beginning in April is either the study on the Liberty or the project on the Pegasus:
    This is a constraint that states that the study beginning in April is either on the Liberty or the Pegasus, but not both. So:
    Xor([April == Liberty, April == Pegasus]).

-   Lauren's project is on the Pegasus:
    This is a direct assignment constraint:
    Lauren == Pegasus.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of student, month, and ship)
# e.g. if darryl == 1 and march == 1 and liberty == 1, then Darryl's project starts in March on the Liberty
darryl, gene, lauren, stacy = students = intvar(1, 4, shape=4)
march, april, may, june = months = intvar(1, 4, shape=4)
liberty, osprey, pegasus, serenity = ships = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
student_to_int = None  # N/A
month_to_int = {march: 1, april: 2, may: 3, june: 4}  # in months
ship_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def starts_after_than(var1, var2):
    """
    Formulate the constraint that var1 starts after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] > month_to_int[m2])
            for m1 in months for m2 in months]


def starts_exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 starts exactly diff months after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] == month_to_int[m2] + diff)
            for m1 in months for m2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(students)
m += AllDifferent(months)
m += AllDifferent(ships)

# Clue 1: The project on the Serenity starts 1 month after Stacy's project:
m += starts_exactly_after_than(stacy, serenity, -1)

# Clue 2: Darryl's project starts 1 month after Gene's assignment:
m += starts_exactly_after_than(darryl, gene, 1)

# Clue 3: The study beginning in April is either the study on the Liberty or the project on the Pegasus:
m += Xor([april == liberty, april == pegasus])

# Clue 4: Lauren's project is on the Pegasus:
m += lauren == pegasus

```
True
True
True
Wrong: 0, Total: 7
---------------------------------------------------------------------------------------------

Clues:
Zimmerman is from the Wolverines.
The person from the Ice Hogs scored 1 goal less than the player from the Wolverines.
Klein had 9 goals this season.
The player from the Checkers scored 1 goal more than Walls.

Entities:
players: Klein, Underwood, Walls, Zimmerman
goals: 6, 7, 8, 9
teams: Checkers, Comets, Ice Hogs, Wolverines
VAR (63-71): Ice Hogs
PARAM (79-80): 1
VAR (116-126): Wolverines
LIMIT (139-140): 9
VAR (181-189): Checkers
PARAM (197-198): 1
PARAM (289-290): 6
PARAM (293-294): 7
PARAM (297-298): 8
PARAM (301-302): 9
VAR (331-339): Ice Hogs
VAR (342-352): Wolverines

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Klein == 1, and Checkers == 1, and 9 == 1, then Klein from the Checkers team scored 9 goals this season.

### Decision variables:
-   Names of the players: Klein, Underwood, Walls, Zimmerman (all different, 1 to 4)
-   Number of goals: 6, 7, 8, 9 (all different, 1 to 4)
-   Teams: Checkers, Comets, Ice Hogs, Wolverines (all different, 1 to 4)

### Constraints:
-   Zimmerman is from the Wolverines:
    This is a direct assignment constraint:
    Zimmerman == Wolverines.

-   The person from the Ice Hogs scored 1 goal less than the player from the Wolverines:
    For this, we will need to add a constraint for each possible assignment of goals for the players from the Ice Hogs and the Wolverines, such that the Ice Hogs player's goals are 1 less than the Wolverines player's goals. So, the constraints will be of the form:
    g1 == IceHogs and g2 == Wolverines => g1_to_int == g2_to_int - 1, for all g1, g2 in goals.

-   Klein had 9 goals this season:
    This is a direct assignment constraint:
    Klein == 9.

-   The player from the Checkers scored 1 goal more than Walls:
    For this, we will need to add a constraint for each possible assignment of goals for the players from the Checkers and Walls, such that the Checkers player's goals are 1 more than Walls' goals. So, the constraints will be of the form:
    g1 == Checkers and g2 == Walls => g1_to_int == g2_to_int + 1, for all g1, g2 in goals.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Klein == 1, and Checkers == 1, and 9 == 1, then Klein from the Checkers team scored 9 goals this season.

### Decision variables:
-   Names of the players: Klein, Underwood, Walls, Zimmerman (all different, 1 to 4)
-   Number of goals: 6, 7, 8, 9 (all different, 1 to 4)
-   Teams: Checkers, Comets, Ice Hogs, Wolverines (all different, 1 to 4)

### Constraints:
-   Zimmerman is from the Wolverines:
    This is a direct assignment constraint:
    Zimmerman == Wolverines.

-   The person from the Ice Hogs scored 1 goal less than the player from the Wolverines:
    For this, we will need to add a constraint for each possible assignment of goals for the players from the Ice Hogs and the Wolverines, such that the Ice Hogs player's goals are 1 less than the Wolverines player's goals. So, the constraints will be of the form:
    g1 == IceHogs and g2 == Wolverines => g1_to_int == g2_to_int - 1, for all g1, g2 in goals.

-   Klein had 9 goals this season:
    This is a direct assignment constraint:
    Klein == 9.

-   The player from the Checkers scored 1 goal more than Walls:
    For this, we will need to add a constraint for each possible assignment of goals for the players from the Checkers and Walls, such that the Checkers player's goals are 1 more than Walls' goals. So, the constraints will be of the form:
    g1 == Checkers and g2 == Walls => g1_to_int == g2_to_int + 1, for all g1, g2 in goals.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of player, goal, and team)
# e.g. if klein == 1 and 9 == 1 and checkers == 1, then Klein from the Checkers team scored 9 goals this season
klein, underwood, walls, zimmerman = players = intvar(1, 4, shape=4)
goals6, goals7, goals8, goals9 = goals = intvar(1, 4, shape=4)
checkers, comets, ice_hogs, wolverines = teams = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
player_to_int = None  # N/A
goal_to_int = {goals6: 6, goals7: 7, goals8: 8, goals9: 9}  # in goals
team_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def scored_less_than(var1, var2):
    """
    Formulate the constraint that var1 scored 1 goal less than var2.
    """
    return [((g1 == var1) & (g2 == var2)).implies(goal_to_int[g1] == goal_to_int[g2] - 1)
            for g1 in goals for g2 in goals]


def scored_more_than(var1, var2):
    """
    Formulate the constraint that var1 scored 1 goal more than var2.
    """
    return [((g1 == var1) & (g2 == var2)).implies(goal_to_int[g1] == goal_to_int[g2] + 1)
            for g1 in goals for g2 in goals]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(players)
m += AllDifferent(goals)
m += AllDifferent(teams)

# Clue 1: Zimmerman is from the Wolverines:
m += zimmerman == wolverines

# Clue 2: The person from the Ice Hogs scored 1 goal less than the player from the Wolverines:
m += scored_less_than(ice_hogs, wolverines)

# Clue 3: Klein had 9 goals this season:
m += klein == goals9

# Clue 4: The player from the Checkers scored 1 goal more than Walls:
m += scored_more_than(checkers, walls

```
Error: invalid syntax (<string>, line 1)
False
False
Error: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
Of the bird bought in February and the bird bought in January, one is Gladys's and the other is the macaw.
The macaw was bought 2 months before Ellen's pet.
The parakeet was bought 1 month after the finch.
Alberta's pet was bought 1 month before Gladys's pet.
The finch was bought sometime after the lovebird.

Entities:
names: Alberta, Della, Ellen, Gladys
months: January, February, March, April
birds: finch, lovebird, macaw, parakeet
VAR (15-19): bird
VAR (47-51): bird
VAR (79-85): Gladys
VAR (110-115): macaw
VAR (122-127): macaw
PARAM (139-140): 2
VAR (174-182): parakeet
PARAM (194-195): 1
VAR (212-217): finch
VAR (220-227): Alberta
PARAM (246-247): 1
VAR (261-267): Gladys
VAR (281-286): finch
VAR (317-325): lovebird
VAR (432-437): finch
VAR (440-448): lovebird
VAR (451-456): macaw
VAR (459-467): parakeet

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Alberta == 1, and January == 1, and Finch == 1, then Alberta's pet, a finch, was bought in January.

### Decision variables:
-   Names of the owners: Alberta, Della, Ellen, Gladys (all different, 1 to 4)
-   Months of purchase: January, February, March, April (all different, 1 to 4)
-   Types of birds: Finch, Lovebird, Macaw, Parakeet (all different, 1 to 4)

### Constraints:
-   Of the bird bought in February and the bird bought in January, one is Gladys's and the other is the macaw:
    This is a constraint that states that one of the birds bought in February and January is Gladys's, and the other is the macaw. So, we need to add constraints to ensure this:
    (bird == February and bird == Gladys) != (bird == January and bird == Macaw).

-   The macaw was bought 2 months before Ellen's pet:
    For this, we will need to add a constraint for each possible assignment of the months of purchase for the macaw and Ellen's pet, such that the macaw's month of purchase is 2 less than Ellen's pet's month of purchase. So, the constraints will be of the form:
    m1 == Macaw and m2 == Ellen => m1_to_int == m2_to_int - 2, for all m1, m2 in months of purchase.

-   The parakeet was bought 1 month after the finch:
    For this, we will need to add a constraint for each possible assignment of the months of purchase for the parakeet and the finch, such that the parakeet's month of purchase is 1 more than the finch's month of purchase. So, the constraints will be of the form:
    m1 == Parakeet and m2 == Finch => m1_to_int == m2_to_int + 1, for all m1, m2 in months of purchase.

-   Alberta's pet was bought 1 month before Gladys's pet:
    For this, we will need to add a constraint for each possible assignment of the months of purchase for Alberta's pet and Gladys's pet, such that Alberta's pet's month of purchase is 1 less than Gladys's pet's month of purchase. So, the constraints will be of the form:
    m1 == Alberta and m2 == Gladys => m1_to_int == m2_to_int - 1, for all m1, m2 in months of purchase.

-   The finch was bought sometime after the lovebird:
    This is a constraint that states that the finch was bought after the lovebird, thus:
    Finch > Lovebird.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Alberta == 1, and January == 1, and Finch == 1, then Alberta's pet, a finch, was bought in January.

### Decision variables:
-   Names of the owners: Alberta, Della, Ellen, Gladys (all different, 1 to 4)
-   Months of purchase: January, February, March, April (all different, 1 to 4)
-   Types of birds: Finch, Lovebird, Macaw, Parakeet (all different, 1 to 4)

### Constraints:
-   Of the bird bought in February and the bird bought in January, one is Gladys's and the other is the macaw:
    This is a constraint that states that one of the birds bought in February and January is Gladys's, and the other is the macaw. So, we need to add constraints to ensure this:
    (bird == February and bird == Gladys) != (bird == January and bird == Macaw).

-   The macaw was bought 2 months before Ellen's pet:
    For this, we will need to add a constraint for each possible assignment of the months of purchase for the macaw and Ellen's pet, such that the macaw's month of purchase is 2 less than Ellen's pet's month of purchase. So, the constraints will be of the form:
    m1 == Macaw and m2 == Ellen => m1_to_int == m2_to_int - 2, for all m1, m2 in months of purchase.

-   The parakeet was bought 1 month after the finch:
    For this, we will need to add a constraint for each possible assignment of the months of purchase for the parakeet and the finch, such that the parakeet's month of purchase is 1 more than the finch's month of purchase. So, the constraints will be of the form:
    m1 == Parakeet and m2 == Finch => m1_to_int == m2_to_int + 1, for all m1, m2 in months of purchase.

-   Alberta's pet was bought 1 month before Gladys's pet:
    For this, we will need to add a constraint for each possible assignment of the months of purchase for Alberta's pet and Gladys's pet, such that Alberta's pet's month of purchase is 1 less than Gladys's pet's month of purchase. So, the constraints will be of the form:
    m1 == Alberta and m2 == Gladys => m1_to_int == m2_to_int - 1, for all m1, m2 in months of purchase.

-   The finch was bought sometime after the lovebird:
    This is a constraint that states that the finch was bought after the lovebird, thus:
    Finch > Lovebird.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of owner, month, and bird)
# e.g. if alberta == 1 and january == 1 and finch == 1, then Alberta's pet, a finch, was bought in January
alberta, della, ellen, gladys = owners = intvar(1, 4, shape=4)
january, february, march, april = months = intvar(1, 4, shape=4)
finch, lovebird, macaw, parakeet = birds = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
owner_to_int = None  # N/A
month_to_int = {january: 1, february: 2, march: 3, april: 4}  # in months
bird_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def bought_before_than(var1, var2):
    """
    Formulate the constraint that var1 bought before var2.
    """
    return [((o1 == var1) & (o2 == var2)).implies(month_to_int[o1] < month_to_int[o2])
            for o1 in months for o2 in months]


def bought_exactly_before_than(var1, var2, diff):
    """
    Formulate the constraint that var1 bought exactly diff months before var2.
    """
    return [((o1 == var1) & (o2 == var2)).implies(month_to_int[o1] == month_to_int[o2] - diff)
            for o1 in months for o2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(owners)
m += AllDifferent(months)
m += AllDifferent(birds)

# Clue 1: Of the bird bought in February and the bird bought in January, one is Gladys's and the other is the macaw:
m += ((february == gladys) & (february == macaw)) != ((january == gladys) & (january == macaw))

# Clue 2: The macaw was bought 2 months before Ellen's pet:
m += bought_exactly_before_than(macaw, ellen, 2)

# Clue 3: The parakeet was bought 1 month after the finch:
m += bought_exactly_before_than(parakeet, finch, 1)

# Clue 4: Alberta's pet was bought 1 month before Gladys's pet:
m += bought_exactly_before_than(alberta, gladys, 1)

# Clue 5: The finch was bought sometime after the lovebird:
m += finch > lovebird

```
False
False
False
Wrong: 3, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The Tevatron LHC is either the facility scheduled to go online in 2019 or the accelerator scheduled to go online in 2016.
Of the project headed by Dr. Baldwin and the project headed by Dr. Quinn, one is the Falston LCS and the other will go online in 2017.
The project headed by Dr. Ewing will go online sometime before the Zynga Complex.
Of the project headed by Dr. Ewing and the facility scheduled to go online in 2018, one is the Egert Facility and the other is the Tevatron LHC.
The Zynga Complex is headed by Dr. Baldwin.

Entities:
names: Egert Facility, Falston LCS, Tevatron LHC, Zynga Complex
years: 2016, 2017, 2018, 2019
scientists: Dr. Baldwin, Dr. Ewing, Dr. Kirk, Dr. Quinn
VAR (12-24): Tevatron LHC
PARAM (74-78): 2019
PARAM (124-128): 2016
VAR (217-228): Falston LCS
PARAM (261-265): 2017
VAR (335-348): Zynga Complex
PARAM (429-433): 2018
VAR (447-461): Egert Facility
VAR (483-495): Tevatron LHC
VAR (502-515): Zynga Complex
VAR (562-576): Egert Facility
VAR (579-590): Falston LCS
VAR (593-605): Tevatron LHC
OBJ_NAME (608-613): Zynga
PARAM (630-634): 2016
PARAM (637-641): 2017
PARAM (644-648): 2018
PARAM (651-655): 2019

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if EgertFacility == 1, and 2016 == 1, and DrBaldwin == 1, then the Egert Facility project headed by Dr. Baldwin will go online in 2016.

### Decision variables:
-   Names of the projects/facilities: EgertFacility, FalstonLCS, TevatronLHC, ZyngaComplex (all different, 1 to 4)
-   Years of going online: 2016, 2017, 2018, 2019 (all different, 1 to 4)
-   Names of the scientists: DrBaldwin, DrEwing, DrKirk, DrQuinn (all different, 1 to 4)

### Constraints:
-   The Tevatron LHC is either the facility scheduled to go online in 2019 or the accelerator scheduled to go online in 2016:
    This is a constraint that states that the Tevatron LHC's year of going online is either 2019 or 2016, but not both. So:
    Xor([TevatronLHC == 2019, TevatronLHC == 2016]).

-   Of the project headed by Dr. Baldwin and the project headed by Dr. Quinn, one is the Falston LCS and the other will go online in 2017:
    This is a constraint that states that one of the projects headed by Dr. Baldwin and Dr. Quinn is the Falston LCS and the other will go online in 2017. So:
    Xor([DrBaldwin == FalstonLCS and DrQuinn == 2017, DrBaldwin == 2017 and DrQuinn == FalstonLCS]).

-   The project headed by Dr. Ewing will go online sometime before the Zynga Complex:
    For this, we will need to add a constraint for each possible assignment of the years for Dr. Ewing's project and the Zynga Complex, such that Dr. Ewing's project's year of going online is less than the Zynga Complex's year of going online. So, the constraints will be of the form:
    y1 == DrEwing and y2 == ZyngaComplex => y1_to_int < y2_to_int, for all y1, y2 in years.

-   Of the project headed by Dr. Ewing and the facility scheduled to go online in 2018, one is the Egert Facility and the other is the Tevatron LHC:
    This is a constraint that states that one of the projects headed by Dr. Ewing and the facility scheduled to go online in 2018 is the Egert Facility and the other is the Tevatron LHC. So:
    Xor([DrEwing == EgertFacility and 2018 == TevatronLHC, DrEwing == TevatronLHC and 2018 == EgertFacility]).

-   The Zynga Complex is headed by Dr. Baldwin:
    This is a direct assignment constraint:
    ZyngaComplex == DrBaldwin.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if EgertFacility == 1, and 2016 == 1, and DrBaldwin == 1, then the Egert Facility project headed by Dr. Baldwin will go online in 2016.

### Decision variables:
-   Names of the projects/facilities: EgertFacility, FalstonLCS, TevatronLHC, ZyngaComplex (all different, 1 to 4)
-   Years of going online: 2016, 2017, 2018, 2019 (all different, 1 to 4)
-   Names of the scientists: DrBaldwin, DrEwing, DrKirk, DrQuinn (all different, 1 to 4)

### Constraints:
-   The Tevatron LHC is either the facility scheduled to go online in 2019 or the accelerator scheduled to go online in 2016:
    This is a constraint that states that the Tevatron LHC's year of going online is either 2019 or 2016, but not both. So:
    Xor([TevatronLHC == 2019, TevatronLHC == 2016]).

-   Of the project headed by Dr. Baldwin and the project headed by Dr. Quinn, one is the Falston LCS and the other will go online in 2017:
    This is a constraint that states that one of the projects headed by Dr. Baldwin and Dr. Quinn is the Falston LCS and the other will go online in 2017. So:
    Xor([DrBaldwin == FalstonLCS and DrQuinn == 2017, DrBaldwin == 2017 and DrQuinn == FalstonLCS]).

-   The project headed by Dr. Ewing will go online sometime before the Zynga Complex:
    For this, we will need to add a constraint for each possible assignment of the years for Dr. Ewing's project and the Zynga Complex, such that Dr. Ewing's project's year of going online is less than the Zynga Complex's year of going online. So, the constraints will be of the form:
    y1 == DrEwing and y2 == ZyngaComplex => y1_to_int < y2_to_int, for all y1, y2 in years.

-   Of the project headed by Dr. Ewing and the facility scheduled to go online in 2018, one is the Egert Facility and the other is the Tevatron LHC:
    This is a constraint that states that one of the projects headed by Dr. Ewing and the facility scheduled to go online in 2018 is the Egert Facility and the other is the Tevatron LHC. So:
    Xor([DrEwing == EgertFacility and 2018 == TevatronLHC, DrEwing == TevatronLHC and 2018 == EgertFacility]).

-   The Zynga Complex is headed by Dr. Baldwin:
    This is a direct assignment constraint:
    ZyngaComplex == DrBaldwin.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of project/facility, year, and scientist)
# e.g. if egert == 1 and year2016 == 1 and baldwin == 1, then the Egert Facility project headed by Dr. Baldwin will go online in 2016
egert, falston, tevatron, zynga = projects = intvar(1, 4, shape=4)
year2016, year2017, year2018, year2019 = years = intvar(1, 4, shape=4)
baldwin, ewing, kirk, quinn = scientists = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
project_to_int = None  # N/A
year_to_int = {year2016: 2016, year2017: 2017, year2018: 2018, year2019: 2019}  # in years
scientist_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def online_after_than(var1, var2):
    """
    Formulate the constraint that var1 goes online after var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(year_to_int[p1] > year_to_int[p2])
            for p1 in years for p2 in years]


def online_exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 goes online exactly diff years after var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(year_to_int[p1] == year_to_int[p2] + diff)
            for p1 in years for p2 in years]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(projects)
m += AllDifferent(years)
m += AllDifferent(scientists)

# Clue 1: The Tevatron LHC is either the facility scheduled to go online in 2019 or the accelerator scheduled to go online in 2016:
m += Xor([tevatron == year2019, tevatron == year2016])

# Clue 2: Of the project headed by Dr. Baldwin and the project headed by Dr. Quinn, one is the Falston LCS and the other will go online in 2017:
m += Xor([baldwin == falston and quinn == year2017, baldwin == year2017 and quinn == falston])

# Clue 3: The project headed by Dr. Ewing will go online sometime before the Zynga Complex:
m += online_after_than(ewing, zynga)

# Clue 4: Of the project headed by Dr. Ewing and the facility scheduled to go online in 2018, one is the Egert Facility and the other is the Tevatron LHC:
m += Xor([ewing == egert and year2018 == tevatron, ewing == tevatron and year2018 == egert])

# Clue 5: The Zynga Complex is headed by Dr. Baldwin:
m += zynga == baldwin

```
False
False
False
Wrong: 3, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The 2004 holiday is either the skydiving holiday or the holiday with Yvonne.
Of the kayaking holiday and the trip with Isabel, one was in 2001 and the other was in 2004.
The vacation with Andy was after the trip with Yvonne.
The holiday with Bill was 1 year after the trip with Andy.
The cycling trip was before the hunting vacation.

Entities:
friends: Andy, Bill, Isabel, Yvonne
years: 2001, 2002, 2003, 2004
activities: cycling, hunting, kayaking, skydiving
VAR (39-56): skydiving holiday
VAR (64-76): holiday with
VAR (77-83): Yvonne
VAR (102-109): holiday
VAR (199-203): Andy
VAR (228-234): Yvonne
VAR (241-258): holiday with Bill
PARAM (263-264): 1
VAR (290-294): Andy
PARAM (428-432): 2004
VAR (477-486): skydiving

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Andy == 1, and 2004 == 1, and cycling == 1, then Andy went on a cycling trip in 2004.

### Decision variables:
-   Names of the friends: Andy, Bill, Isabel, Yvonne (all different, 1 to 4)
-   Years of the holidays: 2001, 2002, 2003, 2004 (all different, 1 to 4)
-   Activities of the holidays: cycling, hunting, kayaking, skydiving (all different, 1 to 4)

### Constraints:
-   The 2004 holiday is either the skydiving holiday or the holiday with Yvonne:
    This is a constraint that states that the 2004 holiday is either the skydiving holiday or the holiday with Yvonne, but not both. So:
    Xor([2004 == skydiving, 2004 == Yvonne]).

-   Of the kayaking holiday and the trip with Isabel, one was in 2001 and the other was in 2004:
    This is a constraint that states that one of the kayaking holiday and the trip with Isabel was in 2001 and the other was in 2004. So:
    (kayaking == 2001 and Isabel == 2004) or (kayaking == 2004 and Isabel == 2001).

-   The vacation with Andy was after the trip with Yvonne:
    For this, we will need to add a constraint for each possible assignment of the years for Andy and Yvonne, such that Andy's vacation year is greater than Yvonne's trip year. So, the constraints will be of the form:
    y1 == Andy and y2 == Yvonne => y1_to_int > y2_to_int, for all y1, y2 in years.

-   The holiday with Bill was 1 year after the trip with Andy:
    For this, we will need to add a constraint for each possible assignment of the years for Bill and Andy, such that Bill's holiday year is 1 more than Andy's trip year. So, the constraints will be of the form:
    y1 == Bill and y2 == Andy => y1_to_int == y2_to_int + 1, for all y1, y2 in years.

-   The cycling trip was before the hunting vacation:
    This is a constraint that states that the cycling trip was before the hunting vacation, thus:
    cycling < hunting.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Andy == 1, and 2004 == 1, and cycling == 1, then Andy went on a cycling trip in 2004.

### Decision variables:
-   Names of the friends: Andy, Bill, Isabel, Yvonne (all different, 1 to 4)
-   Years of the holidays: 2001, 2002, 2003, 2004 (all different, 1 to 4)
-   Activities of the holidays: cycling, hunting, kayaking, skydiving (all different, 1 to 4)

### Constraints:
-   The 2004 holiday is either the skydiving holiday or the holiday with Yvonne:
    This is a constraint that states that the 2004 holiday is either the skydiving holiday or the holiday with Yvonne, but not both. So:
    Xor([2004 == skydiving, 2004 == Yvonne]).

-   Of the kayaking holiday and the trip with Isabel, one was in 2001 and the other was in 2004:
    This is a constraint that states that one of the kayaking holiday and the trip with Isabel was in 2001 and the other was in 2004. So:
    (kayaking == 2001 and Isabel == 2004) or (kayaking == 2004 and Isabel == 2001).

-   The vacation with Andy was after the trip with Yvonne:
    For this, we will need to add a constraint for each possible assignment of the years for Andy and Yvonne, such that Andy's vacation year is greater than Yvonne's trip year. So, the constraints will be of the form:
    y1 == Andy and y2 == Yvonne => y1_to_int > y2_to_int, for all y1, y2 in years.

-   The holiday with Bill was 1 year after the trip with Andy:
    For this, we will need to add a constraint for each possible assignment of the years for Bill and Andy, such that Bill's holiday year is 1 more than Andy's trip year. So, the constraints will be of the form:
    y1 == Bill and y2 == Andy => y1_to_int == y2_to_int + 1, for all y1, y2 in years.

-   The cycling trip was before the hunting vacation:
    This is a constraint that states that the cycling trip was before the hunting vacation, thus:
    cycling < hunting.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of friend, year, and activity)
# e.g. if andy == 1 and year2004 == 1 and skydiving == 1, then Andy went on a skydiving holiday in 2004
andy, bill, isabel, yvonne = friends = intvar(1, 4, shape=4)
year2001, year2002, year2003, year2004 = years = intvar(1, 4, shape=4)
cycling, hunting, kayaking, skydiving = activities = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
friend_to_int = None  # N/A
year_to_int = {year2001: 2001, year2002: 2002, year2003: 2003, year2004: 2004}  # in years
activity_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def after_than(var1, var2):
    """
    Formulate the constraint that var1 is after var2.
    """
    return [((f1 == var1) & (f2 == var2)).implies(year_to_int[f1] > year_to_int[f2])
            for f1 in years for f2 in years]


def exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 is exactly diff years after var2.
    """
    return [((f1 == var1) & (f2 == var2)).implies(year_to_int[f1] == year_to_int[f2] + diff)
            for f1 in years for f2 in years]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(friends)
m += AllDifferent(years)
m += AllDifferent(activities)

# Clue 1: The 2004 holiday is either the skydiving holiday or the holiday with Yvonne:
m += Xor([year2004 == skydiving, year2004 == yvonne])

# Clue 2: Of the kayaking holiday and the trip with Isabel, one was in 2001 and the other was in 2004:
m += ((kayaking == year2001) & (isabel == year2004)) | ((kayaking == year2004) & (isabel == year2001))

# Clue 3: The vacation with Andy was after the trip with Yvonne:
m += after_than(andy, yvonne)

# Clue 4: The holiday with Bill was 1 year after the trip with Andy:
m += exactly_after_than(bill, andy, 1)

# Clue 5: The cycling trip was before the hunting vacation:
m += cycling < hunting

```
False
True
False
Wrong: 2, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Ginger was either the person who paid $160 or Vicki's client.
Beulah paid 10 dollars more than Yvonne's client.
Hannah paid less than Debra.
Vicki's client paid more than Debra.
Debra paid less than Pam's client.

Entities:
clients: Beulah, Debra, Ginger, Hannah
prices: $150, $160, $170, $180
masseuses: Lynda, Pam, Vicki, Yvonne
VAR (8-14): Ginger
PARAM (48-51): 160
VAR (55-60): Vicki
VAR (73-79): Beulah
PARAM (85-87): 10
VAR (106-112): Yvonne
VAR (125-131): Hannah
VAR (147-152): Debra
VAR (155-160): Vicki
VAR (186-191): Debra
VAR (194-199): Debra
VAR (252-258): Beulah
VAR (261-266): Debra
VAR (269-275): Ginger
VAR (278-284): Hannah
PARAM (296-299): 150
PARAM (304-307): 160
PARAM (312-315): 170
PARAM (320-323): 180

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Beulah == 1, and Price150 == 1, and Lynda == 1, then Beulah paid $150 to Lynda.

### Decision variables:
-   Names of the clients: Beulah, Debra, Ginger, Hannah (all different, 1 to 4)
-   Prices paid by the clients: Price150, Price160, Price170, Price180 (all different, 1 to 4)
-   Names of the masseuses: Lynda, Pam, Vicki, Yvonne (all different, 1 to 4)

### Constraints:
-   Ginger was either the person who paid $160 or Vicki's client:
    This is a constraint that states that Ginger's price is either $160 or the price of Vicki's client, but not both. So:
    Xor([Ginger == Price160, Ginger == Vicki]).

-   Beulah paid 10 dollars more than Yvonne's client:
    For this, we will need to add a constraint for each possible assignment of prices to Beulah and Yvonne's client, such that Beulah's price is 10 dollars more than Yvonne's client's price. So, the constraints will be of the form:
    p1 == Beulah and p2 == Yvonne => p1_to_int == p2_to_int + 10, for all p1, p2 in prices.

-   Hannah paid less than Debra:
    This is a constraint that states that Hannah's price is less than Debra's price, thus:
    Hannah_to_int < Debra_to_int.

-   Vicki's client paid more than Debra:
    This is a constraint that states that Vicki's client's price is greater than Debra's price, thus:
    Vicki_to_int > Debra_to_int.

-   Debra paid less than Pam's client:
    This is a constraint that states that Debra's price is less than Pam's client's price, thus:
    Debra_to_int < Pam_to_int.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Beulah == 1, and Price150 == 1, and Lynda == 1, then Beulah paid $150 to Lynda.

### Decision variables:
-   Names of the clients: Beulah, Debra, Ginger, Hannah (all different, 1 to 4)
-   Prices paid by the clients: Price150, Price160, Price170, Price180 (all different, 1 to 4)
-   Names of the masseuses: Lynda, Pam, Vicki, Yvonne (all different, 1 to 4)

### Constraints:
-   Ginger was either the person who paid $160 or Vicki's client:
    This is a constraint that states that Ginger's price is either $160 or the price of Vicki's client, but not both. So:
    Xor([Ginger == Price160, Ginger == Vicki]).

-   Beulah paid 10 dollars more than Yvonne's client:
    For this, we will need to add a constraint for each possible assignment of prices to Beulah and Yvonne's client, such that Beulah's price is 10 dollars more than Yvonne's client's price. So, the constraints will be of the form:
    p1 == Beulah and p2 == Yvonne => p1_to_int == p2_to_int + 10, for all p1, p2 in prices.

-   Hannah paid less than Debra:
    This is a constraint that states that Hannah's price is less than Debra's price, thus:
    Hannah_to_int < Debra_to_int.

-   Vicki's client paid more than Debra:
    This is a constraint that states that Vicki's client's price is greater than Debra's price, thus:
    Vicki_to_int > Debra_to_int.

-   Debra paid less than Pam's client:
    This is a constraint that states that Debra's price is less than Pam's client's price, thus:
    Debra_to_int < Pam_to_int.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of client, price, and masseuse)
# e.g. if beulah == 1 and price150 == 1 and lynda == 1, then Beulah paid $150 to Lynda
beulah, debra, ginger, hannah = clients = intvar(1, 4, shape=4)
price150, price160, price170, price180 = prices = intvar(1, 4, shape=4)
lynda, pam, vicki, yvonne = masseuses = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
client_to_int = None  # N/A
price_to_int = {price150: 150, price160: 160, price170: 170, price180: 180}  # in dollars
masseuse_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def paid_more_than(var1, var2):
    """
    Formulate the constraint that var1 paid more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] > price_to_int[p2])
            for p1 in prices for p2 in prices]


def paid_exactly_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 paid exactly diff dollars more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] + diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(clients)
m += AllDifferent(prices)
m += AllDifferent(masseuses)

# Clue 1: Ginger was either the person who paid $160 or Vicki's client:
m += Xor([ginger == price160, ginger == vicki])

# Clue 2: Beulah paid 10 dollars more than Yvonne's client:
m += paid_exactly_more_than(beulah, yvonne, 10)

# Clue 3: Hannah paid less than Debra:
m += price_to_int[hannah] < price_to_int[debra]

# Clue 4: Vicki's client paid more than Debra:
m += price_to_int[vicki] > price_to_int[debra]

# Clue 5: Debra paid less than Pam's client:
m += price_to_int[debra] < price_to_int[pam]

```
Error: name 'IV7251' is not defined
False
False
Error: name 'IV7275' is not defined
---------------------------------------------------------------------------------------------

