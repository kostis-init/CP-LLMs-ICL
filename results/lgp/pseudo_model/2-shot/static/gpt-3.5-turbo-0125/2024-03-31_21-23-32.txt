Solution accuracy: 43.0%
Inverse Solution accuracy: 44.0%
Constraint accuracy: 66.5785997357992%
Model accuracy: 38.0%

Wrong solutions: 38, total: 100
Wrong inverse solutions: 56, total: 100
Wrong constraints: 108, total: 757
Wrong models: 61, total: 100
Errors: solution-level: 19, inverse solution-level: 0, constraint-level: 145, model-level: 1
---------------------------------------------------------------------------------------------

Clues:
The person who had the port paid 1 dollar more than Kurt.
Of the person who paid $25 and the person who paid $24, one was Priscilla and the other had the shiraz.
Of the person who paid $27 and Priscilla, one had the chianti and the other had the port.
Isabel paid $25.

Entities:
wines: chianti, port, riesling, shiraz
prices: $24, $25, $26, $27
names: Isabel, Kurt, Priscilla, Robin
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Isabel == 1, and Price25 == 1, and Chianti == 1, then Isabel paid $25 for Chianti.

### Decision variables:
-   Names of the people: Isabel, Kurt, Priscilla, Robin (all different, 1 to 4)
-   Wines purchased: Chianti, Port, Riesling, Shiraz (all different, 1 to 4)
-   Prices paid: Price24, Price25, Price26, Price27 (all different, 1 to 4)

### Constraints:
-   The person who had the port paid 1 dollar more than Kurt:
    For this, we will need to add a constraint for each possible assignment of prices to the person who had the port and Kurt, such that the price of the person with the port is 1 dollar more than Kurt's price. So, the constraints will be of the form:
    p1 == Port and p2 == Kurt => p1_to_int == p2_to_int + 1, for all p1, p2 in prices.

-   Of the person who paid $25 and the person who paid $24, one was Priscilla and the other had the Shiraz:
    This is a constraint that states that one person paid $25 and the other paid $24, and one of them is Priscilla and the other had the Shiraz. So, we will have:
    (Price25 == Priscilla and Price24 == Shiraz) or (Price24 == Priscilla and Price25 == Shiraz).

-   Of the person who paid $27 and Priscilla, one had the Chianti and the other had the Port:
    This is a constraint that states that one person paid $27 and the other is Priscilla, and one of them had the Chianti and the other had the Port. So, we will have:
    (Price27 == Priscilla and Chianti == Port) or (Chianti == Priscilla and Price27 == Port).

-   Isabel paid $25:
    This is a constraint that directly states that Isabel paid $25. So, we will have:
    Isabel == Price25.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Isabel == 1, and Price25 == 1, and Chianti == 1, then Isabel paid $25 for Chianti.

### Decision variables:
-   Names of the people: Isabel, Kurt, Priscilla, Robin (all different, 1 to 4)
-   Wines purchased: Chianti, Port, Riesling, Shiraz (all different, 1 to 4)
-   Prices paid: Price24, Price25, Price26, Price27 (all different, 1 to 4)

### Constraints:
-   The person who had the port paid 1 dollar more than Kurt:
    For this, we will need to add a constraint for each possible assignment of prices to the person who had the port and Kurt, such that the price of the person with the port is 1 dollar more than Kurt's price. So, the constraints will be of the form:
    p1 == Port and p2 == Kurt => p1_to_int == p2_to_int + 1, for all p1, p2 in prices.

-   Of the person who paid $25 and the person who paid $24, one was Priscilla and the other had the Shiraz:
    This is a constraint that states that one person paid $25 and the other paid $24, and one of them is Priscilla and the other had the Shiraz. So, we will have:
    (Price25 == Priscilla and Price24 == Shiraz) or (Price24 == Priscilla and Price25 == Shiraz).

-   Of the person who paid $27 and Priscilla, one had the Chianti and the other had the Port:
    This is a constraint that states that one person paid $27 and the other is Priscilla, and one of them had the Chianti and the other had the Port. So, we will have:
    (Price27 == Priscilla and Chianti == Port) or (Chianti == Priscilla and Price27 == Port).

-   Isabel paid $25:
    This is a constraint that directly states that Isabel paid $25. So, we will have:
    Isabel == Price25.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of person, wine, and price)
# e.g. if isabel == 1 and price25 == 1 and chianti == 1, then Isabel paid $25 for Chianti
isabel, kurt, priscilla, robin = people = intvar(1, 4, shape=4)
chianti, port, riesling, shiraz = wines = intvar(1, 4, shape=4)
price24, price25, price26, price27 = prices = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
person_to_int = None  # N/A
wine_to_int = None  # N/A
price_to_int = {price24: 24, price25: 25, price26: 26, price27: 27}  # in dollars


# Helper functions (for formulating comparison constraints)
def paid_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 paid exactly $diff more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] + diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(people)
m += AllDifferent(wines)
m += AllDifferent(prices)

# Clue 1: The person who had the port paid 1 dollar more than Kurt:
m += paid_more_than(port, kurt, 1)

# Clue 2: Of the person who paid $25 and the person who paid $24, one was Priscilla and the other had the Shiraz:
m += ((price25 == priscilla) & (price24 == shiraz)) | ((price24 == priscilla) & (price25 == shiraz))

# Clue 3: Of the person who paid $27 and Priscilla, one had the Chianti and the other had the Port:
m += ((price27 == priscilla) & (chianti == port)) | ((chianti == priscilla) & (price27 == port))

# Clue 4: Isabel paid $25:
m += isabel == price25

```
[['kurt', 'riesling', 'price26'], ['isabel', 'shiraz', 'price25'], ['priscilla', 'chianti', 'price24'], ['robin', 'port', 'price27']]
True
True
True
Wrong: 2, Total: 7
---------------------------------------------------------------------------------------------

Clues:
Celia used the gluten-free diet.
The friend who lost 3 pounds used the low-fat diet.
Mandy lost 2 fewer pounds than Raymond.
Mandy lost 4 more pounds than Tom.
The dieter who used the vegan diet is either Mandy or the friend who lost 3 pounds.

Entities:
pounds lost: 3, 5, 7, 9
diets: dairy-free, gluten-free, low-fat, vegan
names: Celia, Mandy, Raymond, Tom
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Celia == 1, and Pound3 == 1, and DairyFree == 1, then Celia lost 3 pounds using the dairy-free diet.

### Decision variables:
-   Names of the individuals: Celia, Mandy, Raymond, Tom (all different, 1 to 4)
-   Pounds lost: Pound3, Pound5, Pound7, Pound9 (all different, 1 to 4)
-   Diets used: DairyFree, GlutenFree, LowFat, Vegan (all different, 1 to 4)

### Constraints:
-   Celia used the gluten-free diet:
    This constraint states that Celia used the gluten-free diet. So, we have:
    Celia == GlutenFree.

-   The friend who lost 3 pounds used the low-fat diet:
    This constraint states that the friend who lost 3 pounds used the low-fat diet. So, we have:
    Friend3 == LowFat.

-   Mandy lost 2 fewer pounds than Raymond:
    This constraint states that Mandy lost 2 fewer pounds than Raymond. So, we have:
    Mandy_to_int == Raymond_to_int - 2, for pounds lost.

-   Mandy lost 4 more pounds than Tom:
    This constraint states that Mandy lost 4 more pounds than Tom. So, we have:
    Mandy_to_int == Tom_to_int + 4, for pounds lost.

-   The dieter who used the vegan diet is either Mandy or the friend who lost 3 pounds:
    This constraint states that the dieter who used the vegan diet is either Mandy or the friend who lost 3 pounds. So, we have:
    Xor([Vegan == Mandy, Vegan == Friend3]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Celia == 1, and Pound3 == 1, and DairyFree == 1, then Celia lost 3 pounds using the dairy-free diet.

### Decision variables:
-   Names of the individuals: Celia, Mandy, Raymond, Tom (all different, 1 to 4)
-   Pounds lost: Pound3, Pound5, Pound7, Pound9 (all different, 1 to 4)
-   Diets used: DairyFree, GlutenFree, LowFat, Vegan (all different, 1 to 4)

### Constraints:
-   Celia used the gluten-free diet:
    This constraint states that Celia used the gluten-free diet. So, we have:
    Celia == GlutenFree.

-   The friend who lost 3 pounds used the low-fat diet:
    This constraint states that the friend who lost 3 pounds used the low-fat diet. So, we have:
    Friend3 == LowFat.

-   Mandy lost 2 fewer pounds than Raymond:
    This constraint states that Mandy lost 2 fewer pounds than Raymond. So, we have:
    Mandy_to_int == Raymond_to_int - 2, for pounds lost.

-   Mandy lost 4 more pounds than Tom:
    This constraint states that Mandy lost 4 more pounds than Tom. So, we have:
    Mandy_to_int == Tom_to_int + 4, for pounds lost.

-   The dieter who used the vegan diet is either Mandy or the friend who lost 3 pounds:
    This constraint states that the dieter who used the vegan diet is either Mandy or the friend who lost 3 pounds. So, we have:
    Xor([Vegan == Mandy, Vegan == Friend3]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of individual, pounds lost, and diet)
# e.g. if celia == 1 and pound3 == 1 and gluten_free == 1, then Celia lost 3 pounds using the gluten-free diet
celia, mandy, raymond, tom = individuals = intvar(1, 4, shape=4)
pound3, pound5, pound7, pound9 = pounds = intvar(1, 4, shape=4)
dairy_free, gluten_free, low_fat, vegan = diets = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
individual_to_int = None  # N/A
pound_to_int = {pound3: 3, pound5: 5, pound7: 7, pound9: 9}  # in pounds
diet_to_int = None  # N/A


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(individuals)
m += AllDifferent(pounds)
m += AllDifferent(diets)

# Clue 1: Celia used the gluten-free diet
m += celia == gluten_free

# Clue 2: The friend who lost 3 pounds used the low-fat diet
m += pound3 == low_fat

# Clue 3: Mandy lost 2 fewer pounds than Raymond
m += mandy == raymond - 2

# Clue 4: Mandy lost 4 more pounds than Tom
m += mandy == tom + 4

# Clue 5: The dieter who used the vegan diet is either Mandy or the friend who lost 3 pounds
m += Xor([
    vegan == mandy,
    vegan == pound3
])

```
None
False
False
False
Wrong: 2, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The four people were Shari, the performer who went fourth, the person who used batons and the performer who went third.
Of the performer who used bowling pins and the juggler who went fourth, one is Melissa and the other is Yolanda.
The juggler who used bowling pins was either Yolanda or the juggler who went second.
Trevor performed 2 spots before the performer who used chainsaws.

Entities:
orders: first, second, third, fourth
names: Melissa, Shari, Trevor, Yolanda
items: batons, bowling pins, chainsaws, rings
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Melissa == 1, and First == 1, and Batons == 1, then Melissa performed first with batons.

### Decision variables:
-   Orders of performance: First, Second, Third, Fourth (all different, 1 to 4)
-   Names of performers: Melissa, Shari, Trevor, Yolanda (all different, 1 to 4)
-   Items used: Batons, Bowling pins, Chainsaws, Rings (all different, 1 to 4)

### Constraints:
-   The four people were Shari, the performer who went fourth, the person who used batons, and the performer who went third:
    This constraint states that each of the four entities is different. So, we have:
    AllDifferent([Shari, Fourth, Batons, Third]).

-   Of the performer who used bowling pins and the juggler who went fourth, one is Melissa and the other is Yolanda:
    This constraint states that Melissa and Yolanda are associated with bowling pins and the juggler who went fourth. So, we have:
    (BowlingPins == Melissa and Fourth == Yolanda) or (BowlingPins == Yolanda and Fourth == Melissa).

-   The juggler who used bowling pins was either Yolanda or the juggler who went second:
    This constraint states that the juggler who used bowling pins is either Yolanda or the juggler who went second. So, we have:
    (BowlingPins == Yolanda) or (BowlingPins == Second).

-   Trevor performed 2 spots before the performer who used chainsaws:
    This constraint states that Trevor performed 2 spots before the performer who used chainsaws. So, we have:
    Trevor_to_int + 2 == Chainsaws_to_int.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Melissa == 1, and First == 1, and Batons == 1, then Melissa performed first with batons.

### Decision variables:
-   Orders of performance: First, Second, Third, Fourth (all different, 1 to 4)
-   Names of performers: Melissa, Shari, Trevor, Yolanda (all different, 1 to 4)
-   Items used: Batons, Bowling pins, Chainsaws, Rings (all different, 1 to 4)

### Constraints:
-   The four people were Shari, the performer who went fourth, the person who used batons, and the performer who went third:
    This constraint states that each of the four entities is different. So, we have:
    AllDifferent([Shari, Fourth, Batons, Third]).

-   Of the performer who used bowling pins and the juggler who went fourth, one is Melissa and the other is Yolanda:
    This constraint states that Melissa and Yolanda are associated with bowling pins and the juggler who went fourth. So, we have:
    (BowlingPins == Melissa and Fourth == Yolanda) or (BowlingPins == Yolanda and Fourth == Melissa).

-   The juggler who used bowling pins was either Yolanda or the juggler who went second:
    This constraint states that the juggler who used bowling pins is either Yolanda or the juggler who went second. So, we have:
    (BowlingPins == Yolanda) or (BowlingPins == Second).

-   Trevor performed 2 spots before the performer who used chainsaws:
    This constraint states that Trevor performed 2 spots before the performer who used chainsaws. So, we have:
    Trevor_to_int + 2 == Chainsaws_to_int.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of order, performer, and item)
# e.g. if melissa == 1 and first == 1 and batons == 1, then Melissa performed first with batons
melissa, shari, trevor, yolanda = performers = intvar(1, 4, shape=4)
first, second, third, fourth = orders = intvar(1, 4, shape=4)
batons, bowling_pins, chainsaws, rings = items = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
performer_to_int = None  # N/A
order_to_int = {first: 1, second: 2, third: 3, fourth: 4}  # in order
item_to_int = {batons: 1, bowling_pins: 2, chainsaws: 3, rings: 4}  # in items


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(performers)
m += AllDifferent(orders)
m += AllDifferent(items)

# Clue 1: The four people were Shari, the performer who went fourth, the person who used batons, and the performer who went third:
m += AllDifferent([shari, fourth, batons, third])

# Clue 2: Of the performer who used bowling pins and the juggler who went fourth, one is Melissa and the other is Yolanda:
m += ((bowling_pins == melissa) & (fourth == yolanda)) | ((bowling_pins == yolanda) & (fourth == melissa))

# Clue 3: The juggler who used bowling pins was either Yolanda or the juggler who went second:
m += (bowling_pins == yolanda) | (bowling_pins == second)

# Clue 4: Trevor performed 2 spots before the performer who used chainsaws:
m += trevor + 2 == chainsaws

```
[['melissa', 'fourth', 'rings'], ['trevor', 'first', 'batons'], ['yolanda', 'third', 'bowling_pins'], ['shari', 'second', 'chainsaws']]
False
False
False
Wrong: 3, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The woman with 2 losses has 3 more wins than the boxer with 8 losses.
Edna Easton has 6 more wins than Irma.
Of the boxer with 33 wins and the fighter with 27 wins, one is Sonia and the other has 12 losses.
The boxer with 12 losses is either the fighter with 33 wins or Jane.

Entities:
wins: 24, 27, 30, 33
boxers: Edna Easton, Irma, Jane, Sonia
losses: 2, 4, 8, 12
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Edna Easton == 1, and Wins24 == 1, and Losses2 == 1, then Edna Easton has 24 wins and 2 losses.

### Decision variables:
-   Names of the boxers: Edna Easton, Irma, Jane, Sonia (all different, 1 to 4)
-   Number of wins: Wins24, Wins27, Wins30, Wins33 (all different, 1 to 4)
-   Number of losses: Losses2, Losses4, Losses8, Losses12 (all different, 1 to 4)

### Constraints:
-   The woman with 2 losses has 3 more wins than the boxer with 8 losses:
    For this, we will need to add a constraint for each possible assignment of wins and losses, such that the woman with 2 losses has 3 more wins than the boxer with 8 losses. So, the constraints will be of the form:
    l1 == Losses2 and l2 == Losses8 and w1 == WinsX and w2 == WinsY => w1_to_int == w2_to_int + 3, for all l1, l2, w1, w2 in their respective domains.

-   Edna Easton has 6 more wins than Irma:
    For this, we will need to add a constraint for each possible assignment of wins for Edna Easton and Irma, such that Edna Easton has 6 more wins than Irma. So, the constraints will be of the form:
    w1 == Edna Easton and w2 == Irma => w1_to_int == w2_to_int + 6, for all w1, w2 in wins.

-   Of the boxer with 33 wins and the fighter with 27 wins, one is Sonia and the other has 12 losses:
    This is a constraint that states that one of the boxers has 33 wins and the other has 27 wins, and one of them is Sonia and the other has 12 losses. So, the constraints will be of the form:
    (w1 == Wins33 and w2 == Wins27 and b1 == Sonia and l2 == Losses12) or (w1 == Wins27 and w2 == Wins33 and l1 == Losses12 and b2 == Sonia), for all w1, w2, b1, b2, l1, l2 in their respective domains.

-   The boxer with 12 losses is either the fighter with 33 wins or Jane:
    This is a constraint that states that the boxer with 12 losses is either the fighter with 33 wins or Jane, but not both. So:
    Xor([l1 == Losses12 and w1 == Wins33, l1 == Losses12 and b1 == Jane]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Edna Easton == 1, and Wins24 == 1, and Losses2 == 1, then Edna Easton has 24 wins and 2 losses.

### Decision variables:
-   Names of the boxers: Edna Easton, Irma, Jane, Sonia (all different, 1 to 4)
-   Number of wins: Wins24, Wins27, Wins30, Wins33 (all different, 1 to 4)
-   Number of losses: Losses2, Losses4, Losses8, Losses12 (all different, 1 to 4)

### Constraints:
-   The woman with 2 losses has 3 more wins than the boxer with 8 losses:
    For this, we will need to add a constraint for each possible assignment of wins and losses, such that the woman with 2 losses has 3 more wins than the boxer with 8 losses. So, the constraints will be of the form:
    l1 == Losses2 and l2 == Losses8 and w1 == WinsX and w2 == WinsY => w1_to_int == w2_to_int + 3, for all l1, l2, w1, w2 in their respective domains.

-   Edna Easton has 6 more wins than Irma:
    For this, we will need to add a constraint for each possible assignment of wins for Edna Easton and Irma, such that Edna Easton has 6 more wins than Irma. So, the constraints will be of the form:
    w1 == Edna Easton and w2 == Irma => w1_to_int == w2_to_int + 6, for all w1, w2 in wins.

-   Of the boxer with 33 wins and the fighter with 27 wins, one is Sonia and the other has 12 losses:
    This is a constraint that states that one of the boxers has 33 wins and the other has 27 wins, and one of them is Sonia and the other has 12 losses. So, the constraints will be of the form:
    (w1 == Wins33 and w2 == Wins27 and b1 == Sonia and l2 == Losses12) or (w1 == Wins27 and w2 == Wins33 and l1 == Losses12 and b2 == Sonia), for all w1, w2, b1, b2, l1, l2 in their respective domains.

-   The boxer with 12 losses is either the fighter with 33 wins or Jane:
    This is a constraint that states that the boxer with 12 losses is either the fighter with 33 wins or Jane, but not both. So:
    Xor([l1 == Losses12 and w1 == Wins33, l1 == Losses12 and b1 == Jane]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of boxer, wins, and losses)
# e.g. if edna_easton == 1 and wins24 == 1 and losses2 == 1, then Edna Easton has 24 wins and 2 losses
edna_easton, irma, jane, sonia = boxers = intvar(1, 4, shape=4)
wins24, wins27, wins30, wins33 = wins = intvar(1, 4, shape=4)
losses2, losses4, losses8, losses12 = losses = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
boxer_to_int = None  # N/A
wins_to_int = {wins24: 24, wins27: 27, wins30: 30, wins33: 33}  # in wins
losses_to_int = {losses2: 2, losses4: 4, losses8: 8, losses12: 12}  # in losses


# Helper functions (for formulating comparison constraints)
def wins_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 has diff more wins than var2.
    """
    return [((w1 == var1) & (w2 == var2)).implies(wins_to_int[w1] == wins_to_int[w2] + diff)
            for w1 in wins for w2 in wins]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(boxers)
m += AllDifferent(wins)
m += AllDifferent(losses)

# Clue 1: The woman with 2 losses has 3 more wins than the boxer with 8 losses:
m += wins_more_than(losses2, losses8, 3)

# Clue 2: Edna Easton has 6 more wins than Irma:
m += wins_more_than(edna_easton, irma, 6)

# Clue 3: Of the boxer with 33 wins and the fighter with 27 wins, one is Sonia and the other has 12 losses:
m += [
    ((w1 == wins33) & (w2 == wins27) & (b1 == sonia) & (l2 == losses12)) | 
    ((w1 == wins27) & (w2 == wins33) & (l1 == losses12) & (b2 == sonia))
    for w1 in wins for w2 in wins for b1 in boxers for b2 in boxers for l1 in losses for l2 in losses
]

# Clue 4: The boxer with 12 losses is either the fighter with 33 wins or Jane:
m += Xor([
    (l1 == losses12) & (w1 == wins33),
    (l1 == losses12) & (b1 == jane)
])

```
None
Error when trying to check solution from predicted model: invalid syntax (<string>, line 1)
False
False
Error in constraint evaluation: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
The person who will publish in January is either the person who has been studying the Cheer culture or Ira.
The person who has been studying the Xozix culture will publish 1 month before the person who has been studying the Haleyito culture.
Of the student who will publish in March and the person who has been studying the Xozix culture, one is Luther and the other is Yvette.
Vera will publish 1 month before Luther.

Entities:
months: January, February, March, April
names: Ira, Luther, Vera, Yvette
cultures: Cheer, Garyk, Haleyito, Xozix
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ira == 1, and January == 1, and Cheer == 1, then Ira is the person studying the Cheer culture who will publish in January.

### Decision variables:
-   Names of the individuals: Ira, Luther, Vera, Yvette (all different, 1 to 4)
-   Months of publication: January, February, March, April (all different, 1 to 4)
-   Cultures studied: Cheer, Garyk, Haleyito, Xozix (all different, 1 to 4)

### Constraints:
-   The person who will publish in January is either the person who has been studying the Cheer culture or Ira:
    This is a constraint that states that the person publishing in January is either studying the Cheer culture or is Ira, but not both. So:
    Xor([January == Cheer, January == Ira]).

-   The person who has been studying the Xozix culture will publish 1 month before the person who has been studying the Haleyito culture:
    For this, we will need to add a constraint for each possible assignment of the months of publication for Xozix and Haleyito, such that Xozix's month of publication is 1 less than Haleyito's month of publication. So, the constraints will be of the form:
    m1 == Xozix and m2 == Haleyito => m1_to_int == m2_to_int - 1, for all m1, m2 in months of publication.

-   Of the student who will publish in March and the person who has been studying the Xozix culture, one is Luther and the other is Yvette:
    This is a constraint that states that one of the individuals studying Xozix and publishing in March is Luther, and the other is Yvette. So:
    (March == Xozix and Xozix == Luther) or (March == Xozix and Xozix == Yvette).

-   Vera will publish 1 month before Luther:
    For this, we will need to add a constraint for each possible assignment of the months of publication for Vera and Luther, such that Vera's month of publication is 1 less than Luther's month of publication. So, the constraints will be of the form:
    m1 == Vera and m2 == Luther => m1_to_int == m2_to_int - 1, for all m1, m2 in months of publication.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ira == 1, and January == 1, and Cheer == 1, then Ira is the person studying the Cheer culture who will publish in January.

### Decision variables:
-   Names of the individuals: Ira, Luther, Vera, Yvette (all different, 1 to 4)
-   Months of publication: January, February, March, April (all different, 1 to 4)
-   Cultures studied: Cheer, Garyk, Haleyito, Xozix (all different, 1 to 4)

### Constraints:
-   The person who will publish in January is either the person who has been studying the Cheer culture or Ira:
    This is a constraint that states that the person publishing in January is either studying the Cheer culture or is Ira, but not both. So:
    Xor([January == Cheer, January == Ira]).

-   The person who has been studying the Xozix culture will publish 1 month before the person who has been studying the Haleyito culture:
    For this, we will need to add a constraint for each possible assignment of the months of publication for Xozix and Haleyito, such that Xozix's month of publication is 1 less than Haleyito's month of publication. So, the constraints will be of the form:
    m1 == Xozix and m2 == Haleyito => m1_to_int == m2_to_int - 1, for all m1, m2 in months of publication.

-   Of the student who will publish in March and the person who has been studying the Xozix culture, one is Luther and the other is Yvette:
    This is a constraint that states that one of the individuals studying Xozix and publishing in March is Luther, and the other is Yvette. So:
    (March == Xozix and Xozix == Luther) or (March == Xozix and Xozix == Yvette).

-   Vera will publish 1 month before Luther:
    For this, we will need to add a constraint for each possible assignment of the months of publication for Vera and Luther, such that Vera's month of publication is 1 less than Luther's month of publication. So, the constraints will be of the form:
    m1 == Vera and m2 == Luther => m1_to_int == m2_to_int - 1, for all m1, m2 in months of publication.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of individual, month, and culture)
# e.g. if ira == 1 and january == 1 and cheer == 1, then Ira is studying the Cheer culture and will publish in January
ira, luther, vera, yvette = individuals = intvar(1, 4, shape=4)
january, february, march, april = months = intvar(1, 4, shape=4)
cheer, garyk, haleyito, xozix = cultures = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
individual_to_int = None  # N/A
month_to_int = {january: 1, february: 2, march: 3, april: 4}  # in months
culture_to_int = {cheer: 1, garyk: 2, haleyito: 3, xozix: 4}  # in cultures


# Helper functions (for formulating comparison constraints)
def publish_before(var1, var2):
    """
    Formulate the constraint that var1 will publish before var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] < month_to_int[m2])
            for m1 in months for m2 in months]


def publish_exactly_before(var1, var2, diff):
    """
    Formulate the constraint that var1 will publish exactly diff months before var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] == month_to_int[m2] - diff)
            for m1 in months for m2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(individuals)
m += AllDifferent(months)
m += AllDifferent(cultures)

# Clue 1: The person who will publish in January is either the person who has been studying the Cheer culture or Ira:
m += Xor([
    january == cheer,
    january == ira
])

# Clue 2: The person who has been studying the Xozix culture will publish 1 month before the person who has been studying the Haleyito culture:
m += publish_exactly_before(xozix, haleyito, 1)

# Clue 3: Of the student who will publish in March and the person who has been studying the Xozix culture, one is Luther and the other is Yvette:
m += ((march == xozix) & ((xozix == luther) | (xozix == yvette))) | ((march == luther) & ((luther == xozix) | (luther == yvette)))

# Clue 4: Vera will publish 1 month before Luther:
m += publish_exactly_before(vera, luther, 1)

```
[['ira', 'april', 'haleyito'], ['luther', 'february', 'garyk'], ['vera', 'january', 'cheer'], ['yvette', 'march', 'xozix']]
False
False
False
Wrong: 1, Total: 7
---------------------------------------------------------------------------------------------

Clues:
Francis will depart from Manson.
The conductor working on June 12 is either the conductor departing from Buttonwillow or Greg.
Ira will leave 1 day before the conductor departing from Manson.
The person departing from Buttonwillow will leave 1 day before the conductor departing from Indio.

Entities:
days: June 10, June 11, June 12, June 13
names: Francis, Greg, Ira, Oscar
departures: Buttonwillow, Coulterville, Indio, Manson
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Francis == 1, and June10 == 1, and Buttonwillow == 1, then Francis will depart from Buttonwillow on June 10.

### Decision variables:
-   Names of the individuals: Francis, Greg, Ira, Oscar (all different, 1 to 4)
-   Dates of departure: June 10, June 11, June 12, June 13 (all different, 1 to 4)
-   Departure locations: Buttonwillow, Coulterville, Indio, Manson (all different, 1 to 4)

### Constraints:
-   Francis will depart from Manson:
    This constraint directly assigns Francis to depart from Manson:
    Francis == Manson.

-   The conductor working on June 12 is either the conductor departing from Buttonwillow or Greg:
    This constraint states that the conductor working on June 12 is either the conductor departing from Buttonwillow or Greg, but not both. So:
    Xor([June12 == Buttonwillow, June12 == Greg]).

-   Ira will leave 1 day before the conductor departing from Manson:
    For this, we will need to add a constraint for each possible assignment of the dates of departure for Ira and the conductor departing from Manson, such that Ira's date of departure is 1 less than the conductor's date of departure. So, the constraints will be of the form:
    d1 == Ira and d2 == Manson => d1_to_int == d2_to_int - 1, for all d1, d2 in dates of departure.

-   The person departing from Buttonwillow will leave 1 day before the conductor departing from Indio:
    For this, we will need to add a constraint for each possible assignment of the dates of departure for the person departing from Buttonwillow and the conductor departing from Indio, such that the person departing from Buttonwillow's date of departure is 1 less than the conductor's date of departure. So, the constraints will be of the form:
    d1 == Buttonwillow and d2 == Indio => d1_to_int == d2_to_int - 1, for all d1, d2 in dates of departure.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Francis == 1, and June10 == 1, and Buttonwillow == 1, then Francis will depart from Buttonwillow on June 10.

### Decision variables:
-   Names of the individuals: Francis, Greg, Ira, Oscar (all different, 1 to 4)
-   Dates of departure: June 10, June 11, June 12, June 13 (all different, 1 to 4)
-   Departure locations: Buttonwillow, Coulterville, Indio, Manson (all different, 1 to 4)

### Constraints:
-   Francis will depart from Manson:
    This constraint directly assigns Francis to depart from Manson:
    Francis == Manson.

-   The conductor working on June 12 is either the conductor departing from Buttonwillow or Greg:
    This constraint states that the conductor working on June 12 is either the conductor departing from Buttonwillow or Greg, but not both. So:
    Xor([June12 == Buttonwillow, June12 == Greg]).

-   Ira will leave 1 day before the conductor departing from Manson:
    For this, we will need to add a constraint for each possible assignment of the dates of departure for Ira and the conductor departing from Manson, such that Ira's date of departure is 1 less than the conductor's date of departure. So, the constraints will be of the form:
    d1 == Ira and d2 == Manson => d1_to_int == d2_to_int - 1, for all d1, d2 in dates of departure.

-   The person departing from Buttonwillow will leave 1 day before the conductor departing from Indio:
    For this, we will need to add a constraint for each possible assignment of the dates of departure for the person departing from Buttonwillow and the conductor departing from Indio, such that the person departing from Buttonwillow's date of departure is 1 less than the conductor's date of departure. So, the constraints will be of the form:
    d1 == Buttonwillow and d2 == Indio => d1_to_int == d2_to_int - 1, for all d1, d2 in dates of departure.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of individual, date, and departure location)
# e.g. if francis == 1 and june10 == 1 and buttonwillow == 1, then Francis will depart from Buttonwillow on June 10
francis, greg, ira, oscar = individuals = intvar(1, 4, shape=4)
june10, june11, june12, june13 = dates = intvar(1, 4, shape=4)
buttonwillow, coulterville, indio, manson = departures = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
individual_to_int = None  # N/A
date_to_int = {june10: 10, june11: 11, june12: 12, june13: 13}  # in days
departure_to_int = {buttonwillow: 1, coulterville: 2, indio: 3, manson: 4}  # in order


# Helper functions (for formulating comparison constraints)
def leave_exactly_before(var1, var2, diff):
    """
    Formulate the constraint that var1 leaves exactly diff days before var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(date_to_int[d1] == date_to_int[d2] - diff)
            for d1 in dates for d2 in dates]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(individuals)
m += AllDifferent(dates)
m += AllDifferent(departures)

# Clue 1: Francis will depart from Manson
m += francis == manson

# Clue 2: The conductor working on June 12 is either the conductor departing from Buttonwillow or Greg
m += Xor([
    june12 == buttonwillow,
    june12 == greg
])

# Clue 3: Ira will leave 1 day before the conductor departing from Manson
m += leave_exactly_before(ira, manson, 1)

# Clue 4: The person departing from Buttonwillow will leave 1 day before the conductor departing from Indio
m += leave_exactly_before(buttonwillow, indio, 1)

```
[['francis', 'june11', 'manson'], ['greg', 'june13', 'indio'], ['oscar', 'june12', 'buttonwillow'], ['ira', 'june10', 'coulterville']]
True
True
True
Wrong: 0, Total: 7
---------------------------------------------------------------------------------------------

Clues:
Vicky Estes used the catamaran.
Debra Decker took 4 fewer days to finish than the sailor in the trimaran.
Wendell Orr finished in 278 days.
The competitor in the schooner took 4 more days to finish than Vicky Estes.

Entities:
days: 270, 274, 278, 282
boat types: catamaran, ketch, schooner, trimaran
sailors: Debra Decker, Gil Baxter, Vicky Estes, Wendell Orr
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Debra Decker == 1, and Catamaran == 1, and Day270 == 1, then Debra Decker used the catamaran and finished in 270 days.

### Decision variables:
-   Names of the sailors: Debra Decker, Gil Baxter, Vicky Estes, Wendell Orr (all different, 1 to 4)
-   Boat types used: Catamaran, Ketch, Schooner, Trimaran (all different, 1 to 4)
-   Number of days taken to finish: Day270, Day274, Day278, Day282 (all different, 1 to 4)

### Constraints:
-   Vicky Estes used the catamaran:
    This constraint directly assigns Vicky Estes to the catamaran:
    Vicky Estes == Catamaran.

-   Debra Decker took 4 fewer days to finish than the sailor in the trimaran:
    For this, we will need to add a constraint for each possible assignment of days taken to finish by Debra Decker and the sailor in the trimaran, such that Debra Decker's days taken is 4 less than the trimaran sailor's days taken. So, the constraints will be of the form:
    d1 == Debra Decker and d2 == Trimaran => d1_to_int == d2_to_int - 4, for all d1, d2 in days taken.

-   Wendell Orr finished in 278 days:
    This constraint directly assigns Wendell Orr to finish in 278 days:
    Wendell Orr == Day278.

-   The competitor in the schooner took 4 more days to finish than Vicky Estes:
    For this, we will need to add a constraint for each possible assignment of days taken to finish by the competitor in the schooner and Vicky Estes, such that the schooner competitor's days taken is 4 more than Vicky Estes' days taken. So, the constraints will be of the form:
    d1 == Schooner and d2 == Vicky Estes => d1_to_int == d2_to_int + 4, for all d1, d2 in days taken.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Debra Decker == 1, and Catamaran == 1, and Day270 == 1, then Debra Decker used the catamaran and finished in 270 days.

### Decision variables:
-   Names of the sailors: Debra Decker, Gil Baxter, Vicky Estes, Wendell Orr (all different, 1 to 4)
-   Boat types used: Catamaran, Ketch, Schooner, Trimaran (all different, 1 to 4)
-   Number of days taken to finish: Day270, Day274, Day278, Day282 (all different, 1 to 4)

### Constraints:
-   Vicky Estes used the catamaran:
    This constraint directly assigns Vicky Estes to the catamaran:
    Vicky Estes == Catamaran.

-   Debra Decker took 4 fewer days to finish than the sailor in the trimaran:
    For this, we will need to add a constraint for each possible assignment of days taken to finish by Debra Decker and the sailor in the trimaran, such that Debra Decker's days taken is 4 less than the trimaran sailor's days taken. So, the constraints will be of the form:
    d1 == Debra Decker and d2 == Trimaran => d1_to_int == d2_to_int - 4, for all d1, d2 in days taken.

-   Wendell Orr finished in 278 days:
    This constraint directly assigns Wendell Orr to finish in 278 days:
    Wendell Orr == Day278.

-   The competitor in the schooner took 4 more days to finish than Vicky Estes:
    For this, we will need to add a constraint for each possible assignment of days taken to finish by the competitor in the schooner and Vicky Estes, such that the schooner competitor's days taken is 4 more than Vicky Estes' days taken. So, the constraints will be of the form:
    d1 == Schooner and d2 == Vicky Estes => d1_to_int == d2_to_int + 4, for all d1, d2 in days taken.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of sailor, boat type, and days taken)
# e.g. if debra == 1 and catamaran == 1 and day270 == 1, then Debra Decker used the catamaran and finished in 270 days
debra, gil, vicky, wendell = sailors = intvar(1, 4, shape=4)
catamaran, ketch, schooner, trimaran = boats = intvar(1, 4, shape=4)
day270, day274, day278, day282 = days_taken = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
sailor_to_int = None  # N/A
boat_to_int = {catamaran: 1, ketch: 2, schooner: 3, trimaran: 4}  # in boat types
days_to_int = {day270: 270, day274: 274, day278: 278, day282: 282}  # in days


# Helper functions (for formulating comparison constraints)
def took_fewer_days(var1, var2, diff):
    """
    Formulate the constraint that var1 took diff fewer days to finish than var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(days_to_int[d1] == days_to_int[d2] - diff)
            for d1 in days_taken for d2 in days_taken]


def took_more_days(var1, var2, diff):
    """
    Formulate the constraint that var1 took diff more days to finish than var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(days_to_int[d1] == days_to_int[d2] + diff)
            for d1 in days_taken for d2 in days_taken]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(sailors)
m += AllDifferent(boats)
m += AllDifferent(days_taken)

# Clue 1: Vicky Estes used the catamaran
m += vicky == catamaran

# Clue 2: Debra Decker took 4 fewer days to finish than the sailor in the trimaran
m += took_fewer_days(debra, trimaran, 4)

# Clue 3: Wendell Orr finished in 278 days
m += wendell == day278

# Clue 4: The competitor in the schooner took 4 more days to finish than Vicky Estes
m += took_more_days(schooner, vicky, 4

```
None
Error when trying to check solution from predicted model: invalid syntax (<string>, line 1)
False
False
Error in constraint evaluation: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
Jorge is either the skydiver who wears the red suit or the jumper who started in 1982.
The skydiver who wears the pink suit started skydiving 1 year before Otis.
The jumper who wears the yellow suit started skydiving sometime after Philip.
The jumper who wears the lime green suit started skydiving sometime after the jumper who wears the yellow suit.
The jumper who wears the pink suit started skydiving 2 years before Shaun.

Entities:
names: Jorge, Otis, Philip, Shaun
years: 1982, 1983, 1984, 1985
suit colors: lime green, pink, red, yellow
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Jorge == 1, and Year1982 == 1, and LimeGreen == 1, then Jorge is the skydiver who started in 1982 and wears the lime green suit.

### Decision variables:
-   Names of the skydivers: Jorge, Otis, Philip, Shaun (all different, 1 to 4)
-   Years when they started skydiving: 1982, 1983, 1984, 1985 (all different, 1 to 4)
-   Suit colors: LimeGreen, Pink, Red, Yellow (all different, 1 to 4)

### Constraints:
-   Jorge is either the skydiver who wears the red suit or the jumper who started in 1982:
    This is a constraint that states that Jorge's suit color is either red or Jorge started skydiving in 1982, but not both. So:
    Xor([Jorge == Red, Jorge == Year1982]).

-   The skydiver who wears the pink suit started skydiving 1 year before Otis:
    For this, we will need to add a constraint for each possible assignment of the years when the skydiver who wears the pink suit and Otis started skydiving, such that the pink suit skydiver's year is 1 less than Otis's year. So, the constraints will be of the form:
    y1 == Pink and y2 == Otis => y1_to_int == y2_to_int - 1, for all y1, y2 in years.

-   The jumper who wears the yellow suit started skydiving sometime after Philip:
    For this, we will need to add a constraint for each possible assignment of the years when the jumper who wears the yellow suit and Philip started skydiving, such that the yellow suit jumper's year is greater than Philip's year. So, the constraints will be of the form:
    y1 == Yellow and y2 == Philip => y1_to_int > y2_to_int, for all y1, y2 in years.

-   The jumper who wears the lime green suit started skydiving sometime after the jumper who wears the yellow suit:
    For this, we will need to add a constraint for each possible assignment of the years when the lime green suit jumper and the yellow suit jumper started skydiving, such that the lime green suit jumper's year is greater than the yellow suit jumper's year. So, the constraints will be of the form:
    y1 == LimeGreen and y2 == Yellow => y1_to_int > y2_to_int, for all y1, y2 in years.

-   The jumper who wears the pink suit started skydiving 2 years before Shaun:
    For this, we will need to add a constraint for each possible assignment of the years when the pink suit jumper and Shaun started skydiving, such that the pink suit jumper's year is 2 less than Shaun's year. So, the constraints will be of the form:
    y1 == Pink and y2 == Shaun => y1_to_int == y2_to_int - 2, for all y1, y2 in years.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Jorge == 1, and Year1982 == 1, and LimeGreen == 1, then Jorge is the skydiver who started in 1982 and wears the lime green suit.

### Decision variables:
-   Names of the skydivers: Jorge, Otis, Philip, Shaun (all different, 1 to 4)
-   Years when they started skydiving: 1982, 1983, 1984, 1985 (all different, 1 to 4)
-   Suit colors: LimeGreen, Pink, Red, Yellow (all different, 1 to 4)

### Constraints:
-   Jorge is either the skydiver who wears the red suit or the jumper who started in 1982:
    This is a constraint that states that Jorge's suit color is either red or Jorge started skydiving in 1982, but not both. So:
    Xor([Jorge == Red, Jorge == Year1982]).

-   The skydiver who wears the pink suit started skydiving 1 year before Otis:
    For this, we will need to add a constraint for each possible assignment of the years when the skydiver who wears the pink suit and Otis started skydiving, such that the pink suit skydiver's year is 1 less than Otis's year. So, the constraints will be of the form:
    y1 == Pink and y2 == Otis => y1_to_int == y2_to_int - 1, for all y1, y2 in years.

-   The jumper who wears the yellow suit started skydiving sometime after Philip:
    For this, we will need to add a constraint for each possible assignment of the years when the jumper who wears the yellow suit and Philip started skydiving, such that the yellow suit jumper's year is greater than Philip's year. So, the constraints will be of the form:
    y1 == Yellow and y2 == Philip => y1_to_int > y2_to_int, for all y1, y2 in years.

-   The jumper who wears the lime green suit started skydiving sometime after the jumper who wears the yellow suit:
    For this, we will need to add a constraint for each possible assignment of the years when the lime green suit jumper and the yellow suit jumper started skydiving, such that the lime green suit jumper's year is greater than the yellow suit jumper's year. So, the constraints will be of the form:
    y1 == LimeGreen and y2 == Yellow => y1_to_int > y2_to_int, for all y1, y2 in years.

-   The jumper who wears the pink suit started skydiving 2 years before Shaun:
    For this, we will need to add a constraint for each possible assignment of the years when the pink suit jumper and Shaun started skydiving, such that the pink suit jumper's year is 2 less than Shaun's year. So, the constraints will be of the form:
    y1 == Pink and y2 == Shaun => y1_to_int == y2_to_int - 2, for all y1, y2 in years.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of skydiver, year, and suit color)
# e.g. if jorge == 1 and year1982 == 1 and limegreen == 1, then Jorge started in 1982 and wears the lime green suit
jorge, otis, philip, shaun = names = intvar(1, 4, shape=4)
year1982, year1983, year1984, year1985 = years = intvar(1, 4, shape=4)
limegreen, pink, red, yellow = suit_colors = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
name_to_int = None  # N/A
year_to_int = {year1982: 1982, year1983: 1983, year1984: 1984, year1985: 1985}  # in years
suit_color_to_int = {limegreen: 1, pink: 2, red: 3, yellow: 4}  # arbitrary order


# Helper functions (for formulating comparison constraints)
def started_before_than(var1, var2):
    """
    Formulate the constraint that var1 started before var2.
    """
    return [((y1 == var1) & (y2 == var2)).implies(year_to_int[y1] < year_to_int[y2])
            for y1 in years for y2 in years]


def started_exactly_before_than(var1, var2, diff):
    """
    Formulate the constraint that var1 started exactly diff years before var2.
    """
    return [((y1 == var1) & (y2 == var2)).implies(year_to_int[y1] == year_to_int[y2] - diff)
            for y1 in years for y2 in years]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(names)
m += AllDifferent(years)
m += AllDifferent(suit_colors)

# Clue 1: Jorge is either the skydiver who wears the red suit or the jumper who started in 1982:
m += Xor([
    jorge == red,
    jorge == year1982
])

# Clue 2: The skydiver who wears the pink suit started skydiving 1 year before Otis:
m += started_exactly_before_than(pink, otis, 1)

# Clue 3: The jumper who wears the yellow suit started skydiving sometime after Philip:
m += started_before_than(yellow, philip)

# Clue 4: The jumper who wears the lime green suit started skydiving sometime after the jumper who wears the yellow suit:
m += started_before_than(limegreen, yellow)

# Clue 5: The jumper who wears the pink suit started skydiving 2 years before Shaun:
m += started_exactly_before_than(pink, shaun, 2)

```
[['jorge', 'year1982', 'pink'], ['otis', 'year1983', 'limegreen'], ['shaun', 'year1984', 'yellow'], ['philip', 'year1985', 'red']]
False
False
False
Wrong: 2, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The ambassador with the 9 day visit will leave sometime after Fitzgerald.
Quinn will leave 2 months after Bender.
The person leaving in January is either the ambassador with the 3 day visit or Fitzgerald.
Quinn will leave 1 month before the ambassador with the 7 day visit.

Entities:
diplomats: Bender, Fitzgerald, Owens, Quinn
months: January, February, March, April
durations: 2 day, 3 day, 7 day, 9 day
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Bender == 1, and January == 1, and Day2 == 1, then Bender is the diplomat leaving in January with a 2-day visit.

### Decision variables:
-   Names of the diplomats: Bender, Fitzgerald, Owens, Quinn (all different, 1 to 4)
-   Months of departure: January, February, March, April (all different, 1 to 4)
-   Visit durations: Day2, Day3, Day7, Day9 (all different, 1 to 4)

### Constraints:
-   The ambassador with the 9-day visit will leave sometime after Fitzgerald:
    For this, we will need to add a constraint for each possible assignment of the months of departure for the ambassador with the 9-day visit and Fitzgerald, such that the ambassador with the 9-day visit's month of departure is greater than Fitzgerald's month of departure. So, the constraints will be of the form:
    m1 == Day9 and m2 == Fitzgerald => m1_to_int > m2_to_int, for all m1, m2 in months of departure.

-   Quinn will leave 2 months after Bender:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Quinn and Bender, such that Quinn's month of departure is 2 more than Bender's month of departure. So, the constraints will be of the form:
    m1 == Quinn and m2 == Bender => m1_to_int == m2_to_int + 2, for all m1, m2 in months of departure.

-   The person leaving in January is either the ambassador with the 3-day visit or Fitzgerald:
    This is a constraint that states that the diplomat leaving in January is either the ambassador with the 3-day visit or Fitzgerald, but not both. So:
    Xor([January == Day3, January == Fitzgerald]).

-   Quinn will leave 1 month before the ambassador with the 7-day visit:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Quinn and the ambassador with the 7-day visit, such that Quinn's month of departure is 1 less than the 7-day ambassador's month of departure. So, the constraints will be of the form:
    m1 == Quinn and m2 == Day7 => m1_to_int == m2_to_int - 1, for all m1, m2 in months of departure.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Bender == 1, and January == 1, and Day2 == 1, then Bender is the diplomat leaving in January with a 2-day visit.

### Decision variables:
-   Names of the diplomats: Bender, Fitzgerald, Owens, Quinn (all different, 1 to 4)
-   Months of departure: January, February, March, April (all different, 1 to 4)
-   Visit durations: Day2, Day3, Day7, Day9 (all different, 1 to 4)

### Constraints:
-   The ambassador with the 9-day visit will leave sometime after Fitzgerald:
    For this, we will need to add a constraint for each possible assignment of the months of departure for the ambassador with the 9-day visit and Fitzgerald, such that the ambassador with the 9-day visit's month of departure is greater than Fitzgerald's month of departure. So, the constraints will be of the form:
    m1 == Day9 and m2 == Fitzgerald => m1_to_int > m2_to_int, for all m1, m2 in months of departure.

-   Quinn will leave 2 months after Bender:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Quinn and Bender, such that Quinn's month of departure is 2 more than Bender's month of departure. So, the constraints will be of the form:
    m1 == Quinn and m2 == Bender => m1_to_int == m2_to_int + 2, for all m1, m2 in months of departure.

-   The person leaving in January is either the ambassador with the 3-day visit or Fitzgerald:
    This is a constraint that states that the diplomat leaving in January is either the ambassador with the 3-day visit or Fitzgerald, but not both. So:
    Xor([January == Day3, January == Fitzgerald]).

-   Quinn will leave 1 month before the ambassador with the 7-day visit:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Quinn and the ambassador with the 7-day visit, such that Quinn's month of departure is 1 less than the 7-day ambassador's month of departure. So, the constraints will be of the form:
    m1 == Quinn and m2 == Day7 => m1_to_int == m2_to_int - 1, for all m1, m2 in months of departure.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of diplomat, month, and duration)
# e.g. if bender == 1 and january == 1 and days2 == 1, then Bender will leave in January and for 2 days
bender, fitzgerald, owens, quinn = diplomats = intvar(1, 4, shape=4)
january, february, march, april = months = intvar(1, 4, shape=4)
days2, days3, days7, days9 = durations = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
diplomat_to_int = None  # N/A
month_to_int = {january: 1, february: 2, march: 3, april: 4}  # in months
duration_to_int = {days2: 2, days3: 3, days7: 7, days9: 9}  # in days


# Helper functions (for formulating comparison constraints)
def left_after_than(var1, var2):
    """
    Formulate the constraint that var1 left after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] > month_to_int[m2])
            for m1 in months for m2 in months]


def left_exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 left exactly diff months after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] == month_to_int[m2] + diff)
            for m1 in months for m2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(diplomats)
m += AllDifferent(months)
m += AllDifferent(durations)

# Clue 1: The ambassador with the 9-day visit will leave sometime after Fitzgerald:
m += left_after_than(days9, fitzgerald)

# Clue 2: Quinn will leave 2 months after Bender:
m += left_exactly_after_than(quinn, bender, 2)

# Clue 3: The person leaving in January is either the ambassador with the 3-day visit or Fitzgerald:
m += Xor([
    january == days3,
    january == fitzgerald
])

# Clue 4: Quinn will leave 1 month before the ambassador with the 7-day visit:
m += left_exactly_after_than(quinn, days7, -1)

```
[['quinn', 'march', 'days9'], ['bender', 'january', 'days3'], ['fitzgerald', 'february', 'days2'], ['owens', 'april', 'days7']]
True
True
True
Wrong: 0, Total: 7
---------------------------------------------------------------------------------------------

Clues:
Ultra Hex is Gabe Grant.
Criminal Bane is either the hero who started in 2007 or the superhero who started in 2009.
Peter Powers began sometime before Matt Minkle.
Gabe Grant began 1 year after Wonderman.
The four people are Deep Shadow, the superhero who started in 2007, the hero who started in 2009 and Matt Minkle.

Entities:
years: 2007, 2008, 2009, 2010
superheroes: Criminal Bane, Deep Shadow, Ultra Hex, Wonderman
names: Gabe Grant, Ivor Ingram, Matt Minkle, Peter Powers
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Gabe Grant == 1, and 2007 == 1, and Peter Powers == 1, then Gabe Grant is Ultra Hex who started in 2007 and began before Peter Powers.

### Decision variables:
-   Years of starting: 2007, 2008, 2009, 2010 (all different, 1 to 4)
-   Superheroes: Criminal Bane, Deep Shadow, Ultra Hex, Wonderman (all different, 1 to 4)
-   Names of the people: Gabe Grant, Ivor Ingram, Matt Minkle, Peter Powers (all different, 1 to 4)

### Constraints:
-   Ultra Hex is Gabe Grant:
    This constraint directly assigns Ultra Hex to Gabe Grant:
    Ultra Hex == Gabe Grant.

-   Criminal Bane is either the hero who started in 2007 or the superhero who started in 2009:
    This constraint states that Criminal Bane is either the hero who started in 2007 or the superhero who started in 2009, but not both. So:
    Xor([Criminal Bane == 2007, Criminal Bane == 2009]).

-   Peter Powers began sometime before Matt Minkle:
    For this, we will need to add a constraint for each possible assignment of the years of starting for Peter Powers and Matt Minkle, such that Peter Powers' year of starting is less than Matt Minkle's year of starting. So, the constraints will be of the form:
    y1 == Peter Powers and y2 == Matt Minkle => y1_to_int < y2_to_int, for all y1, y2 in years of starting.

-   Gabe Grant began 1 year after Wonderman:
    For this, we will need to add a constraint for each possible assignment of the years of starting for Gabe Grant and Wonderman, such that Gabe Grant's year of starting is 1 more than Wonderman's year of starting. So, the constraints will be of the form:
    y1 == Gabe Grant and y2 == Wonderman => y1_to_int == y2_to_int + 1, for all y1, y2 in years of starting.

-   The four people are Deep Shadow, the superhero who started in 2007, the hero who started in 2009, and Matt Minkle:
    This constraint directly assigns the four people to the given entities:
    AllDifferent([Deep Shadow, 2007, 2009, Matt Minkle]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Gabe Grant == 1, and 2007 == 1, and Peter Powers == 1, then Gabe Grant is Ultra Hex who started in 2007 and began before Peter Powers.

### Decision variables:
-   Years of starting: 2007, 2008, 2009, 2010 (all different, 1 to 4)
-   Superheroes: Criminal Bane, Deep Shadow, Ultra Hex, Wonderman (all different, 1 to 4)
-   Names of the people: Gabe Grant, Ivor Ingram, Matt Minkle, Peter Powers (all different, 1 to 4)

### Constraints:
-   Ultra Hex is Gabe Grant:
    This constraint directly assigns Ultra Hex to Gabe Grant:
    Ultra Hex == Gabe Grant.

-   Criminal Bane is either the hero who started in 2007 or the superhero who started in 2009:
    This constraint states that Criminal Bane is either the hero who started in 2007 or the superhero who started in 2009, but not both. So:
    Xor([Criminal Bane == 2007, Criminal Bane == 2009]).

-   Peter Powers began sometime before Matt Minkle:
    For this, we will need to add a constraint for each possible assignment of the years of starting for Peter Powers and Matt Minkle, such that Peter Powers' year of starting is less than Matt Minkle's year of starting. So, the constraints will be of the form:
    y1 == Peter Powers and y2 == Matt Minkle => y1_to_int < y2_to_int, for all y1, y2 in years of starting.

-   Gabe Grant began 1 year after Wonderman:
    For this, we will need to add a constraint for each possible assignment of the years of starting for Gabe Grant and Wonderman, such that Gabe Grant's year of starting is 1 more than Wonderman's year of starting. So, the constraints will be of the form:
    y1 == Gabe Grant and y2 == Wonderman => y1_to_int == y2_to_int + 1, for all y1, y2 in years of starting.

-   The four people are Deep Shadow, the superhero who started in 2007, the hero who started in 2009, and Matt Minkle:
    This constraint directly assigns the four people to the given entities:
    AllDifferent([Deep Shadow, 2007, 2009, Matt Minkle]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of year, superhero, and name)
# e.g. if 2007 == 1 and deep_shadow == 1 and ivor_ingram == 1, then Deep Shadow started in 2007 and is Ivor Ingram
year_2007, year_2008, year_2009, year_2010 = years = intvar(1, 4, shape=4)
criminal_bane, deep_shadow, ultra_hex, wonderman = superheroes = intvar(1, 4, shape=4)
gabe_grant, ivor_ingram, matt_minkle, peter_powers = names = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
year_to_int = {year_2007: 2007, year_2008: 2008, year_2009: 2009, year_2010: 2010}  # in years
superhero_to_int = None  # N/A
name_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def started_before(var1, var2):
    """
    Formulate the constraint that var1 started before var2.
    """
    return [((y1 == var1) & (y2 == var2)).implies(year_to_int[y1] < year_to_int[y2])
            for y1 in years for y2 in years]


def started_exactly_after(var1, var2, diff):
    """
    Formulate the constraint that var1 started exactly diff years after var2.
    """
    return [((y1 == var1) & (y2 == var2)).implies(year_to_int[y1] == year_to_int[y2] + diff)
            for y1 in years for y2 in years]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(years)
m += AllDifferent(superheroes)
m += AllDifferent(names)

# Clue 1: Ultra Hex is Gabe Grant
m += ultra_hex == gabe_grant

# Clue 2: Criminal Bane is either the hero who started in 2007 or the superhero who started in 2009
m += Xor([
    criminal_bane == year_2007,
    criminal_bane == year_2009
])

# Clue 3: Peter Powers began sometime before Matt Minkle
m += started_before(peter_powers, matt_minkle)

# Clue 4: Gabe Grant began 1 year after Wonderman
m += started_exactly_after(gabe_grant, wonderman, 1)

# Clue 5: The four people are Deep Shadow, the superhero who started in 2007, the hero who started in 2009, and Matt Minkle
m += AllDifferent([deep_shadow, year_2007, year_2009, matt_minkle])

```
[['year_2007', 'criminal_bane', 'peter_powers'], ['year_2008', 'wonderman', 'matt_minkle'], ['year_2009', 'ultra_hex', 'gabe_grant'], ['year_2010', 'deep_shadow', 'ivor_ingram']]
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The Sancode interview is 1 day after the meeting for the copywriter position.
The Laneplex interview is on August 20th.
The meeting for the copywriter position is 2 days before the meeting for the web developer position.
The Haytouch interview is for the sales rep job.

Entities:
days: August 20th, August 21st, August 22nd, August 23rd
companies: Canway, Haytouch, Laneplex, Sancode
positions: copywriter, janitor, sales rep, web developer
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Canway == 1, and August20th == 1, and Copywriter == 1, then Canway has a meeting for the copywriter position on August 20th.

### Decision variables:
-   Days: August 20th, August 21st, August 22nd, August 23rd (all different, 1 to 4)
-   Companies: Canway, Haytouch, Laneplex, Sancode (all different, 1 to 4)
-   Positions: Copywriter, Janitor, Sales rep, Web developer (all different, 1 to 4)

### Constraints:
-   The Sancode interview is 1 day after the meeting for the copywriter position:
    For this, we will need to add a constraint for each possible assignment of days for the Sancode interview and the meeting for the copywriter position, such that the Sancode interview day is 1 more than the copywriter meeting day. So, the constraints will be of the form:
    d1 == Sancode and d2 == Copywriter => d1_to_int == d2_to_int + 1, for all d1, d2 in days.

-   The Laneplex interview is on August 20th:
    This is a constraint that directly states the assignment of Laneplex to August 20th:
    Laneplex == August20th.

-   The meeting for the copywriter position is 2 days before the meeting for the web developer position:
    For this, we will need to add a constraint for each possible assignment of days for the copywriter meeting and the web developer meeting, such that the copywriter meeting day is 2 less than the web developer meeting day. So, the constraints will be of the form:
    d1 == Copywriter and d2 == WebDeveloper => d1_to_int == d2_to_int - 2, for all d1, d2 in days.

-   The Haytouch interview is for the sales rep job:
    This is a constraint that directly states the assignment of Haytouch to the sales rep job:
    Haytouch == SalesRep.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Canway == 1, and August20th == 1, and Copywriter == 1, then Canway has a meeting for the copywriter position on August 20th.

### Decision variables:
-   Days: August 20th, August 21st, August 22nd, August 23rd (all different, 1 to 4)
-   Companies: Canway, Haytouch, Laneplex, Sancode (all different, 1 to 4)
-   Positions: Copywriter, Janitor, Sales rep, Web developer (all different, 1 to 4)

### Constraints:
-   The Sancode interview is 1 day after the meeting for the copywriter position:
    For this, we will need to add a constraint for each possible assignment of days for the Sancode interview and the meeting for the copywriter position, such that the Sancode interview day is 1 more than the copywriter meeting day. So, the constraints will be of the form:
    d1 == Sancode and d2 == Copywriter => d1_to_int == d2_to_int + 1, for all d1, d2 in days.

-   The Laneplex interview is on August 20th:
    This is a constraint that directly states the assignment of Laneplex to August 20th:
    Laneplex == August20th.

-   The meeting for the copywriter position is 2 days before the meeting for the web developer position:
    For this, we will need to add a constraint for each possible assignment of days for the copywriter meeting and the web developer meeting, such that the copywriter meeting day is 2 less than the web developer meeting day. So, the constraints will be of the form:
    d1 == Copywriter and d2 == WebDeveloper => d1_to_int == d2_to_int - 2, for all d1, d2 in days.

-   The Haytouch interview is for the sales rep job:
    This is a constraint that directly states the assignment of Haytouch to the sales rep job:
    Haytouch == SalesRep.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of day, company, and position)
# e.g. if canway == 1 and august20th == 1 and copywriter == 1, then Canway has a meeting for the copywriter position on August 20th
canway, haytouch, laneplex, sancode = companies = intvar(1, 4, shape=4)
august20th, august21st, august22nd, august23rd = days = intvar(1, 4, shape=4)
copywriter, janitor, salesrep, webdeveloper = positions = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
company_to_int = None  # N/A
day_to_int = {august20th: 20, august21st: 21, august22nd: 22, august23rd: 23}  # in days
position_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def day_after_than(var1, var2):
    """
    Formulate the constraint that var1 is 1 day after var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(day_to_int[d1] == day_to_int[d2] + 1)
            for d1 in days for d2 in days]


def day_before_than(var1, var2, diff):
    """
    Formulate the constraint that var1 is diff days before var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(day_to_int[d1] == day_to_int[d2] - diff)
            for d1 in days for d2 in days]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(companies)
m += AllDifferent(days)
m += AllDifferent(positions)

# Clue 1: The Sancode interview is 1 day after the meeting for the copywriter position:
m += day_after_than(sancode, copywriter)

# Clue 2: The Laneplex interview is on August 20th:
m += laneplex == august20th

# Clue 3: The meeting for the copywriter position is 2 days before the meeting for the web developer position:
m += day_before_than(copywriter, webdeveloper, 2)

# Clue 4: The Haytouch interview is for the sales rep job:
m += haytouch == salesrep

```
[['laneplex', 'august20th', 'copywriter'], ['haytouch', 'august23rd', 'salesrep'], ['sancode', 'august21st', 'janitor'], ['canway', 'august22nd', 'webdeveloper']]
True
True
True
Wrong: 0, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The Quince Street project will be headed by Freda Fisher.
Of the job starting in May and the Oak Road project, one will be headed by Dawn Daniels and the other will be headed by Irma Ingram.
Of the job starting in July and the job starting in April, one will focus on Oak Road and the other will be headed by Freda Fisher.
The Aspen Court project starts in May.
The Aspen Court project begins sometime after Dawn Daniels's project.

Entities:
months: April, May, June, July
streets: Aspen Court, Norway Court, Oak Road, Quince Street
managers: Bill Bonner, Dawn Daniels, Freda Fisher, Irma Ingram
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if AspenCourt == 1, and May == 1, and Freda == 1, then the Aspen Court project starts in May and is headed by Freda Fisher.

### Decision variables:
-   Months of project start: April, May, June, July (all different, 1 to 4)
-   Streets of the projects: Aspen Court, Norway Court, Oak Road, Quince Street (all different, 1 to 4)
-   Project managers: Bill Bonner, Dawn Daniels, Freda Fisher, Irma Ingram (all different, 1 to 4)

### Constraints:
-   The Quince Street project will be headed by Freda Fisher:
    This constraint directly assigns Freda Fisher to the Quince Street project:
    QuinceStreet == Freda.

-   Of the job starting in May and the Oak Road project, one will be headed by Dawn Daniels and the other will be headed by Irma Ingram:
    This constraint assigns Dawn Daniels to one project and Irma Ingram to the other, and also assigns May to one project and Oak Road to the other:
    (May == Dawn and OakRoad == Irma) or (May == Irma and OakRoad == Dawn).

-   Of the job starting in July and the job starting in April, one will focus on Oak Road and the other will be headed by Freda Fisher:
    This constraint assigns Freda Fisher to one project and Oak Road to the other, and also assigns July to one project and April to the other:
    (July == Freda and OakRoad == April) or (July == April and OakRoad == Freda).

-   The Aspen Court project starts in May:
    This constraint directly assigns May to the Aspen Court project:
    AspenCourt == May.

-   The Aspen Court project begins sometime after Dawn Daniels's project:
    This constraint ensures that the Aspen Court project starts after Dawn Daniels's project:
    AspenCourt > Dawn.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if AspenCourt == 1, and May == 1, and Freda == 1, then the Aspen Court project starts in May and is headed by Freda Fisher.

### Decision variables:
-   Months of project start: April, May, June, July (all different, 1 to 4)
-   Streets of the projects: Aspen Court, Norway Court, Oak Road, Quince Street (all different, 1 to 4)
-   Project managers: Bill Bonner, Dawn Daniels, Freda Fisher, Irma Ingram (all different, 1 to 4)

### Constraints:
-   The Quince Street project will be headed by Freda Fisher:
    This constraint directly assigns Freda Fisher to the Quince Street project:
    QuinceStreet == Freda.

-   Of the job starting in May and the Oak Road project, one will be headed by Dawn Daniels and the other will be headed by Irma Ingram:
    This constraint assigns Dawn Daniels to one project and Irma Ingram to the other, and also assigns May to one project and Oak Road to the other:
    (May == Dawn and OakRoad == Irma) or (May == Irma and OakRoad == Dawn).

-   Of the job starting in July and the job starting in April, one will focus on Oak Road and the other will be headed by Freda Fisher:
    This constraint assigns Freda Fisher to one project and Oak Road to the other, and also assigns July to one project and April to the other:
    (July == Freda and OakRoad == April) or (July == April and OakRoad == Freda).

-   The Aspen Court project starts in May:
    This constraint directly assigns May to the Aspen Court project:
    AspenCourt == May.

-   The Aspen Court project begins sometime after Dawn Daniels's project:
    This constraint ensures that the Aspen Court project starts after Dawn Daniels's project:
    AspenCourt > Dawn.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of month, street, and manager)
# e.g. if april == 1 and quince == 1 and freda == 1, then the Quince Street project starts in April and is headed by Freda Fisher
april, may, june, july = months = intvar(1, 4, shape=4)
aspen_court, norway_court, oak_road, quince_street = streets = intvar(1, 4, shape=4)
bill, dawn, freda, irma = managers = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
month_to_int = {april: 1, may: 2, june: 3, july: 4}  # in months
street_to_int = None  # N/A
manager_to_int = None  # N/A


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(months)
m += AllDifferent(streets)
m += AllDifferent(managers)

# Clue 1: The Quince Street project will be headed by Freda Fisher:
m += quince_street == freda

# Clue 2: Of the job starting in May and the Oak Road project, one will be headed by Dawn Daniels and the other will be headed by Irma Ingram:
m += ((may == dawn) & (oak_road == irma)) | ((may == irma) & (oak_road == dawn))

# Clue 3: Of the job starting in July and the job starting in April, one will focus on Oak Road and the other will be headed by Freda Fisher:
m += ((july == freda) & (oak_road == april)) | ((july == april) & (oak_road == freda))

# Clue 4: The Aspen Court project starts in May:
m += aspen_court == may

# Clue 5: The Aspen Court project begins sometime after Dawn Daniels's project:
m += aspen_court > dawn

```
[['april', 'oak_road', 'dawn'], ['may', 'aspen_court', 'irma'], ['june', 'norway_court', 'bill'], ['july', 'quince_street', 'freda']]
True
False
False
Wrong: 3, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Of Sophie and Gwen, one will bring their rabbit's foot and the other will leave in January.
Sophie will leave sometime before Gwen.
The passenger with the lucky hat, Gwen and Sophie are all different fliers.
Florence will leave 2 months after the passenger with the lucky hat.
The passenger leaving in April is either Gwen or the passenger with the talisman.

Entities:
months: January, February, March, April
fliers: Florence, Gwen, Olive, Sophie
lucky charms: coin, lucky hat, rabbit's foot, talisman
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Florence == 1, and January == 1, and Coin == 1, then Florence is the flier leaving in January with a coin.

### Decision variables:
-   Months of departure: January, February, March, April (all different, 1 to 4)
-   Names of the fliers: Florence, Gwen, Olive, Sophie (all different, 1 to 4)
-   Lucky charms: Coin, LuckyHat, RabbitFoot, Talisman (all different, 1 to 4)

### Constraints:
-   Of Sophie and Gwen, one will bring their rabbit's foot and the other will leave in January:
    This constraint states that Sophie and Gwen have different lucky charms and different months of departure. So, we need to add constraints to ensure that one has the RabbitFoot and leaves in January, while the other does not have the RabbitFoot and does not leave in January.

-   Sophie will leave sometime before Gwen:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Sophie and Gwen, such that Sophie's month of departure is less than Gwen's month of departure. So, the constraints will be of the form:
    m1 == Sophie and m2 == Gwen => m1_to_int < m2_to_int, for all m1, m2 in months of departure.

-   The passenger with the lucky hat, Gwen, and Sophie are all different fliers:
    This is a constraint that states that all these entities are different, thus:
    AllDifferent([LuckyHat, Gwen, Sophie]).

-   Florence will leave 2 months after the passenger with the lucky hat:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Florence and the passenger with the lucky hat, such that Florence's month of departure is 2 more than the lucky hat's month of departure. So, the constraints will be of the form:
    m1 == Florence and m2 == LuckyHat => m1_to_int == m2_to_int + 2, for all m1, m2 in months of departure.

-   The passenger leaving in April is either Gwen or the passenger with the talisman:
    This is a constraint that states that the flier leaving in April is either Gwen or the flier with the talisman, but not both. Thus:
    Xor([Gwen == April, Talisman == April]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Florence == 1, and January == 1, and Coin == 1, then Florence is the flier leaving in January with a coin.

### Decision variables:
-   Months of departure: January, February, March, April (all different, 1 to 4)
-   Names of the fliers: Florence, Gwen, Olive, Sophie (all different, 1 to 4)
-   Lucky charms: Coin, LuckyHat, RabbitFoot, Talisman (all different, 1 to 4)

### Constraints:
-   Of Sophie and Gwen, one will bring their rabbit's foot and the other will leave in January:
    This constraint states that Sophie and Gwen have different lucky charms and different months of departure. So, we need to add constraints to ensure that one has the RabbitFoot and leaves in January, while the other does not have the RabbitFoot and does not leave in January.

-   Sophie will leave sometime before Gwen:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Sophie and Gwen, such that Sophie's month of departure is less than Gwen's month of departure. So, the constraints will be of the form:
    m1 == Sophie and m2 == Gwen => m1_to_int < m2_to_int, for all m1, m2 in months of departure.

-   The passenger with the lucky hat, Gwen, and Sophie are all different fliers:
    This is a constraint that states that all these entities are different, thus:
    AllDifferent([LuckyHat, Gwen, Sophie]).

-   Florence will leave 2 months after the passenger with the lucky hat:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Florence and the passenger with the lucky hat, such that Florence's month of departure is 2 more than the lucky hat's month of departure. So, the constraints will be of the form:
    m1 == Florence and m2 == LuckyHat => m1_to_int == m2_to_int + 2, for all m1, m2 in months of departure.

-   The passenger leaving in April is either Gwen or the passenger with the talisman:
    This is a constraint that states that the flier leaving in April is either Gwen or the flier with the talisman, but not both. Thus:
    Xor([Gwen == April, Talisman == April]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of flier, month, and lucky charm)
# e.g. if florence == 1 and january == 1 and coin == 1, then Florence will leave in January with a coin
florence, gwen, olive, sophie = fliers = intvar(1, 4, shape=4)
january, february, march, april = months = intvar(1, 4, shape=4)
coin, luckyhat, rabbitfoot, talisman = lucky_charms = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
flier_to_int = None  # N/A
month_to_int = {january: 1, february: 2, march: 3, april: 4}  # in months
lucky_charm_to_int = {coin: 1, luckyhat: 2, rabbitfoot: 3, talisman: 4}  # in lucky charms


# Helper functions (for formulating comparison constraints)
def left_before_than(var1, var2):
    """
    Formulate the constraint that var1 left before var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] < month_to_int[m2])
            for m1 in months for m2 in months]


def left_exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 left exactly diff months after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] == month_to_int[m2] + diff)
            for m1 in months for m2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(fliers)
m += AllDifferent(months)
m += AllDifferent(lucky_charms)

# Clue 1: Of Sophie and Gwen, one will bring their rabbit's foot and the other will leave in January:
m += [
    ((sophie == rabbitfoot) & (gwen != rabbitfoot) & (sophie == january) & (gwen != january)),
    ((gwen == rabbitfoot) & (sophie != rabbitfoot) & (gwen == january) & (sophie != january))
]

# Clue 2: Sophie will leave sometime before Gwen:
m += left_before_than(sophie, gwen)

# Clue 3: The passenger with the lucky hat, Gwen, and Sophie are all different fliers:
m += AllDifferent([luckyhat, gwen, sophie])

# Clue 4: Florence will leave 2 months after the passenger with the lucky hat:
m += left_exactly_after_than(florence, luckyhat, 2)

# Clue 5: The passenger leaving in April is either Gwen or the passenger with the talisman:
m += Xor([
    gwen == april,
    talisman == april
])

```
None
False
False
False
Wrong: 1, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The Iunsel launched in February.
The Munei is going to Mars.
The Munei launched 1 month after the mission going to Pluto.
Of the mission going to Ganymede and the mission going to Pluto, one launched in March and the other is the Chano.

Entities:
months: January, February, March, April
probes: Ateyin, Chano, Iunsel, Munei
destinations: Ganymede, Mars, Pluto, Uranus
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ateyin == 1, and January == 1, and Ganymede == 1, then Ateyin is the probe going to Ganymede launched in January.

### Decision variables:
-   Names of the probes: Ateyin, Chano, Iunsel, Munei (all different, 1 to 4)
-   Months of launch: January, February, March, April (all different, 1 to 4)
-   Destinations: Ganymede, Mars, Pluto, Uranus (all different, 1 to 4)

### Constraints:
-   The Iunsel launched in February:
    This constraint directly assigns the month of launch for the Iunsel probe:
    Iunsel == February.

-   The Munei is going to Mars:
    This constraint directly assigns the destination for the Munei probe:
    Munei == Mars.

-   The Munei launched 1 month after the mission going to Pluto:
    For this, we will need to add a constraint for each possible assignment of the months of launch for the Munei probe and the mission going to Pluto, such that the Munei's month of launch is 1 greater than the Pluto mission's month of launch. So, the constraints will be of the form:
    m1 == Munei and m2 == Pluto => m1_to_int == m2_to_int + 1, for all m1, m2 in months of launch.

-   Of the mission going to Ganymede and the mission going to Pluto, one launched in March and the other is the Chano:
    This constraint states that one of the missions went to Ganymede and the other to Pluto, one launched in March, and the other is the Chano probe. So, we can represent this as:
    (Ganymede == March and Pluto == Chano) or (Pluto == March and Ganymede == Chano).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ateyin == 1, and January == 1, and Ganymede == 1, then Ateyin is the probe going to Ganymede launched in January.

### Decision variables:
-   Names of the probes: Ateyin, Chano, Iunsel, Munei (all different, 1 to 4)
-   Months of launch: January, February, March, April (all different, 1 to 4)
-   Destinations: Ganymede, Mars, Pluto, Uranus (all different, 1 to 4)

### Constraints:
-   The Iunsel launched in February:
    This constraint directly assigns the month of launch for the Iunsel probe:
    Iunsel == February.

-   The Munei is going to Mars:
    This constraint directly assigns the destination for the Munei probe:
    Munei == Mars.

-   The Munei launched 1 month after the mission going to Pluto:
    For this, we will need to add a constraint for each possible assignment of the months of launch for the Munei probe and the mission going to Pluto, such that the Munei's month of launch is 1 greater than the Pluto mission's month of launch. So, the constraints will be of the form:
    m1 == Munei and m2 == Pluto => m1_to_int == m2_to_int + 1, for all m1, m2 in months of launch.

-   Of the mission going to Ganymede and the mission going to Pluto, one launched in March and the other is the Chano:
    This constraint states that one of the missions went to Ganymede and the other to Pluto, one launched in March, and the other is the Chano probe. So, we can represent this as:
    (Ganymede == March and Pluto == Chano) or (Pluto == March and Ganymede == Chano).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of probe, month, and destination)
# e.g. if ateyin == 1 and january == 1 and ganymede == 1, then Ateyin is the probe going to Ganymede launched in January
ateyin, chano, iunsel, munei = probes = intvar(1, 4, shape=4)
january, february, march, april = months = intvar(1, 4, shape=4)
ganymede, mars, pluto, uranus = destinations = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
probe_to_int = None  # N/A
month_to_int = {january: 1, february: 2, march: 3, april: 4}  # in months
destination_to_int = {ganymede: 1, mars: 2, pluto: 3, uranus: 4}  # in destinations


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(probes)
m += AllDifferent(months)
m += AllDifferent(destinations)

# Clue 1: The Iunsel launched in February
m += iunsel == february

# Clue 2: The Munei is going to Mars
m += munei == mars

# Clue 3: The Munei launched 1 month after the mission going to Pluto
m += [((m1 == munei) & (m2 == pluto)).implies(month_to_int[m1] == month_to_int[m2] + 1)
      for m1 in months for m2 in months]

# Clue 4: Of the mission going to Ganymede and the mission going to Pluto, one launched in March and the other is the Chano
m += ((ganymede == march) & (pluto == chano)) | ((pluto == march) & (ganymede == chano)

```
None
Error when trying to check solution from predicted model: invalid syntax (<string>, line 1)
False
False
Error in constraint evaluation: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
The blue topaz sold for 10 dollars more than the gem found in the Osborne claim.
The rhodolite went for $820.
The tourmaline is either the gem that sold for $810 or the gem found in the Underwood claim.
Of the gem found in the Collins claim and the aquamarine, one went for $790 and the other went for $800.

Entities:
prices: $790, $800, $810, $820
gems: aquamarine, blue topaz, rhodolite, tourmaline
claims: Collins, Knox, Osborne, Underwood
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Aquamarine == 1, and Price790 == 1, and Collins == 1, then the aquamarine found in the Collins claim went for $790.

### Decision variables:
-   Prices of the gems: Price790, Price800, Price810, Price820 (all different, 1 to 4)
-   Names of the gems: Aquamarine, BlueTopaz, Rhodolite, Tourmaline (all different, 1 to 4)
-   Claims where gems were found: Collins, Knox, Osborne, Underwood (all different, 1 to 4)

### Constraints:
-   The blue topaz sold for 10 dollars more than the gem found in the Osborne claim:
    For this, we will need to add a constraint for each possible assignment of prices to the blue topaz and the gem found in the Osborne claim, such that the blue topaz's price is 10 dollars more than the Osborne claim gem's price. So, the constraints will be of the form:
    p1 == BlueTopaz and p2 == Osborne => p1_to_int == p2_to_int + 10, for all p1, p2 in prices.

-   The rhodolite went for $820:
    This is a simple constraint that states the price of the rhodolite:
    Rhodolite == Price820.

-   The tourmaline is either the gem that sold for $810 or the gem found in the Underwood claim:
    This is a constraint that states that the tourmaline's price is either $810 or the gem found in the Underwood claim, but not both. So:
    Xor([Tourmaline == Price810, Tourmaline == Underwood]).

-   Of the gem found in the Collins claim and the aquamarine, one went for $790 and the other went for $800:
    This is a constraint that states that the gem found in the Collins claim and the aquamarine have prices of $790 and $800, but we don't know which one has which price. So, the constraints will be of the form:
    (Collins == Price790 and Aquamarine == Price800) or (Collins == Price800 and Aquamarine == Price790).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Aquamarine == 1, and Price790 == 1, and Collins == 1, then the aquamarine found in the Collins claim went for $790.

### Decision variables:
-   Prices of the gems: Price790, Price800, Price810, Price820 (all different, 1 to 4)
-   Names of the gems: Aquamarine, BlueTopaz, Rhodolite, Tourmaline (all different, 1 to 4)
-   Claims where gems were found: Collins, Knox, Osborne, Underwood (all different, 1 to 4)

### Constraints:
-   The blue topaz sold for 10 dollars more than the gem found in the Osborne claim:
    For this, we will need to add a constraint for each possible assignment of prices to the blue topaz and the gem found in the Osborne claim, such that the blue topaz's price is 10 dollars more than the Osborne claim gem's price. So, the constraints will be of the form:
    p1 == BlueTopaz and p2 == Osborne => p1_to_int == p2_to_int + 10, for all p1, p2 in prices.

-   The rhodolite went for $820:
    This is a simple constraint that states the price of the rhodolite:
    Rhodolite == Price820.

-   The tourmaline is either the gem that sold for $810 or the gem found in the Underwood claim:
    This is a constraint that states that the tourmaline's price is either $810 or the gem found in the Underwood claim, but not both. So:
    Xor([Tourmaline == Price810, Tourmaline == Underwood]).

-   Of the gem found in the Collins claim and the aquamarine, one went for $790 and the other went for $800:
    This is a constraint that states that the gem found in the Collins claim and the aquamarine have prices of $790 and $800, but we don't know which one has which price. So, the constraints will be of the form:
    (Collins == Price790 and Aquamarine == Price800) or (Collins == Price800 and Aquamarine == Price790).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of price, gem, and claim)
# e.g. if aquamarine == 1 and price790 == 1 and collins == 1, then the aquamarine found in the Collins claim went for $790
price790, price800, price810, price820 = prices = intvar(1, 4, shape=4)
aquamarine, blue_topaz, rhodolite, tourmaline = gems = intvar(1, 4, shape=4)
collins, knox, osborne, underwood = claims = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
price_to_int = {price790: 790, price800: 800, price810: 810, price820: 820}  # in dollars
gem_to_int = None  # N/A
claim_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def sold_for_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 sold for diff dollars more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] + diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(prices)
m += AllDifferent(gems)
m += AllDifferent(claims)

# Clue 1: The blue topaz sold for 10 dollars more than the gem found in the Osborne claim:
m += sold_for_more_than(blue_topaz, osborne, 10)

# Clue 2: The rhodolite went for $820:
m += rhodolite == price820

# Clue 3: The tourmaline is either the gem that sold for $810 or the gem found in the Underwood claim:
m += Xor([
    tourmaline == price810,
    tourmaline == underwood
])

# Clue 4: Of the gem found in the Collins claim and the aquamarine, one went for $790 and the other went for $800:
m += ((collins == price790) & (aquamarine == price800)) | ((collins == price800) & (aquamarine == price790))

```
[['price790', 'aquamarine', 'osborne'], ['price800', 'blue_topaz', 'collins'], ['price810', 'tourmaline', 'knox'], ['price820', 'rhodolite', 'underwood']]
True
True
True
Wrong: 1, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The facility launching in March is the tokamak reactor.
The reactor launching in April is either the direct drive facility or the z-pinch facility.
Of the fusor reactor and the z-pinch facility, one will launch in February and the other is the Kuchiwa W10.
The Essita CBT will launch in February.
The Haramarui LV will launch 1 month before the fusor reactor.

Entities:
months: January, February, March, April
names: Essita CBT, Haramarui LV, Kuchiwa W10, Rodim-Rexit
types: direct drive, fusor, tokamak, z-pinch
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if EssitaCBT == 1, and January == 1, and DirectDrive == 1, then Essita CBT is the direct drive facility launching in January.

### Decision variables:
-   Months of launch: January, February, March, April (all different, 1 to 4)
-   Names of the facilities: Essita CBT, Haramarui LV, Kuchiwa W10, Rodim-Rexit (all different, 1 to 4)
-   Types of reactors: Direct Drive, Fusor, Tokamak, Z-Pinch (all different, 1 to 4)

### Constraints:
-   The facility launching in March is the tokamak reactor:
    This constraint directly assigns the tokamak reactor to the month of March:
    Tokamak == March.

-   The reactor launching in April is either the direct drive facility or the z-pinch facility:
    This constraint states that the reactor launching in April is either the direct drive facility or the z-pinch facility:
    (DirectDrive == April) or (ZPinch == April).

-   Of the fusor reactor and the z-pinch facility, one will launch in February and the other is the Kuchiwa W10:
    This constraint states that one of the fusor reactor and the z-pinch facility will launch in February and the other is the Kuchiwa W10:
    (Fusor == February and ZPinch == KuchiwaW10) or (ZPinch == February and Fusor == KuchiwaW10).

-   The Essita CBT will launch in February:
    This constraint directly assigns the Essita CBT facility to the month of February:
    EssitaCBT == February.

-   The Haramarui LV will launch 1 month before the fusor reactor:
    This constraint states that the Haramarui LV will launch 1 month before the fusor reactor:
    HaramaruiLV_to_int == Fusor_to_int - 1.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if EssitaCBT == 1, and January == 1, and DirectDrive == 1, then Essita CBT is the direct drive facility launching in January.

### Decision variables:
-   Months of launch: January, February, March, April (all different, 1 to 4)
-   Names of the facilities: Essita CBT, Haramarui LV, Kuchiwa W10, Rodim-Rexit (all different, 1 to 4)
-   Types of reactors: Direct Drive, Fusor, Tokamak, Z-Pinch (all different, 1 to 4)

### Constraints:
-   The facility launching in March is the tokamak reactor:
    This constraint directly assigns the tokamak reactor to the month of March:
    Tokamak == March.

-   The reactor launching in April is either the direct drive facility or the z-pinch facility:
    This constraint states that the reactor launching in April is either the direct drive facility or the z-pinch facility:
    (DirectDrive == April) or (ZPinch == April).

-   Of the fusor reactor and the z-pinch facility, one will launch in February and the other is the Kuchiwa W10:
    This constraint states that one of the fusor reactor and the z-pinch facility will launch in February and the other is the Kuchiwa W10:
    (Fusor == February and ZPinch == KuchiwaW10) or (ZPinch == February and Fusor == KuchiwaW10).

-   The Essita CBT will launch in February:
    This constraint directly assigns the Essita CBT facility to the month of February:
    EssitaCBT == February.

-   The Haramarui LV will launch 1 month before the fusor reactor:
    This constraint states that the Haramarui LV will launch 1 month before the fusor reactor:
    HaramaruiLV_to_int == Fusor_to_int - 1.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of month, facility, and reactor type)
# e.g. if essitaCBT == 1 and january == 1 and directDrive == 1, then Essita CBT is the direct drive facility launching in January
essitaCBT, haramaruiLV, kuchiwaW10, rodimRexit = facilities = intvar(1, 4, shape=4)
january, february, march, april = months = intvar(1, 4, shape=4)
directDrive, fusor, tokamak, zPinch = reactors = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
facility_to_int = None  # N/A
month_to_int = {january: 1, february: 2, march: 3, april: 4}  # in months
reactor_to_int = {directDrive: 1, fusor: 2, tokamak: 3, zPinch: 4}  # in types


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(facilities)
m += AllDifferent(months)
m += AllDifferent(reactors)

# Clue 1: The facility launching in March is the tokamak reactor
m += tokamak == march

# Clue 2: The reactor launching in April is either the direct drive facility or the z-pinch facility
m += (directDrive == april) | (zPinch == april)

# Clue 3: Of the fusor reactor and the z-pinch facility, one will launch in February and the other is the Kuchiwa W10
m += ((fusor == february) & (zPinch == kuchiwaW10)) | ((zPinch == february) & (fusor == kuchiwaW10))

# Clue 4: The Essita CBT will launch in February
m += essitaCBT == february

# Clue 5: The Haramarui LV will launch 1 month before the fusor reactor
m += haramaruiLV == fusor - 1

```
[['essitaCBT', 'february', 'zPinch'], ['haramaruiLV', 'april', 'directDrive'], ['kuchiwaW10', 'january', 'fusor'], ['rodimRexit', 'march', 'tokamak']]
False
False
False
Wrong: 3, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Of the anniversary event and the event with 100 attendees, one will be handled by Joel and the other will be handled by Susan.
Herbert's assignment will involve 25 fewer people than Susan's assignment.
Of the assignment with 75 attendees and the assignment with 100 attendees, one will be handled by Susan and the other is the birthday.
Herbert's event is either the event with 50 attendees or the graduation job.

Entities:
people: 50, 75, 100, 125
planners: Herbert, Joel, Susan, Teresa
events: anniversary, birthday, graduation, wedding
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if 50 == 1, and Herbert == 1, and Anniversary == 1, then the event with 50 attendees is the anniversary event handled by Herbert.

### Decision variables:
-   Number of people attending: 50, 75, 100, 125 (all different, 1 to 4)
-   Names of the planners: Herbert, Joel, Susan, Teresa (all different, 1 to 4)
-   Types of events: Anniversary, Birthday, Graduation, Wedding (all different, 1 to 4)

### Constraints:
-   Of the anniversary event and the event with 100 attendees, one will be handled by Joel and the other will be handled by Susan:
    This constraint states that Joel will handle one of the events (anniversary or 100 attendees) and Susan will handle the other. So, we can represent this as:
    (Anniversary == Joel and People100 == Susan) or (Anniversary == Susan and People100 == Joel).

-   Herbert's assignment will involve 25 fewer people than Susan's assignment:
    This constraint states that the number of people attending Herbert's event is 25 fewer than the number of people attending Susan's event. So, we can represent this as:
    Herbert_to_int == Susan_to_int - 25.

-   Of the assignment with 75 attendees and the assignment with 100 attendees, one will be handled by Susan and the other is the birthday:
    This constraint states that Susan will handle one of the events (75 attendees or 100 attendees) and the other event is the birthday. So, we can represent this as:
    (People75 == Susan and Birthday == Susan) or (People75 == Birthday and Birthday == Susan).

-   Herbert's event is either the event with 50 attendees or the graduation job:
    This constraint states that Herbert's event is either the event with 50 attendees or the graduation event. So, we can represent this as:
    (People50 == Herbert) or (Graduation == Herbert).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if 50 == 1, and Herbert == 1, and Anniversary == 1, then the event with 50 attendees is the anniversary event handled by Herbert.

### Decision variables:
-   Number of people attending: 50, 75, 100, 125 (all different, 1 to 4)
-   Names of the planners: Herbert, Joel, Susan, Teresa (all different, 1 to 4)
-   Types of events: Anniversary, Birthday, Graduation, Wedding (all different, 1 to 4)

### Constraints:
-   Of the anniversary event and the event with 100 attendees, one will be handled by Joel and the other will be handled by Susan:
    This constraint states that Joel will handle one of the events (anniversary or 100 attendees) and Susan will handle the other. So, we can represent this as:
    (Anniversary == Joel and People100 == Susan) or (Anniversary == Susan and People100 == Joel).

-   Herbert's assignment will involve 25 fewer people than Susan's assignment:
    This constraint states that the number of people attending Herbert's event is 25 fewer than the number of people attending Susan's event. So, we can represent this as:
    Herbert_to_int == Susan_to_int - 25.

-   Of the assignment with 75 attendees and the assignment with 100 attendees, one will be handled by Susan and the other is the birthday:
    This constraint states that Susan will handle one of the events (75 attendees or 100 attendees) and the other event is the birthday. So, we can represent this as:
    (People75 == Susan and Birthday == Susan) or (People75 == Birthday and Birthday == Susan).

-   Herbert's event is either the event with 50 attendees or the graduation job:
    This constraint states that Herbert's event is either the event with 50 attendees or the graduation event. So, we can represent this as:
    (People50 == Herbert) or (Graduation == Herbert).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of people, planner, and event)
# e.g. if people50 == 1 and herbert == 1 and anniversary == 1, then the event with 50 attendees is the anniversary event handled by Herbert.
people50, people75, people100, people125 = people = intvar(1, 4, shape=4)
herbert, joel, susan, teresa = planners = intvar(1, 4, shape=4)
anniversary, birthday, graduation, wedding = events = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
people_to_int = {people50: 50, people75: 75, people100: 100, people125: 125}  # number of people
planner_to_int = None  # N/A
event_to_int = None  # N/A


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(people)
m += AllDifferent(planners)
m += AllDifferent(events)

# Clue 1: Of the anniversary event and the event with 100 attendees, one will be handled by Joel and the other will be handled by Susan:
m += ((anniversary == joel) & (people100 == susan)) | ((anniversary == susan) & (people100 == joel))

# Clue 2: Herbert's assignment will involve 25 fewer people than Susan's assignment:
m += herbert == susan - 25

# Clue 3: Of the assignment with 75 attendees and the assignment with 100 attendees, one will be handled by Susan and the other is the birthday:
m += ((people75 == susan) & (birthday == susan)) | ((people75 == birthday) & (birthday == susan))

# Clue 4: Herbert's event is either the event with 50 attendees or the graduation job:
m += (people50 == herbert) | (graduation == herbert)

```
None
False
False
False
Wrong: 4, Total: 7
---------------------------------------------------------------------------------------------

Clues:
D. forcilitis has 500 genes.
B. mangeris was either the one sequenced by Dr. Ortiz or the organism with 750 genes.
The organism sequenced by Dr. Trujillo has 500 more genes than the bacteria sequenced by Dr. Nielsen.
Of the bacteria sequenced by Dr. Jordan and the bacteria sequenced by Dr. Trujillo, one has 1000 genes and the other is E. carolinus.

Entities:
genes: 250, 500, 750, 1000
bacteria: B. mangeris, D. forcilitis, E. carolinus, P. wellington
doctors: Jordan, Nielsen, Ortiz, Trujillo
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Bmangeris == 1, and DrOrtiz == 1, and Genes750 == 1, then B. mangeris was sequenced by Dr. Ortiz and has 750 genes.

### Decision variables:
-   Names of the bacteria: B. mangeris, D. forcilitis, E. carolinus, P. wellington (all different, 1 to 4)
-   Doctors who sequenced the bacteria: Jordan, Nielsen, Ortiz, Trujillo (all different, 1 to 4)
-   Number of genes: Genes250, Genes500, Genes750, Genes1000 (all different, 1 to 4)

### Constraints:
-   D. forcilitis has 500 genes:
    This constraint directly assigns D. forcilitis to have 500 genes:
    Dforcilitis == Genes500.

-   B. mangeris was either the one sequenced by Dr. Ortiz or the organism with 750 genes:
    This constraint states that B. mangeris was either sequenced by Dr. Ortiz or has 750 genes, but not both:
    Xor([Bmangeris == DrOrtiz, Bmangeris == Genes750]).

-   The organism sequenced by Dr. Trujillo has 500 more genes than the bacteria sequenced by Dr. Nielsen:
    For this, we will need to add a constraint for each possible assignment of genes to the bacteria sequenced by Dr. Nielsen and Dr. Trujillo, such that the genes of the organism sequenced by Dr. Trujillo is 500 more than the bacteria sequenced by Dr. Nielsen. So, the constraints will be of the form:
    b1 == Nielsen and b2 == Trujillo => b2_to_int == b1_to_int + 500, for all b1, b2 in genes.

-   Of the bacteria sequenced by Dr. Jordan and the bacteria sequenced by Dr. Trujillo, one has 1000 genes and the other is E. carolinus:
    This constraint states that one of the bacteria sequenced by Dr. Jordan and Dr. Trujillo has 1000 genes, and the other is E. carolinus. So, we will need to add constraints to ensure this:
    (Jordangenesto_int == Genes1000 and Trujillogenesto_int == Ecarolinus) or (Jordangenesto_int == Ecarolinus and Trujillogenesto_int == Genes1000).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Bmangeris == 1, and DrOrtiz == 1, and Genes750 == 1, then B. mangeris was sequenced by Dr. Ortiz and has 750 genes.

### Decision variables:
-   Names of the bacteria: B. mangeris, D. forcilitis, E. carolinus, P. wellington (all different, 1 to 4)
-   Doctors who sequenced the bacteria: Jordan, Nielsen, Ortiz, Trujillo (all different, 1 to 4)
-   Number of genes: Genes250, Genes500, Genes750, Genes1000 (all different, 1 to 4)

### Constraints:
-   D. forcilitis has 500 genes:
    This constraint directly assigns D. forcilitis to have 500 genes:
    Dforcilitis == Genes500.

-   B. mangeris was either the one sequenced by Dr. Ortiz or the organism with 750 genes:
    This constraint states that B. mangeris was either sequenced by Dr. Ortiz or has 750 genes, but not both:
    Xor([Bmangeris == DrOrtiz, Bmangeris == Genes750]).

-   The organism sequenced by Dr. Trujillo has 500 more genes than the bacteria sequenced by Dr. Nielsen:
    For this, we will need to add a constraint for each possible assignment of genes to the bacteria sequenced by Dr. Nielsen and Dr. Trujillo, such that the genes of the organism sequenced by Dr. Trujillo is 500 more than the bacteria sequenced by Dr. Nielsen. So, the constraints will be of the form:
    b1 == Nielsen and b2 == Trujillo => b2_to_int == b1_to_int + 500, for all b1, b2 in genes.

-   Of the bacteria sequenced by Dr. Jordan and the bacteria sequenced by Dr. Trujillo, one has 1000 genes and the other is E. carolinus:
    This constraint states that one of the bacteria sequenced by Dr. Jordan and Dr. Trujillo has 1000 genes, and the other is E. carolinus. So, we will need to add constraints to ensure this:
    (Jordangenesto_int == Genes1000 and Trujillogenesto_int == Ecarolinus) or (Jordangenesto_int == Ecarolinus and Trujillogenesto_int == Genes1000).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of bacteria, doctor, and genes)
# e.g. if bmangeris == 1 and drortiz == 1 and genes750 == 1, then B. mangeris was sequenced by Dr. Ortiz and has 750 genes
bmangeris, dforcilitis, ecarolinus, pwellington = bacteria = intvar(1, 4, shape=4)
jordan, nielsen, ortiz, trujillo = doctors = intvar(1, 4, shape=4)
genes250, genes500, genes750, genes1000 = genes = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
bacteria_to_int = None  # N/A
doctor_to_int = None  # N/A
genes_to_int = {genes250: 250, genes500: 500, genes750: 750, genes1000: 1000}  # in number of genes


# Helper functions (for formulating comparison constraints)
def has_more_genes(var1, var2, diff):
    """
    Formulate the constraint that var1 has diff more genes than var2.
    """
    return [((b1 == var1) & (b2 == var2)).implies(genes_to_int[b1] == genes_to_int[b2] + diff)
            for b1 in genes for b2 in genes]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(bacteria)
m += AllDifferent(doctors)
m += AllDifferent(genes)

# Clue 1: D. forcilitis has 500 genes
m += dforcilitis == genes500

# Clue 2: B. mangeris was either the one sequenced by Dr. Ortiz or the organism with 750 genes
m += Xor([
    bmangeris == ortiz,
    bmangeris == genes750
])

# Clue 3: The organism sequenced by Dr. Trujillo has 500 more genes than the bacteria sequenced by Dr. Nielsen
m += has_more_genes(trujillo, nielsen, 500)

# Clue 4: Of the bacteria sequenced by Dr. Jordan and the bacteria sequenced by Dr. Trujillo, one has 1000 genes and the other is E. carolinus
m += ((jordan == genes1000) & (trujillo == ecarolinus)) | ((jordan == ecarolinus) & (trujillo == genes1000)

```
None
Error when trying to check solution from predicted model: invalid syntax (<string>, line 1)
False
False
Error in constraint evaluation: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
The mountain that is 210 feet tall was climbed by Leonard Lara.
Of Mt. Brewer and Mt. Quinn, one was climbed by Ben Beasley and the other is 470 feet tall.
Mt. Brewer is either the mountain summited by Leonard Lara or the peak that is 600 feet tall.
Mt. York was climbed by Kermit Kramer.

Entities:
heights: 210, 340, 470, 600
mountains: Mt. Brewer, Mt. Gillespie, Mt. Quinn, Mt. York
climbers: Ben Beasley, Eddie English, Kermit Kramer, Leonard Lara
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Leonard Lara == 1, and Mt. Brewer == 1, and Height210 == 1, then Leonard Lara climbed Mt. Brewer, which is 210 feet tall.

### Decision variables:
-   Names of the climbers: Ben Beasley, Eddie English, Kermit Kramer, Leonard Lara (all different, 1 to 4)
-   Heights of the mountains: 210, 340, 470, 600 (all different, 1 to 4)
-   Names of the mountains: Mt. Brewer, Mt. Gillespie, Mt. Quinn, Mt. York (all different, 1 to 4)

### Constraints:
-   The mountain that is 210 feet tall was climbed by Leonard Lara:
    This constraint directly assigns the mountain of 210 feet to Leonard Lara:
    Leonard Lara == Height210.

-   Of Mt. Brewer and Mt. Quinn, one was climbed by Ben Beasley and the other is 470 feet tall:
    This constraint states that one of Mt. Brewer or Mt. Quinn is climbed by Ben Beasley and the other is 470 feet tall. So, we can represent this as:
    (Ben Beasley == Mt. Brewer and Mt. Brewer == Height470) or (Ben Beasley == Mt. Quinn and Mt. Quinn == Height470).

-   Mt. Brewer is either the mountain summited by Leonard Lara or the peak that is 600 feet tall:
    This constraint states that Mt. Brewer is either climbed by Leonard Lara or is 600 feet tall, but not both. So, we can represent this as:
    Xor([Mt. Brewer == Leonard Lara, Mt. Brewer == Height600]).

-   Mt. York was climbed by Kermit Kramer:
    This constraint directly assigns Mt. York to Kermit Kramer:
    Kermit Kramer == Mt. York.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Leonard Lara == 1, and Mt. Brewer == 1, and Height210 == 1, then Leonard Lara climbed Mt. Brewer, which is 210 feet tall.

### Decision variables:
-   Names of the climbers: Ben Beasley, Eddie English, Kermit Kramer, Leonard Lara (all different, 1 to 4)
-   Heights of the mountains: 210, 340, 470, 600 (all different, 1 to 4)
-   Names of the mountains: Mt. Brewer, Mt. Gillespie, Mt. Quinn, Mt. York (all different, 1 to 4)

### Constraints:
-   The mountain that is 210 feet tall was climbed by Leonard Lara:
    This constraint directly assigns the mountain of 210 feet to Leonard Lara:
    Leonard Lara == Height210.

-   Of Mt. Brewer and Mt. Quinn, one was climbed by Ben Beasley and the other is 470 feet tall:
    This constraint states that one of Mt. Brewer or Mt. Quinn is climbed by Ben Beasley and the other is 470 feet tall. So, we can represent this as:
    (Ben Beasley == Mt. Brewer and Mt. Brewer == Height470) or (Ben Beasley == Mt. Quinn and Mt. Quinn == Height470).

-   Mt. Brewer is either the mountain summited by Leonard Lara or the peak that is 600 feet tall:
    This constraint states that Mt. Brewer is either climbed by Leonard Lara or is 600 feet tall, but not both. So, we can represent this as:
    Xor([Mt. Brewer == Leonard Lara, Mt. Brewer == Height600]).

-   Mt. York was climbed by Kermit Kramer:
    This constraint directly assigns Mt. York to Kermit Kramer:
    Kermit Kramer == Mt. York.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of climber, mountain, and height)
# e.g. if ben == 1 and mt_brewer == 1 and height_470 == 1, then Ben Beasley climbed Mt. Brewer, which is 470 feet tall
ben, eddie, kermit, leonard = climbers = intvar(1, 4, shape=4)
height_210, height_340, height_470, height_600 = heights = intvar(1, 4, shape=4)
mt_brewer, mt_gillespie, mt_quinn, mt_york = mountains = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
climber_to_int = None  # N/A
height_to_int = {height_210: 210, height_340: 340, height_470: 470, height_600: 600}  # in feet
mountain_to_int = None  # N/A


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(climbers)
m += AllDifferent(heights)
m += AllDifferent(mountains)

# Clue 1: The mountain that is 210 feet tall was climbed by Leonard Lara
m += leonard == height_210

# Clue 2: Of Mt. Brewer and Mt. Quinn, one was climbed by Ben Beasley and the other is 470 feet tall
m += ((ben == mt_brewer) & (mt_brewer == height_470)) | ((ben == mt_quinn) & (mt_quinn == height_470))

# Clue 3: Mt. Brewer is either the mountain summited by Leonard Lara or the peak that is 600 feet tall
m += Xor([
    mt_brewer == leonard,
    mt_brewer == height_600
])

# Clue 4: Mt. York was climbed by Kermit Kramer
m += kermit == mt_york

```
[['ben', 'height_470', 'mt_quinn'], ['leonard', 'height_210', 'mt_gillespie'], ['kermit', 'height_340', 'mt_york'], ['eddie', 'height_600', 'mt_brewer']]
False
False
False
Wrong: 1, Total: 7
---------------------------------------------------------------------------------------------

Clues:
Opie Oliver's card came out in 2012.
The piece that sold for $175 came out in 1999.
Of the 2012 card and the 1987 item, one featured Mike Morales and the other sold for $275.
Neddy Norris's item sold for 50 dollars more than the 1987 card.

Entities:
prices: $125, $175, $225, $275
players: Finn Freeman, Mike Morales, Neddy Norris, Opie Oliver
years: 1974, 1987, 1999, 2012
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Finn Freeman == 1, and Year1974 == 1, and Price125 == 1, then Finn Freeman's item from 1974 was sold for $125.

### Decision variables:
-   Names of the players: Finn Freeman, Mike Morales, Neddy Norris, Opie Oliver (all different, 1 to 4)
-   Years of the items: 1974, 1987, 1999, 2012 (all different, 1 to 4)
-   Prices of the items: $125, $175, $225, $275 (all different, 1 to 4)

### Constraints:
-   Opie Oliver's card came out in 2012:
    This constraint directly assigns Opie Oliver's item to the year 2012:
    Opie Oliver == 2012.

-   The piece that sold for $175 came out in 1999:
    This constraint directly assigns the item sold for $175 to the year 1999:
    Price175 == 1999.

-   Of the 2012 card and the 1987 item, one featured Mike Morales and the other sold for $275:
    This constraint states that one of the items from 2012 and 1987 is associated with Mike Morales and the other was sold for $275. We can represent this as:
    (Year2012 == Mike Morales and Price275 == 1987) or (Year1987 == Mike Morales and Price275 == 2012).

-   Neddy Norris's item sold for 50 dollars more than the 1987 card:
    This constraint states that Neddy Norris's item was sold for $50 more than the 1987 card. We can represent this as:
    Price1987 + 50 == Neddy Norris.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Finn Freeman == 1, and Year1974 == 1, and Price125 == 1, then Finn Freeman's item from 1974 was sold for $125.

### Decision variables:
-   Names of the players: Finn Freeman, Mike Morales, Neddy Norris, Opie Oliver (all different, 1 to 4)
-   Years of the items: 1974, 1987, 1999, 2012 (all different, 1 to 4)
-   Prices of the items: $125, $175, $225, $275 (all different, 1 to 4)

### Constraints:
-   Opie Oliver's card came out in 2012:
    This constraint directly assigns Opie Oliver's item to the year 2012:
    Opie Oliver == 2012.

-   The piece that sold for $175 came out in 1999:
    This constraint directly assigns the item sold for $175 to the year 1999:
    Price175 == 1999.

-   Of the 2012 card and the 1987 item, one featured Mike Morales and the other sold for $275:
    This constraint states that one of the items from 2012 and 1987 is associated with Mike Morales and the other was sold for $275. We can represent this as:
    (Year2012 == Mike Morales and Price275 == 1987) or (Year1987 == Mike Morales and Price275 == 2012).

-   Neddy Norris's item sold for 50 dollars more than the 1987 card:
    This constraint states that Neddy Norris's item was sold for $50 more than the 1987 card. We can represent this as:
    Price1987 + 50 == Neddy Norris.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of player, year, and price)
# e.g. if finn == 1 and year1974 == 1 and price125 == 1, then Finn Freeman's item from 1974 was sold for $125
finn, mike, neddy, opie = players = intvar(1, 4, shape=4)
year1974, year1987, year1999, year2012 = years = intvar(1, 4, shape=4)
price125, price175, price225, price275 = prices = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
player_to_int = None  # N/A
year_to_int = {year1974: 1974, year1987: 1987, year1999: 1999, year2012: 2012}  # in years
price_to_int = {price125: 125, price175: 175, price225: 225, price275: 275}  # in dollars


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(players)
m += AllDifferent(years)
m += AllDifferent(prices)

# Clue 1: Opie Oliver's card came out in 2012
m += opie == year2012

# Clue 2: The piece that sold for $175 came out in 1999
m += price175 == year1999

# Clue 3: Of the 2012 card and the 1987 item, one featured Mike Morales and the other sold for $275
m += ((year2012 == mike) & (price275 == year1987)) | ((year1987 == mike) & (price275 == year2012))

# Clue 4: Neddy Norris's item sold for 50 dollars more than the 1987 card
m += price1987 + 50 == neddy

```
None
Error when trying to check solution from predicted model: invalid syntax (<string>, line 1)
False
False
Error in constraint evaluation: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
Of Nelson and the cook who scored 63 points, one made the lemon snapper and the other made the cajun chili.
Of the chef who scored 42 points and the cook who scored 63 points, one made the cashew tofu and the other was Rosalie.
Karl scored 7 more points than the person who made the lemon snapper.

Entities:
scores: 42, 49, 56, 63
chefs: Karl, Nelson, Peggy, Rosalie
dishes: cajun chili, cashew tofu, lemon snapper, smoked pork
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Karl == 1, and Score42 == 1, and CajunChili == 1, then Karl scored 42 points for making the cajun chili.

### Decision variables:
-   Scores: Score42, Score49, Score56, Score63 (all different, 1 to 4)
-   Chefs: Karl, Nelson, Peggy, Rosalie (all different, 1 to 4)
-   Dishes: CajunChili, CashewTofu, LemonSnapper, SmokedPork (all different, 1 to 4)

### Constraints:
-   Of Nelson and the cook who scored 63 points, one made the lemon snapper and the other made the cajun chili:
    This constraint implies that Nelson and the cook who scored 63 points made different dishes (lemon snapper and cajun chili). So, we can represent this as:
    (Nelson == LemonSnapper and Score63 == CajunChili) or (Nelson == CajunChili and Score63 == LemonSnapper).

-   Of the chef who scored 42 points and the cook who scored 63 points, one made the cashew tofu and the other was Rosalie:
    This constraint implies that the chef who scored 42 points and the cook who scored 63 points made different dishes (cashew tofu and Rosalie). So, we can represent this as:
    (Score42 == CashewTofu and Score63 == Rosalie) or (Score42 == Rosalie and Score63 == CashewTofu).

-   Karl scored 7 more points than the person who made the lemon snapper:
    This constraint implies that Karl scored 7 more points than the person who made the lemon snapper. So, we can represent this as:
    Karl_to_int == LemonSnapper_to_int + 7.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Karl == 1, and Score42 == 1, and CajunChili == 1, then Karl scored 42 points for making the cajun chili.

### Decision variables:
-   Scores: Score42, Score49, Score56, Score63 (all different, 1 to 4)
-   Chefs: Karl, Nelson, Peggy, Rosalie (all different, 1 to 4)
-   Dishes: CajunChili, CashewTofu, LemonSnapper, SmokedPork (all different, 1 to 4)

### Constraints:
-   Of Nelson and the cook who scored 63 points, one made the lemon snapper and the other made the cajun chili:
    This constraint implies that Nelson and the cook who scored 63 points made different dishes (lemon snapper and cajun chili). So, we can represent this as:
    (Nelson == LemonSnapper and Score63 == CajunChili) or (Nelson == CajunChili and Score63 == LemonSnapper).

-   Of the chef who scored 42 points and the cook who scored 63 points, one made the cashew tofu and the other was Rosalie:
    This constraint implies that the chef who scored 42 points and the cook who scored 63 points made different dishes (cashew tofu and Rosalie). So, we can represent this as:
    (Score42 == CashewTofu and Score63 == Rosalie) or (Score42 == Rosalie and Score63 == CashewTofu).

-   Karl scored 7 more points than the person who made the lemon snapper:
    This constraint implies that Karl scored 7 more points than the person who made the lemon snapper. So, we can represent this as:
    Karl_to_int == LemonSnapper_to_int + 7.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of score, chef, and dish)
# e.g. if score42 == 1 and karl == 1 and cajun_chili == 1, then Karl scored 42 points for making the cajun chili
score42, score49, score56, score63 = scores = intvar(1, 4, shape=4)
karl, nelson, peggy, rosalie = chefs = intvar(1, 4, shape=4)
cajun_chili, cashew_tofu, lemon_snapper, smoked_pork = dishes = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
score_to_int = {score42: 42, score49: 49, score56: 56, score63: 63}  # in points
chef_to_int = None  # N/A
dish_to_int = None  # N/A


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(scores)
m += AllDifferent(chefs)
m += AllDifferent(dishes)

# Clue 1: Of Nelson and the cook who scored 63 points, one made the lemon snapper and the other made the cajun chili
m += ((nelson == lemon_snapper) & (score63 == cajun_chili)) | ((nelson == cajun_chili) & (score63 == lemon_snapper))

# Clue 2: Of the chef who scored 42 points and the cook who scored 63 points, one made the cashew tofu and the other was Rosalie
m += ((score42 == cashew_tofu) & (score63 == rosalie)) | ((score42 == rosalie) & (score63 == cashew_tofu))

# Clue 3: Karl scored 7 more points than the person who made the lemon snapper
m += karl == lemon_snapper + 7

```
None
False
False
False
Wrong: 3, Total: 6
---------------------------------------------------------------------------------------------

Clues:
Alejandro's purchase cost less than Irma's purchase.
The insect that sold for $90 was either the atlas butterfly or the emperor butterfly.
The peacock butterfly cost more than Irma's purchase.
Of Alejandro's purchase and Irma's purchase, one was the emperor butterfly and the other sold for $45.
The four butterflies were Phillip's purchase, the insect that sold for $60, the butterfly that sold for $45 and the butterfly that sold for $90.

Entities:
prices: $45, $60, $75, $90
winners: Alejandro, Faye, Irma, Phillip
butterflies: atlas, emperor, grayling, peacock
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Alejandro == 1, and Price45 == 1, and Atlas == 1, then Alejandro bought the atlas butterfly for $45.

### Decision variables:
-   Names of the winners: Alejandro, Faye, Irma, Phillip (all different, 1 to 4)
-   Prices of the purchases: Price45, Price60, Price75, Price90 (all different, 1 to 4)
-   Types of butterflies: Atlas, Emperor, Grayling, Peacock (all different, 1 to 4)

### Constraints:
-   Alejandro's purchase cost less than Irma's purchase:
    For this, we will need to add a constraint for each possible assignment of prices to Alejandro and Irma's purchases, such that Alejandro's price is less than Irma's price. So, the constraints will be of the form:
    p1 == Alejandro and p2 == Irma => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   The insect that sold for $90 was either the atlas butterfly or the emperor butterfly:
    This is a constraint that states that the butterfly that sold for $90 is either the atlas or the emperor butterfly. So, we can represent this as:
    Or([Price90 == Atlas, Price90 == Emperor]).

-   The peacock butterfly cost more than Irma's purchase:
    For this, we will need to add a constraint for each possible assignment of prices to the peacock butterfly and Irma's purchase, such that the peacock butterfly's price is greater than Irma's price. So, the constraints will be of the form:
    p1 == Peacock and p2 == Irma => p1_to_int > p2_to_int, for all p1, p2 in prices.

-   Of Alejandro's purchase and Irma's purchase, one was the emperor butterfly and the other sold for $45:
    This is a constraint that states that one of Alejandro's and Irma's purchases was the emperor butterfly and the other sold for $45. So, we can represent this as:
    Xor([Alejandro == Emperor and Price45 == Irma, Alejandro == Price45 and Irma == Emperor]).

-   The four butterflies were Phillip's purchase, the insect that sold for $60, the butterfly that sold for $45, and the butterfly that sold for $90:
    This is a constraint that states that each butterfly corresponds to a different price. So, we can represent this as:
    AllDifferent([Phillip, Price60, Price45, Price90]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Alejandro == 1, and Price45 == 1, and Atlas == 1, then Alejandro bought the atlas butterfly for $45.

### Decision variables:
-   Names of the winners: Alejandro, Faye, Irma, Phillip (all different, 1 to 4)
-   Prices of the purchases: Price45, Price60, Price75, Price90 (all different, 1 to 4)
-   Types of butterflies: Atlas, Emperor, Grayling, Peacock (all different, 1 to 4)

### Constraints:
-   Alejandro's purchase cost less than Irma's purchase:
    For this, we will need to add a constraint for each possible assignment of prices to Alejandro and Irma's purchases, such that Alejandro's price is less than Irma's price. So, the constraints will be of the form:
    p1 == Alejandro and p2 == Irma => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   The insect that sold for $90 was either the atlas butterfly or the emperor butterfly:
    This is a constraint that states that the butterfly that sold for $90 is either the atlas or the emperor butterfly. So, we can represent this as:
    Or([Price90 == Atlas, Price90 == Emperor]).

-   The peacock butterfly cost more than Irma's purchase:
    For this, we will need to add a constraint for each possible assignment of prices to the peacock butterfly and Irma's purchase, such that the peacock butterfly's price is greater than Irma's price. So, the constraints will be of the form:
    p1 == Peacock and p2 == Irma => p1_to_int > p2_to_int, for all p1, p2 in prices.

-   Of Alejandro's purchase and Irma's purchase, one was the emperor butterfly and the other sold for $45:
    This is a constraint that states that one of Alejandro's and Irma's purchases was the emperor butterfly and the other sold for $45. So, we can represent this as:
    Xor([Alejandro == Emperor and Price45 == Irma, Alejandro == Price45 and Irma == Emperor]).

-   The four butterflies were Phillip's purchase, the insect that sold for $60, the butterfly that sold for $45, and the butterfly that sold for $90:
    This is a constraint that states that each butterfly corresponds to a different price. So, we can represent this as:
    AllDifferent([Phillip, Price60, Price45, Price90]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of winner, price, and butterfly)
# e.g. if alejandro == 1 and price45 == 1 and atlas == 1, then Alejandro bought the atlas butterfly for $45
alejandro, faye, irma, phillip = winners = intvar(1, 4, shape=4)
price45, price60, price75, price90 = prices = intvar(1, 4, shape=4)
atlas, emperor, grayling, peacock = butterflies = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
winner_to_int = None  # N/A
price_to_int = {price45: 45, price60: 60, price75: 75, price90: 90}  # in dollars
butterfly_to_int = {atlas: 1, emperor: 2, grayling: 3, peacock: 4}  # in order


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(winners)
m += AllDifferent(prices)
m += AllDifferent(butterflies)

# Clue 1: Alejandro's purchase cost less than Irma's purchase:
m += [((p1 == alejandro) & (p2 == irma)).implies(price_to_int[p1] < price_to_int[p2])
      for p1 in prices for p2 in prices]

# Clue 2: The insect that sold for $90 was either the atlas butterfly or the emperor butterfly:
m += Or([price90 == atlas, price90 == emperor])

# Clue 3: The peacock butterfly cost more than Irma's purchase:
m += [((p1 == peacock) & (p2 == irma)).implies(price_to_int[p1] > price_to_int[p2])
      for p1 in prices for p2 in prices]

# Clue 4: Of Alejandro's purchase and Irma's purchase, one was the emperor butterfly and the other sold for $45:
m += Xor([
    (alejandro == emperor) & (price45 == irma),
    (alejandro == price45) & (irma == emperor)
])

# Clue 5: The four butterflies were Phillip's purchase, the insect that sold for $60, the butterfly that sold for $45, and the butterfly that sold for $90:
m += AllDifferent([phillip, price60, price45, price90])

```
None
Error when trying to check solution from predicted model: invalid syntax (<string>, line 1)
False
False
Error in constraint evaluation: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
The athlete who traveled for 195 days started from Pescadero.
Of Dana and the athlete who traveled for 184 days, one started from Cayucos and the other started from Bodega Bay .
Hilda finished in 217 days .
Walter finished 11 days before the athlete who started from Cayucos.

Entities:
durations: 184 days, 195 days, 206 days, 217 days
rowers: Antonio, Dana, Hilda, Walter
start points: Bodega Bay, Cayucos, Pescadero, Pismo Beach
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Antonio == 1, and Day184 == 1, and PismoBeach == 1, then Antonio traveled for 184 days starting from Pismo Beach.

### Decision variables:
-   Names of the rowers: Antonio, Dana, Hilda, Walter (all different, 1 to 4)
-   Durations of travel: Day184, Day195, Day206, Day217 (all different, 1 to 4)
-   Starting points: Bodega Bay, Cayucos, Pescadero, Pismo Beach (all different, 1 to 4)

### Constraints:
-   The athlete who traveled for 195 days started from Pescadero:
    This constraint directly assigns the athlete who traveled for 195 days to start from Pescadero:
    Day195 == Pescadero.

-   Of Dana and the athlete who traveled for 184 days, one started from Cayucos and the other started from Bodega Bay:
    This constraint states that Dana and the athlete who traveled for 184 days started from different locations, Cayucos and Bodega Bay. So, we can represent this as:
    (Dana == Cayucos and Day184 == BodegaBay) or (Dana == BodegaBay and Day184 == Cayucos).

-   Hilda finished in 217 days:
    This constraint directly assigns Hilda to finish in 217 days:
    Hilda == Day217.

-   Walter finished 11 days before the athlete who started from Cayucos:
    This constraint states that Walter finished 11 days before the athlete who started from Cayucos. So, we can represent this as:
    Walter_to_int + 11 == Cayucos_to_int.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Antonio == 1, and Day184 == 1, and PismoBeach == 1, then Antonio traveled for 184 days starting from Pismo Beach.

### Decision variables:
-   Names of the rowers: Antonio, Dana, Hilda, Walter (all different, 1 to 4)
-   Durations of travel: Day184, Day195, Day206, Day217 (all different, 1 to 4)
-   Starting points: Bodega Bay, Cayucos, Pescadero, Pismo Beach (all different, 1 to 4)

### Constraints:
-   The athlete who traveled for 195 days started from Pescadero:
    This constraint directly assigns the athlete who traveled for 195 days to start from Pescadero:
    Day195 == Pescadero.

-   Of Dana and the athlete who traveled for 184 days, one started from Cayucos and the other started from Bodega Bay:
    This constraint states that Dana and the athlete who traveled for 184 days started from different locations, Cayucos and Bodega Bay. So, we can represent this as:
    (Dana == Cayucos and Day184 == BodegaBay) or (Dana == BodegaBay and Day184 == Cayucos).

-   Hilda finished in 217 days:
    This constraint directly assigns Hilda to finish in 217 days:
    Hilda == Day217.

-   Walter finished 11 days before the athlete who started from Cayucos:
    This constraint states that Walter finished 11 days before the athlete who started from Cayucos. So, we can represent this as:
    Walter_to_int + 11 == Cayucos_to_int.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of rower, duration, and starting point)
# e.g. if antonio == 1 and day184 == 1 and bodegabay == 1, then Antonio traveled for 184 days starting from Bodega Bay
antonio, dana, hilda, walter = rowers = intvar(1, 4, shape=4)
day184, day195, day206, day217 = durations = intvar(1, 4, shape=4)
bodegabay, cayucos, pescadero, pismobeach = start_points = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
rower_to_int = None  # N/A
duration_to_int = {day184: 184, day195: 195, day206: 206, day217: 217}  # in days
start_point_to_int = {bodegabay: 1, cayucos: 2, pescadero: 3, pismobeach: 4}  # in order


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(rowers)
m += AllDifferent(durations)
m += AllDifferent(start_points)

# Clue 1: The athlete who traveled for 195 days started from Pescadero:
m += day195 == pescadero

# Clue 2: Of Dana and the athlete who traveled for 184 days, one started from Cayucos and the other started from Bodega Bay:
m += ((dana == cayucos) & (day184 == bodegabay)) | ((dana == bodegabay) & (day184 == cayucos))

# Clue 3: Hilda finished in 217 days:
m += hilda == day217

# Clue 4: Walter finished 11 days before the athlete who started from Cayucos:
m += walter + 11 == cayucos

```
None
False
False
False
Wrong: 2, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The movie that grossed 5 million was directed by Kenneth Key.
Of What a World and Amerigo, one made 2 million and the other was directed by Jim Johnson.
The film directed by Kenneth Key made 3 million less than Amerigo.
Fast and Dead was directed by Kenneth Key.
Let Me Out is either the movie directed by Linda Lynch or the movie that grossed 5 million.

Entities:
earnings: 2 million, 5 million, 8 million, 11 million
movies: Amerigo, Fast and Dead, Let Me Out, What a World
directors: Jim Johnson, Kenneth Key, Linda Lynch, Micah Moreno
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Amerigo == 1, and Earnings2M == 1, and JimJohnson == 1, then Amerigo made 2 million and was directed by Jim Johnson.

### Decision variables:
-   Earnings of the movies: 2 million, 5 million, 8 million, 11 million (all different, 1 to 4)
-   Names of the movies: Amerigo, Fast and Dead, Let Me Out, What a World (all different, 1 to 4)
-   Directors: Jim Johnson, Kenneth Key, Linda Lynch, Micah Moreno (all different, 1 to 4)

### Constraints:
-   The movie that grossed 5 million was directed by Kenneth Key:
    This constraint states that the movie that grossed 5 million was directed by Kenneth Key. So, we have:
    Earnings5M == 5 and KennethKey == Earnings5M.

-   Of What a World and Amerigo, one made 2 million and the other was directed by Jim Johnson:
    This constraint states that one of What a World and Amerigo made 2 million and the other was directed by Jim Johnson. So, we have:
    (WhatAWorld == Earnings2M and JimJohnson == WhatAWorld) or (Amerigo == Earnings2M and JimJohnson == Amerigo).

-   The film directed by Kenneth Key made 3 million less than Amerigo:
    This constraint states that the film directed by Kenneth Key made 3 million less than Amerigo. So, we have:
    KennethKey == EarningsAmerigo - 3.

-   Fast and Dead was directed by Kenneth Key:
    This constraint states that Fast and Dead was directed by Kenneth Key. So, we have:
    FastAndDead == KennethKey.

-   Let Me Out is either the movie directed by Linda Lynch or the movie that grossed 5 million:
    This constraint states that Let Me Out is either directed by Linda Lynch or the movie that grossed 5 million. So, we have:
    (LetMeOut == LindaLynch) or (LetMeOut == Earnings5M).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Amerigo == 1, and Earnings2M == 1, and JimJohnson == 1, then Amerigo made 2 million and was directed by Jim Johnson.

### Decision variables:
-   Earnings of the movies: 2 million, 5 million, 8 million, 11 million (all different, 1 to 4)
-   Names of the movies: Amerigo, Fast and Dead, Let Me Out, What a World (all different, 1 to 4)
-   Directors: Jim Johnson, Kenneth Key, Linda Lynch, Micah Moreno (all different, 1 to 4)

### Constraints:
-   The movie that grossed 5 million was directed by Kenneth Key:
    This constraint states that the movie that grossed 5 million was directed by Kenneth Key. So, we have:
    Earnings5M == 5 and KennethKey == Earnings5M.

-   Of What a World and Amerigo, one made 2 million and the other was directed by Jim Johnson:
    This constraint states that one of What a World and Amerigo made 2 million and the other was directed by Jim Johnson. So, we have:
    (WhatAWorld == Earnings2M and JimJohnson == WhatAWorld) or (Amerigo == Earnings2M and JimJohnson == Amerigo).

-   The film directed by Kenneth Key made 3 million less than Amerigo:
    This constraint states that the film directed by Kenneth Key made 3 million less than Amerigo. So, we have:
    KennethKey == EarningsAmerigo - 3.

-   Fast and Dead was directed by Kenneth Key:
    This constraint states that Fast and Dead was directed by Kenneth Key. So, we have:
    FastAndDead == KennethKey.

-   Let Me Out is either the movie directed by Linda Lynch or the movie that grossed 5 million:
    This constraint states that Let Me Out is either directed by Linda Lynch or the movie that grossed 5 million. So, we have:
    (LetMeOut == LindaLynch) or (LetMeOut == Earnings5M).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of earnings, movie, and director)
# e.g. if earnings2M == 1 and amerigo == 1 and jimJohnson == 1, then Amerigo made 2 million and was directed by Jim Johnson
earnings2M, earnings5M, earnings8M, earnings11M = earnings = intvar(1, 4, shape=4)
amerigo, fastAndDead, letMeOut, whatAWorld = movies = intvar(1, 4, shape=4)
jimJohnson, kennethKey, lindaLynch, micahMoreno = directors = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
earnings_to_int = {earnings2M: 2, earnings5M: 5, earnings8M: 8, earnings11M: 11}  # in million dollars
movie_to_int = None  # N/A
director_to_int = None  # N/A


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(earnings)
m += AllDifferent(movies)
m += AllDifferent(directors)

# Clue 1: The movie that grossed 5 million was directed by Kenneth Key
m += earnings5M == 5
m += kennethKey == earnings5M

# Clue 2: Of What a World and Amerigo, one made 2 million and the other was directed by Jim Johnson
m += ((whatAWorld == earnings2M) & (jimJohnson == whatAWorld)) | ((amerigo == earnings2M) & (jimJohnson == amerigo))

# Clue 3: The film directed by Kenneth Key made 3 million less than Amerigo
m += kennethKey == amerigo - 3

# Clue 4: Fast and Dead was directed by Kenneth Key
m += fastAndDead == kennethKey

# Clue 5: Let Me Out is either the movie directed by Linda Lynch or the movie that grossed 5 million
m += (letMeOut == lindaLynch) | (letMeOut == earnings5M)

```
None
False
False
False
Wrong: 4, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The person who is 110 years old is a native of Connecticut.
Of Arlene and the Texas native, one is 110 years old and the other is 109 years old.
Herbert is 1 year younger than Doris.
The person who is 112 years old is either Herbert or the New Mexico native.

Entities:
ages: 109 years, 110 years, 111 years, 112 years
names: Arlene, Doris, Floyd, Herbert
states: Connecticut, Missouri, New Mexico, Texas
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Arlene == 1, and Age109 == 1, and Connecticut == 1, then Arlene is 109 years old and from Connecticut.

### Decision variables:
-   Names of the individuals: Arlene, Doris, Floyd, Herbert (all different, 1 to 4)
-   Ages: 109 years, 110 years, 111 years, 112 years (all different, 1 to 4)
-   States of origin: Connecticut, Missouri, New Mexico, Texas (all different, 1 to 4)

### Constraints:
-   The person who is 110 years old is a native of Connecticut:
    This constraint directly assigns the person who is 110 years old to be from Connecticut:
    Age110 == 1 and Connecticut == 1.

-   Of Arlene and the Texas native, one is 110 years old and the other is 109 years old:
    This constraint states that one of Arlene and the Texas native is 110 years old and the other is 109 years old. We can represent this as:
    (Arlene == Age110 and Texas == Age109) or (Arlene == Age109 and Texas == Age110).

-   Herbert is 1 year younger than Doris:
    This constraint states that Herbert's age is 1 less than Doris's age:
    Herbert_to_int == Doris_to_int - 1.

-   The person who is 112 years old is either Herbert or the New Mexico native:
    This constraint states that the person who is 112 years old is either Herbert or the New Mexico native:
    (Herbert == Age112) or (New Mexico == Age112).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Arlene == 1, and Age109 == 1, and Connecticut == 1, then Arlene is 109 years old and from Connecticut.

### Decision variables:
-   Names of the individuals: Arlene, Doris, Floyd, Herbert (all different, 1 to 4)
-   Ages: 109 years, 110 years, 111 years, 112 years (all different, 1 to 4)
-   States of origin: Connecticut, Missouri, New Mexico, Texas (all different, 1 to 4)

### Constraints:
-   The person who is 110 years old is a native of Connecticut:
    This constraint directly assigns the person who is 110 years old to be from Connecticut:
    Age110 == 1 and Connecticut == 1.

-   Of Arlene and the Texas native, one is 110 years old and the other is 109 years old:
    This constraint states that one of Arlene and the Texas native is 110 years old and the other is 109 years old. We can represent this as:
    (Arlene == Age110 and Texas == Age109) or (Arlene == Age109 and Texas == Age110).

-   Herbert is 1 year younger than Doris:
    This constraint states that Herbert's age is 1 less than Doris's age:
    Herbert_to_int == Doris_to_int - 1.

-   The person who is 112 years old is either Herbert or the New Mexico native:
    This constraint states that the person who is 112 years old is either Herbert or the New Mexico native:
    (Herbert == Age112) or (New Mexico == Age112).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of name, age, and state)
# e.g. if arlene == 1 and age109 == 1 and connecticut == 1, then Arlene is 109 years old and from Connecticut
arlene, doris, floyd, herbert = names = intvar(1, 4, shape=4)
age109, age110, age111, age112 = ages = intvar(1, 4, shape=4)
connecticut, missouri, new_mexico, texas = states = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
name_to_int = None  # N/A
age_to_int = {age109: 109, age110: 110, age111: 111, age112: 112}  # in years
state_to_int = None  # N/A


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(names)
m += AllDifferent(ages)
m += AllDifferent(states)

# Clue 1: The person who is 110 years old is a native of Connecticut
m += (age110 == 1) & (connecticut == 1)

# Clue 2: Of Arlene and the Texas native, one is 110 years old and the other is 109 years old
m += ((arlene == age110) & (texas == age109)) | ((arlene == age109) & (texas == age110))

# Clue 3: Herbert is 1 year younger than Doris
m += herbert == doris - 1

# Clue 4: The person who is 112 years old is either Herbert or the New Mexico native
m += (herbert == age112) | (new_mexico == age112)

```
[['arlene', 'age110', 'connecticut'], ['herbert', 'age112', 'missouri'], ['doris', 'age109', 'texas'], ['floyd', 'age111', 'new_mexico']]
False
False
False
Wrong: 4, Total: 7
---------------------------------------------------------------------------------------------

Clues:
Of Frances and Olga, one paid $25 and the other had the shiraz.
The one who had the port paid 2 dollars more than Kurt.
Olga had the merlot.

Entities:
prices: $24, $25, $26, $27
names: Frances, Hannah, Kurt, Olga
wines: merlot, port, riesling, shiraz
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Frances == 1, and Price24 == 1, and Merlot == 1, then Frances paid $24 for the merlot.

### Decision variables:
-   Names of the individuals: Frances, Hannah, Kurt, Olga (all different, 1 to 4)
-   Prices paid: Price24, Price25, Price26, Price27 (all different, 1 to 4)
-   Types of wines: Merlot, Port, Riesling, Shiraz (all different, 1 to 4)

### Constraints:
-   Of Frances and Olga, one paid $25 and the other had the shiraz:
    This constraint states that one of Frances or Olga paid $25, and the other had the shiraz. So, we need to add constraints to ensure this:
    (Frances == Price25 and Olga == Shiraz) or (Frances == Shiraz and Olga == Price25).

-   The one who had the port paid 2 dollars more than Kurt:
    For this, we will need to add a constraint for each possible assignment of prices to the port and Kurt, such that the price of the port is 2 dollars more than Kurt's price. So, the constraints will be of the form:
    p1 == Port and p2 == Kurt => p1_to_int == p2_to_int + 2, for all p1, p2 in prices.

-   Olga had the merlot:
    This is a simple constraint that states Olga had the merlot:
    Olga == Merlot.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Frances == 1, and Price24 == 1, and Merlot == 1, then Frances paid $24 for the merlot.

### Decision variables:
-   Names of the individuals: Frances, Hannah, Kurt, Olga (all different, 1 to 4)
-   Prices paid: Price24, Price25, Price26, Price27 (all different, 1 to 4)
-   Types of wines: Merlot, Port, Riesling, Shiraz (all different, 1 to 4)

### Constraints:
-   Of Frances and Olga, one paid $25 and the other had the shiraz:
    This constraint states that one of Frances or Olga paid $25, and the other had the shiraz. So, we need to add constraints to ensure this:
    (Frances == Price25 and Olga == Shiraz) or (Frances == Shiraz and Olga == Price25).

-   The one who had the port paid 2 dollars more than Kurt:
    For this, we will need to add a constraint for each possible assignment of prices to the port and Kurt, such that the price of the port is 2 dollars more than Kurt's price. So, the constraints will be of the form:
    p1 == Port and p2 == Kurt => p1_to_int == p2_to_int + 2, for all p1, p2 in prices.

-   Olga had the merlot:
    This is a simple constraint that states Olga had the merlot:
    Olga == Merlot.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of individual, price, and wine)
# e.g. if frances == 1 and price24 == 1 and merlot == 1, then Frances paid $24 for the merlot
frances, hannah, kurt, olga = individuals = intvar(1, 4, shape=4)
price24, price25, price26, price27 = prices = intvar(1, 4, shape=4)
merlot, port, riesling, shiraz = wines = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
individual_to_int = None  # N/A
price_to_int = {price24: 24, price25: 25, price26: 26, price27: 27}  # in dollars
wine_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def paid_and_had(var1, var2, price, wine):
    """
    Formulate the constraint that var1 paid the given price and var2 had the given wine.
    """
    return [
        ((i1 == var1) & (i2 == var2)).implies(
            ((p1 == price) & (w1 == wine)) | ((p1 == wine) & (w1 == price))
        )
        for i1 in individuals for i2 in individuals
        for p1 in prices for w1 in wines
    ]


def paid_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 paid diff dollars more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] + diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(individuals)
m += AllDifferent(prices)
m += AllDifferent(wines)

# Clue 1: Of Frances and Olga, one paid $25 and the other had the shiraz:
m += paid_and_had(frances, olga, price25, shiraz)

# Clue 2: The one who had the port paid 2 dollars more than Kurt:
m += paid_more_than(port, kurt, 2)

# Clue 3: Olga had the merlot:
m += olga == merlot

```
None
False
False
False
Wrong: 1, Total: 6
---------------------------------------------------------------------------------------------

Clues:
Regal Park is on Barbados.
Grand Echo costs 40 dollars more per night than the resort on Barbados.
Of El Pacifico and Regal Park, one is on Martinique and the other costs $175 per night.
The hotel that costs $215 per night is either the hotel on St. Barts or Emerald View.
Grand Echo costs 20 dollars less per night than Emerald View.

Entities:
prices: $175, $195, $215, $235
resorts: El Pacifico, Emerald View, Grand Echo, Regal Park
islands: Anguilla, Barbados, Martinique, St. Barts
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if El Pacifico == 1, and Barbados == 1, and Price175 == 1, then El Pacifico is on Barbados and costs $175 per night.

### Decision variables:
-   Prices per night: Price175, Price195, Price215, Price235 (all different, 1 to 4)
-   Resorts: El Pacifico, Emerald View, Grand Echo, Regal Park (all different, 1 to 4)
-   Islands: Anguilla, Barbados, Martinique, St. Barts (all different, 1 to 4)

### Constraints:
-   Regal Park is on Barbados:
    This constraint directly assigns the resort Regal Park to the island Barbados:
    RegalPark == Barbados.

-   Grand Echo costs 40 dollars more per night than the resort on Barbados:
    This constraint states that the price of Grand Echo is 40 dollars more than the price of the resort on Barbados. So, for all possible assignments of prices and resorts, the constraints will be of the form:
    p1 == GrandEcho and p2 == Barbados => p1_to_int == p2_to_int + 40, for all p1, p2 in prices.

-   Of El Pacifico and Regal Park, one is on Martinique and the other costs $175 per night:
    This constraint states that one of El Pacifico and Regal Park is on Martinique and the other costs $175 per night. So, for all possible assignments of resorts and prices, the constraints will be of the form:
    (ElPacifico == Martinique and RegalPark == Price175) or (RegalPark == Martinique and ElPacifico == Price175).

-   The hotel that costs $215 per night is either the hotel on St. Barts or Emerald View:
    This constraint states that the hotel that costs $215 per night is either on St. Barts or is Emerald View. So, for all possible assignments of prices and islands, the constraints will be of the form:
    (Price215 == StBarts or Price215 == EmeraldView).

-   Grand Echo costs 20 dollars less per night than Emerald View:
    This constraint states that the price of Grand Echo is 20 dollars less than the price of Emerald View. So, for all possible assignments of prices, the constraints will be of the form:
    p1 == GrandEcho and p2 == EmeraldView => p1_to_int == p2_to_int - 20, for all p1, p2 in prices.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if El Pacifico == 1, and Barbados == 1, and Price175 == 1, then El Pacifico is on Barbados and costs $175 per night.

### Decision variables:
-   Prices per night: Price175, Price195, Price215, Price235 (all different, 1 to 4)
-   Resorts: El Pacifico, Emerald View, Grand Echo, Regal Park (all different, 1 to 4)
-   Islands: Anguilla, Barbados, Martinique, St. Barts (all different, 1 to 4)

### Constraints:
-   Regal Park is on Barbados:
    This constraint directly assigns the resort Regal Park to the island Barbados:
    RegalPark == Barbados.

-   Grand Echo costs 40 dollars more per night than the resort on Barbados:
    This constraint states that the price of Grand Echo is 40 dollars more than the price of the resort on Barbados. So, for all possible assignments of prices and resorts, the constraints will be of the form:
    p1 == GrandEcho and p2 == Barbados => p1_to_int == p2_to_int + 40, for all p1, p2 in prices.

-   Of El Pacifico and Regal Park, one is on Martinique and the other costs $175 per night:
    This constraint states that one of El Pacifico and Regal Park is on Martinique and the other costs $175 per night. So, for all possible assignments of resorts and prices, the constraints will be of the form:
    (ElPacifico == Martinique and RegalPark == Price175) or (RegalPark == Martinique and ElPacifico == Price175).

-   The hotel that costs $215 per night is either the hotel on St. Barts or Emerald View:
    This constraint states that the hotel that costs $215 per night is either on St. Barts or is Emerald View. So, for all possible assignments of prices and islands, the constraints will be of the form:
    (Price215 == StBarts or Price215 == EmeraldView).

-   Grand Echo costs 20 dollars less per night than Emerald View:
    This constraint states that the price of Grand Echo is 20 dollars less than the price of Emerald View. So, for all possible assignments of prices, the constraints will be of the form:
    p1 == GrandEcho and p2 == EmeraldView => p1_to_int == p2_to_int - 20, for all p1, p2 in prices.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of price, resort, and island)
# e.g. if price175 == 1 and el_pacifico == 1 and martinique == 1, then El Pacifico is on Martinique and costs $175 per night
price175, price195, price215, price235 = prices = intvar(1, 4, shape=4)
el_pacifico, emerald_view, grand_echo, regal_park = resorts = intvar(1, 4, shape=4)
anguilla, barbados, martinique, st_barts = islands = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
price_to_int = {price175: 175, price195: 195, price215: 215, price235: 235}  # in dollars
resort_to_int = None  # N/A
island_to_int = {anguilla: 1, barbados: 2, martinique: 3, st_barts: 4}  # in islands


# Helper functions (for formulating comparison constraints)
def cost_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 costs diff dollars more per night than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] + diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(prices)
m += AllDifferent(resorts)
m += AllDifferent(islands)

# Clue 1: Regal Park is on Barbados
m += regal_park == barbados

# Clue 2: Grand Echo costs 40 dollars more per night than the resort on Barbados
m += cost_more_than(grand_echo, barbados, 40)

# Clue 3: Of El Pacifico and Regal Park, one is on Martinique and the other costs $175 per night
m += ((el_pacifico == martinique) & (regal_park == price175)) | ((regal_park == martinique) & (el_pacifico == price175))

# Clue 4: The hotel that costs $215 per night is either the hotel on St. Barts or Emerald View
m += (price215 == st_barts) | (price215 == emerald_view)

# Clue 5: Grand Echo costs 20 dollars less per night than Emerald View
m += cost_more_than(emerald_view, grand_echo, 20)

```
[['price215', 'grand_echo', 'st_barts'], ['price235', 'emerald_view', 'anguilla'], ['price195', 'el_pacifico', 'martinique'], ['price175', 'regal_park', 'barbados']]
True
True
True
Wrong: 2, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Snappy is 18 years younger than the swoopbacked tortoise.
The 68 year old animal is the horned tortoise.
Chewie is 32 years old.
Of Snappy and Toredo, one is 14 years old and the other is the horned tortoise.
The pitch belly tortoise is younger than Chewie.

Entities:
ages: 14, 32, 50, 68
tortoises: Chewie, Snappy, Speedy, Toredo
species: black neck, horned, pitch belly, swoopbacked
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Chewie == 1, and Age32 == 1, and Horned == 1, then Chewie is the 32-year-old horned tortoise.

### Decision variables:
-   Ages of the tortoises: Age14, Age32, Age50, Age68 (all different, 1 to 4)
-   Names of the tortoises: Chewie, Snappy, Speedy, Toredo (all different, 1 to 4)
-   Species of the tortoises: BlackNeck, Horned, PitchBelly, Swoopbacked (all different, 1 to 4)

### Constraints:
-   Snappy is 18 years younger than the swoopbacked tortoise:
    For this, we will need to add a constraint for each possible assignment of ages to Snappy and the swoopbacked tortoise, such that Snappy's age is 18 less than the swoopbacked tortoise's age. So, the constraints will be of the form:
    a1 == Snappy and a2 == Swoopbacked => a1_to_int == a2_to_int - 18, for all a1, a2 in ages.

-   The 68-year-old animal is the horned tortoise:
    This is a constraint that states that the horned tortoise is 68 years old. So:
    Horned == Age68.

-   Chewie is 32 years old:
    This is a constraint that states Chewie's age is 32 years. So:
    Chewie == Age32.

-   Of Snappy and Toredo, one is 14 years old and the other is the horned tortoise:
    This is a constraint that states that one of Snappy and Toredo is 14 years old and the other is the horned tortoise. So, we will need to add constraints to represent this:
    (Age14 == Snappy and Horned == Toredo) or (Age14 == Toredo and Horned == Snappy).

-   The pitch belly tortoise is younger than Chewie:
    For this, we will need to add a constraint for each possible assignment of ages to the pitch belly tortoise and Chewie, such that the pitch belly tortoise's age is less than Chewie's age. So, the constraints will be of the form:
    a1 == PitchBelly and a2 == Chewie => a1_to_int < a2_to_int, for all a1, a2 in ages.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Chewie == 1, and Age32 == 1, and Horned == 1, then Chewie is the 32-year-old horned tortoise.

### Decision variables:
-   Ages of the tortoises: Age14, Age32, Age50, Age68 (all different, 1 to 4)
-   Names of the tortoises: Chewie, Snappy, Speedy, Toredo (all different, 1 to 4)
-   Species of the tortoises: BlackNeck, Horned, PitchBelly, Swoopbacked (all different, 1 to 4)

### Constraints:
-   Snappy is 18 years younger than the swoopbacked tortoise:
    For this, we will need to add a constraint for each possible assignment of ages to Snappy and the swoopbacked tortoise, such that Snappy's age is 18 less than the swoopbacked tortoise's age. So, the constraints will be of the form:
    a1 == Snappy and a2 == Swoopbacked => a1_to_int == a2_to_int - 18, for all a1, a2 in ages.

-   The 68-year-old animal is the horned tortoise:
    This is a constraint that states that the horned tortoise is 68 years old. So:
    Horned == Age68.

-   Chewie is 32 years old:
    This is a constraint that states Chewie's age is 32 years. So:
    Chewie == Age32.

-   Of Snappy and Toredo, one is 14 years old and the other is the horned tortoise:
    This is a constraint that states that one of Snappy and Toredo is 14 years old and the other is the horned tortoise. So, we will need to add constraints to represent this:
    (Age14 == Snappy and Horned == Toredo) or (Age14 == Toredo and Horned == Snappy).

-   The pitch belly tortoise is younger than Chewie:
    For this, we will need to add a constraint for each possible assignment of ages to the pitch belly tortoise and Chewie, such that the pitch belly tortoise's age is less than Chewie's age. So, the constraints will be of the form:
    a1 == PitchBelly and a2 == Chewie => a1_to_int < a2_to_int, for all a1, a2 in ages.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of age, tortoise, and species)
# e.g. if age14 == 1 and chewie == 1 and blackneck == 1, then Chewie is the black neck tortoise and is 14 years old
age14, age32, age50, age68 = ages = intvar(1, 4, shape=4)
chewie, snappy, speedy, toredo = tortoises = intvar(1, 4, shape=4)
blackneck, horned, pitchbelly, swoopbacked = species = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
age_to_int = {age14: 14, age32: 32, age50: 50, age68: 68}  # in years
tortoise_to_int = None  # N/A
species_to_int = {blackneck: 1, horned: 2, pitchbelly: 3, swoopbacked: 4}  # in order


# Helper functions (for formulating comparison constraints)
def age_difference(var1, var2, diff):
    """
    Formulate the constraint that var1's age is diff years less than var2's age.
    """
    return [((a1 == var1) & (a2 == var2)).implies(age_to_int[a1] == age_to_int[a2] - diff)
            for a1 in ages for a2 in ages]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(ages)
m += AllDifferent(tortoises)
m += AllDifferent(species)

# Clue 1: Snappy is 18 years younger than the swoopbacked tortoise:
m += age_difference(snappy, swoopbacked, 18)

# Clue 2: The 68-year-old animal is the horned tortoise:
m += horned == age68

# Clue 3: Chewie is 32 years old:
m += chewie == age32

# Clue 4: Of Snappy and Toredo, one is 14 years old and the other is the horned tortoise:
m += ((age14 == snappy) & (horned == toredo)) | ((age14 == toredo) & (horned == snappy))

# Clue 5: The pitch belly tortoise is younger than Chewie:
m += [((a1 == pitchbelly) & (a2 == chewie)).implies(age_to_int[a1] < age_to_int[a2])
      for a1 in ages for a2 in ages]

```
[['age14', 'snappy', 'pitchbelly'], ['age32', 'chewie', 'swoopbacked'], ['age68', 'toredo', 'horned'], ['age50', 'speedy', 'blackneck']]
True
True
True
Wrong: 1, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Of the parrot and the lorikeet, one was bought in April and the other is Roberta's.
Natalie's pet was bought sometime before Roberta's pet.
Laura's pet is the lovebird.
The bird bought in February is either the lorikeet or the lovebird.
Of the bird bought in February and the macaw, one is Natalie's and the other is Roberta's.

Entities:
months: January, February, March, April
names: Celia, Laura, Natalie, Roberta
birds: lorikeet, lovebird, macaw, parrot
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Celia == 1, and January == 1, and Lorikeet == 1, then Celia bought a lorikeet in January.

### Decision variables:
-   Names of the people: Celia, Laura, Natalie, Roberta (all different, 1 to 4)
-   Months of purchase: January, February, March, April (all different, 1 to 4)
-   Types of birds: Lorikeet, Lovebird, Macaw, Parrot (all different, 1 to 4)

### Constraints:
-   Of the parrot and the lorikeet, one was bought in April and the other is Roberta's:
    This constraint states that one of the parrot or the lorikeet was bought in April, and the other bird is Roberta's. So, we need to add constraints to represent this:
    (bird1 == Parrot and bird2 == Lorikeet) or (bird1 == Lorikeet and bird2 == Parrot)
    (month1 == April and owner2 == Roberta) or (month2 == April and owner1 == Roberta)

-   Natalie's pet was bought sometime before Roberta's pet:
    This constraint states that Natalie's pet was bought before Roberta's pet. So, we need to add constraints to represent this:
    owner1 == Natalie and owner2 == Roberta => month1_to_int < month2_to_int

-   Laura's pet is the lovebird:
    This constraint states that Laura's pet is the lovebird. So, we need to add a constraint to represent this:
    bird == Lovebird and owner == Laura

-   The bird bought in February is either the lorikeet or the lovebird:
    This constraint states that the bird bought in February is either the lorikeet or the lovebird. So, we need to add a constraint to represent this:
    (bird == Lorikeet or bird == Lovebird) and month == February

-   Of the bird bought in February and the macaw, one is Natalie's and the other is Roberta's:
    This constraint states that one of the bird bought in February and the macaw is Natalie's and the other is Roberta's. So, we need to add constraints to represent this:
    (bird1 == Macaw and bird2 == February) or (bird1 == February and bird2 == Macaw)
    (owner1 == Natalie and owner2 == Roberta) or (owner1 == Roberta and owner2 == Natalie)
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Celia == 1, and January == 1, and Lorikeet == 1, then Celia bought a lorikeet in January.

### Decision variables:
-   Names of the people: Celia, Laura, Natalie, Roberta (all different, 1 to 4)
-   Months of purchase: January, February, March, April (all different, 1 to 4)
-   Types of birds: Lorikeet, Lovebird, Macaw, Parrot (all different, 1 to 4)

### Constraints:
-   Of the parrot and the lorikeet, one was bought in April and the other is Roberta's:
    This constraint states that one of the parrot or the lorikeet was bought in April, and the other bird is Roberta's. So, we need to add constraints to represent this:
    (bird1 == Parrot and bird2 == Lorikeet) or (bird1 == Lorikeet and bird2 == Parrot)
    (month1 == April and owner2 == Roberta) or (month2 == April and owner1 == Roberta)

-   Natalie's pet was bought sometime before Roberta's pet:
    This constraint states that Natalie's pet was bought before Roberta's pet. So, we need to add constraints to represent this:
    owner1 == Natalie and owner2 == Roberta => month1_to_int < month2_to_int

-   Laura's pet is the lovebird:
    This constraint states that Laura's pet is the lovebird. So, we need to add a constraint to represent this:
    bird == Lovebird and owner == Laura

-   The bird bought in February is either the lorikeet or the lovebird:
    This constraint states that the bird bought in February is either the lorikeet or the lovebird. So, we need to add a constraint to represent this:
    (bird == Lorikeet or bird == Lovebird) and month == February

-   Of the bird bought in February and the macaw, one is Natalie's and the other is Roberta's:
    This constraint states that one of the bird bought in February and the macaw is Natalie's and the other is Roberta's. So, we need to add constraints to represent this:
    (bird1 == Macaw and bird2 == February) or (bird1 == February and bird2 == Macaw)
    (owner1 == Natalie and owner2 == Roberta) or (owner1 == Roberta and owner2 == Natalie)
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of person, month, and bird)
# e.g. if celia == 1 and january == 1 and lorikeet == 1, then Celia bought a lorikeet in January
celia, laura, natalie, roberta = names = intvar(1, 4, shape=4)
january, february, march, april = months = intvar(1, 4, shape=4)
lorikeet, lovebird, macaw, parrot = birds = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
name_to_int = None  # N/A
month_to_int = {january: 1, february: 2, march: 3, april: 4}  # in months
bird_to_int = {lorikeet: 1, lovebird: 2, macaw: 3, parrot: 4}  # in birds


# Helper functions (for formulating constraints)
def one_bought_in_month_and_robertas(bird1, bird2, month1, month2, owner1, owner2):
    """
    Formulate the constraint that one bird was bought in a specific month and the other is Roberta's.
    """
    return [
        ((bird1 == parrot) & (bird2 == lorikeet)) | ((bird1 == lorikeet) & (bird2 == parrot)),
        ((month1 == april) & (owner2 == roberta)) | ((month2 == april) & (owner1 == roberta))
    ]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(names)
m += AllDifferent(months)
m += AllDifferent(birds)

# Clue 1: Of the parrot and the lorikeet, one was bought in April and the other is Roberta's
m += one_bought_in_month_and_robertas(parrot, lorikeet, april, roberta, parrot, lorikeet)

# Clue 2: Natalie's pet was bought sometime before Roberta's pet
m += (natalie == names) & (roberta == names) & (january == months) & (february == months) & (natalie < roberta)

# Clue 3: Laura's pet is the lovebird
m += (laura == names) & (lovebird == birds)

# Clue 4: The bird bought in February is either the lorikeet or the lovebird
m += (february == months) & ((lorikeet == birds) | (lovebird == birds))

# Clue 5: Of the bird bought in February and the macaw, one is Natalie's and the other is Roberta's
m += ((february == birds) & (macaw == birds)) | ((natalie == names) & (roberta == names))

```
None
Error when trying to check solution from predicted model: invalid syntax (<string>, line 1)
False
False
Error in constraint evaluation: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
Suzanne paid less than Margie.
Margie paid $7.
The competitor who ordered spaghetti paid 2 dollars more than the competitor who ordered taglioni.
Of the runner who paid $9 and the contestant who ordered fettuccine, one was Margie and the other was Velma.

Entities:
prices: $6, $7, $8, $9
runners: Florence, Margie, Suzanne, Velma
pastas: fettuccine, fusilli, spaghetti, taglioni
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Florence == 1, and Price6 == 1, and Fettuccine == 1, then Florence paid $6 for fettuccine.

### Decision variables:
-   Names of the runners: Florence, Margie, Suzanne, Velma (all different, 1 to 4)
-   Prices paid: Price6, Price7, Price8, Price9 (all different, 1 to 4)
-   Pasta ordered: Fettuccine, Fusilli, Spaghetti, Taglioni (all different, 1 to 4)

### Constraints:
-   Suzanne paid less than Margie:
    For this, we will need to add a constraint for each possible assignment of prices to Suzanne and Margie, such that Suzanne's price is less than Margie's price. So, the constraints will be of the form:
    p1 == Suzanne and p2 == Margie => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   Margie paid $7:
    This is a simple constraint that states Margie paid $7:
    Margie == Price7.

-   The competitor who ordered spaghetti paid 2 dollars more than the competitor who ordered taglioni:
    For this, we will need to add a constraint for each possible assignment of pastas to spaghetti and taglioni, such that the price paid for spaghetti is 2 dollars more than the price paid for taglioni. So, the constraints will be of the form:
    p1 == Spaghetti and p2 == Taglioni => p1_to_int == p2_to_int + 2, for all p1, p2 in prices.

-   Of the runner who paid $9 and the contestant who ordered fettuccine, one was Margie and the other was Velma:
    This is a constraint that states that one of Margie or Velma paid $9 and the other ordered fettuccine. So, the constraints will be of the form:
    (Margie == Price9 and Velma == Fettuccine) or (Margie == Fettuccine and Velma == Price9).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Florence == 1, and Price6 == 1, and Fettuccine == 1, then Florence paid $6 for fettuccine.

### Decision variables:
-   Names of the runners: Florence, Margie, Suzanne, Velma (all different, 1 to 4)
-   Prices paid: Price6, Price7, Price8, Price9 (all different, 1 to 4)
-   Pasta ordered: Fettuccine, Fusilli, Spaghetti, Taglioni (all different, 1 to 4)

### Constraints:
-   Suzanne paid less than Margie:
    For this, we will need to add a constraint for each possible assignment of prices to Suzanne and Margie, such that Suzanne's price is less than Margie's price. So, the constraints will be of the form:
    p1 == Suzanne and p2 == Margie => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   Margie paid $7:
    This is a simple constraint that states Margie paid $7:
    Margie == Price7.

-   The competitor who ordered spaghetti paid 2 dollars more than the competitor who ordered taglioni:
    For this, we will need to add a constraint for each possible assignment of pastas to spaghetti and taglioni, such that the price paid for spaghetti is 2 dollars more than the price paid for taglioni. So, the constraints will be of the form:
    p1 == Spaghetti and p2 == Taglioni => p1_to_int == p2_to_int + 2, for all p1, p2 in prices.

-   Of the runner who paid $9 and the contestant who ordered fettuccine, one was Margie and the other was Velma:
    This is a constraint that states that one of Margie or Velma paid $9 and the other ordered fettuccine. So, the constraints will be of the form:
    (Margie == Price9 and Velma == Fettuccine) or (Margie == Fettuccine and Velma == Price9).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of runner, price, and pasta)
# e.g. if florence == 1 and price6 == 1 and fettuccine == 1, then Florence paid $6 for fettuccine
florence, margie, suzanne, velma = runners = intvar(1, 4, shape=4)
price6, price7, price8, price9 = prices = intvar(1, 4, shape=4)
fettuccine, fusilli, spaghetti, taglioni = pastas = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
runner_to_int = None  # N/A
price_to_int = {price6: 6, price7: 7, price8: 8, price9: 9}  # in dollars
pasta_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def paid_less_than(var1, var2):
    """
    Formulate the constraint that var1 paid less than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] < price_to_int[p2])
            for p1 in prices for p2 in prices]


def paid_more_by_than(var1, var2, diff):
    """
    Formulate the constraint that var1 paid more by diff dollars than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] + diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(runners)
m += AllDifferent(prices)
m += AllDifferent(pastas)

# Clue 1: Suzanne paid less than Margie:
m += paid_less_than(suzanne, margie)

# Clue 2: Margie paid $7:
m += margie == price7

# Clue 3: The competitor who ordered spaghetti paid 2 dollars more than the competitor who ordered taglioni:
m += paid_more_by_than(spaghetti, taglioni, 2)

# Clue 4: Of the runner who paid $9 and the contestant who ordered fettuccine, one was Margie and the other was Velma:
m += ((margie == price9) & (velma == fettuccine)) | ((margie == fettuccine) & (velma == price9))

```
[['suzanne', 'price6', 'taglioni'], ['florence', 'price8', 'spaghetti'], ['velma', 'price9', 'fusilli'], ['margie', 'price7', 'fettuccine']]
True
True
True
Wrong: 1, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The Luzagueil is a chardonnay.
The Annata Branco is either the 1992 wine or the syrah.
The Friambliss is a syrah.
Of the pinot gris and the 1984 bottle, one is the Luzagueil and the other is the Zifennwein.
The pinot gris was bottled 4 years after the merlot.

Entities:
vintages: 1984, 1988, 1992, 1996
wines: Annata Branco, Friambliss, Luzagueil, Zifennwein
types: chardonnay, merlot, pinot gris, syrah
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if 1984 == 1, and AnnataBranco == 1, and Chardonnay == 1, then the 1984 vintage is the Annata Branco chardonnay.

### Decision variables:
-   Vintages: 1984, 1988, 1992, 1996 (all different, 1 to 4)
-   Wines: Annata Branco, Friambliss, Luzagueil, Zifennwein (all different, 1 to 4)
-   Types of wine: Chardonnay, Merlot, Pinot Gris, Syrah (all different, 1 to 4)

### Constraints:
-   The Luzagueil is a chardonnay:
    This constraint directly assigns the Luzagueil wine to the Chardonnay type:
    Luzagueil == Chardonnay.

-   The Annata Branco is either the 1992 wine or the syrah:
    This constraint states that the Annata Branco wine is either the 1992 vintage or the Syrah type:
    AnnataBranco == 1992 OR AnnataBranco == Syrah.

-   The Friambliss is a syrah:
    This constraint directly assigns the Friambliss wine to the Syrah type:
    Friambliss == Syrah.

-   Of the pinot gris and the 1984 bottle, one is the Luzagueil and the other is the Zifennwein:
    This constraint states that one of the Pinot Gris and the 1984 bottle is the Luzagueil and the other is the Zifennwein. This can be represented as:
    (PinotGris == Luzagueil AND 1984 == Zifennwein) OR (PinotGris == Zifennwein AND 1984 == Luzagueil).

-   The pinot gris was bottled 4 years after the merlot:
    This constraint states that the Pinot Gris vintage is 4 years after the Merlot vintage. We can represent this as:
    PinotGris_to_int == Merlot_to_int + 4.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if 1984 == 1, and AnnataBranco == 1, and Chardonnay == 1, then the 1984 vintage is the Annata Branco chardonnay.

### Decision variables:
-   Vintages: 1984, 1988, 1992, 1996 (all different, 1 to 4)
-   Wines: Annata Branco, Friambliss, Luzagueil, Zifennwein (all different, 1 to 4)
-   Types of wine: Chardonnay, Merlot, Pinot Gris, Syrah (all different, 1 to 4)

### Constraints:
-   The Luzagueil is a chardonnay:
    This constraint directly assigns the Luzagueil wine to the Chardonnay type:
    Luzagueil == Chardonnay.

-   The Annata Branco is either the 1992 wine or the syrah:
    This constraint states that the Annata Branco wine is either the 1992 vintage or the Syrah type:
    AnnataBranco == 1992 OR AnnataBranco == Syrah.

-   The Friambliss is a syrah:
    This constraint directly assigns the Friambliss wine to the Syrah type:
    Friambliss == Syrah.

-   Of the pinot gris and the 1984 bottle, one is the Luzagueil and the other is the Zifennwein:
    This constraint states that one of the Pinot Gris and the 1984 bottle is the Luzagueil and the other is the Zifennwein. This can be represented as:
    (PinotGris == Luzagueil AND 1984 == Zifennwein) OR (PinotGris == Zifennwein AND 1984 == Luzagueil).

-   The pinot gris was bottled 4 years after the merlot:
    This constraint states that the Pinot Gris vintage is 4 years after the Merlot vintage. We can represent this as:
    PinotGris_to_int == Merlot_to_int + 4.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of vintage, wine, and type)
# e.g. if vintage1984 == 1 and annata_branco == 1 and chardonnay == 1, then the 1984 vintage is the Annata Branco chardonnay
vintage1984, vintage1988, vintage1992, vintage1996 = vintages = intvar(1, 4, shape=4)
annata_branco, friambliss, luzagueil, zifennwein = wines = intvar(1, 4, shape=4)
chardonnay, merlot, pinot_gris, syrah = types = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
vintage_to_int = {vintage1984: 1984, vintage1988: 1988, vintage1992: 1992, vintage1996: 1996}  # in years
wine_to_int = None  # N/A
type_to_int = {chardonnay: 1, merlot: 2, pinot_gris: 3, syrah: 4}  # in numbers


# Constraints
m = Model()

# Clue 1: The Luzagueil is a chardonnay
m += luzagueil == chardonnay

# Clue 2: The Annata Branco is either the 1992 wine or the syrah
m += (annata_branco == vintage1992) | (annata_branco == syrah)

# Clue 3: The Friambliss is a syrah
m += friambliss == syrah

# Clue 4: Of the pinot gris and the 1984 bottle, one is the Luzagueil and the other is the Zifennwein
m += ((pinot_gris == luzagueil) & (vintage1984 == zifennwein)) | ((pinot_gris == zifennwein) & (vintage1984 == luzagueil))

# Clue 5: The pinot gris was bottled 4 years after the merlot
m += pinot_gris == merlot + 4

```
None
False
False
False
Wrong: 6, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Hannah paid more than Teri's client.
Freda paid 20 dollars more than Lynda's client.
Hannah paid 10 dollars less than Nancy's client.
Nancy's client, Hannah and Ginger were all different clients.
Hannah was either the person who paid $180 or Lynda's client.

Entities:
Clients: Aimee, Ginger, Freda, Hannah
Prices: $150, $160, $170, $180
Masseuses: Lynda, Nancy, Teri, Whitney
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Aimee == 1, and Price150 == 1, and Lynda == 1, then Aimee paid $150 to Lynda.

### Decision variables:
-   Names of the clients: Aimee, Ginger, Freda, Hannah (all different, 1 to 4)
-   Prices paid by the clients: Price150, Price160, Price170, Price180 (all different, 1 to 4)
-   Names of the masseuses: Lynda, Nancy, Teri, Whitney (all different, 1 to 4)

### Constraints:
-   Hannah paid more than Teri's client:
    For this, we will need to add a constraint for each possible assignment of prices to Hannah and Teri's client, such that Hannah's price is greater than Teri's client's price. So, the constraints will be of the form:
    p1 == Hannah and p2 == Teri => p1_to_int > p2_to_int, for all p1, p2 in prices.

-   Freda paid 20 dollars more than Lynda's client:
    For this, we will need to add a constraint for each possible assignment of prices to Freda and Lynda's client, such that Freda's price is 20 dollars greater than Lynda's client's price. So, the constraints will be of the form:
    p1 == Freda and p2 == Lynda => p1_to_int == p2_to_int + 20, for all p1, p2 in prices.

-   Hannah paid 10 dollars less than Nancy's client:
    For this, we will need to add a constraint for each possible assignment of prices to Hannah and Nancy's client, such that Hannah's price is 10 dollars less than Nancy's client's price. So, the constraints will be of the form:
    p1 == Hannah and p2 == Nancy => p1_to_int == p2_to_int - 10, for all p1, p2 in prices.

-   Nancy's client, Hannah and Ginger were all different clients:
    This is a constraint that states that all these entities are different, thus:
    AllDifferent([Nancy, Hannah, Ginger]).

-   Hannah was either the person who paid $180 or Lynda's client:
    This is a constraint that states that Hannah is either the person who paid $180 or Lynda's client, but not both. Thus:
    Xor([Hannah == Price180, Hannah == Lynda]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Aimee == 1, and Price150 == 1, and Lynda == 1, then Aimee paid $150 to Lynda.

### Decision variables:
-   Names of the clients: Aimee, Ginger, Freda, Hannah (all different, 1 to 4)
-   Prices paid by the clients: Price150, Price160, Price170, Price180 (all different, 1 to 4)
-   Names of the masseuses: Lynda, Nancy, Teri, Whitney (all different, 1 to 4)

### Constraints:
-   Hannah paid more than Teri's client:
    For this, we will need to add a constraint for each possible assignment of prices to Hannah and Teri's client, such that Hannah's price is greater than Teri's client's price. So, the constraints will be of the form:
    p1 == Hannah and p2 == Teri => p1_to_int > p2_to_int, for all p1, p2 in prices.

-   Freda paid 20 dollars more than Lynda's client:
    For this, we will need to add a constraint for each possible assignment of prices to Freda and Lynda's client, such that Freda's price is 20 dollars greater than Lynda's client's price. So, the constraints will be of the form:
    p1 == Freda and p2 == Lynda => p1_to_int == p2_to_int + 20, for all p1, p2 in prices.

-   Hannah paid 10 dollars less than Nancy's client:
    For this, we will need to add a constraint for each possible assignment of prices to Hannah and Nancy's client, such that Hannah's price is 10 dollars less than Nancy's client's price. So, the constraints will be of the form:
    p1 == Hannah and p2 == Nancy => p1_to_int == p2_to_int - 10, for all p1, p2 in prices.

-   Nancy's client, Hannah and Ginger were all different clients:
    This is a constraint that states that all these entities are different, thus:
    AllDifferent([Nancy, Hannah, Ginger]).

-   Hannah was either the person who paid $180 or Lynda's client:
    This is a constraint that states that Hannah is either the person who paid $180 or Lynda's client, but not both. Thus:
    Xor([Hannah == Price180, Hannah == Lynda]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of client, masseuse, and price)
# e.g. if aimee == 1 and lynda == 1 and price150 == 1, then Aimee paid $150 to Lynda.

aimee, ginger, freda, hannah = clients = intvar(1, 4, shape=4)
lynda, nancy, teri, whitney = masseuses = intvar(1, 4, shape=4)
price150, price160, price170, price180 = prices = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
client_to_int = None  # N/A
masseuse_to_int = None  # N/A
price_to_int = {price150: 150, price160: 160, price170: 170, price180: 180}  # in dollars

# Helper functions (for formulating comparison constraints)
def paid_more_than(var1, var2):
    """
    Formulate the constraint that var1 paid more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] > price_to_int[p2])
            for p1 in prices for p2 in prices]

def paid_exactly_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 paid exactly $diff more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] + diff)
            for p1 in prices for p2 in prices]

# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(clients)
m += AllDifferent(masseuses)
m += AllDifferent(prices)

# Clue 1: Hannah paid more than Teri's client
m += paid_more_than(hannah, teri)

# Clue 2: Freda paid 20 dollars more than Lynda's client
m += paid_exactly_more_than(freda, lynda, 20)

# Clue 3: Hannah paid 10 dollars less than Nancy's client
m += paid_exactly_more_than(hannah, nancy, -10)

# Clue 4: Nancy's client, Hannah and Ginger were all different clients
m += AllDifferent([nancy, hannah, ginger])

# Clue 5: Hannah was either the person who paid $180 or Lynda's client
m += Xor([
    hannah == price180,
    hannah == lynda
])
```
[['freda', 'whitney', 'price180'], ['hannah', 'lynda', 'price160'], ['ginger', 'teri', 'price150'], ['aimee', 'nancy', 'price170']]
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The 115 ft tall waterfall is either the waterfall in Nigeria or the waterfall located in Tibet.
Inawatai is 100 ft tall.
Nyalt is 10 ft taller than Rhoqua.
The waterfall in Brazil is somewhat shorter than Rhoqua.
The waterfall in Brazil is 10 ft shorter than the waterfall located in Nigeria.

Entities:
waterfalls: Sihat, Rhoqua, Nyalt, Inawatai
heights: 100 ft, 105 ft, 110 ft, 115 ft
countries: Brazil, Nigeria, Tibet, Switzerland
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Sihat == 1, and Height100 == 1, and Brazil == 1, then Sihat is the 100 ft tall waterfall located in Brazil.

### Decision variables:
-   Names of the waterfalls: Sihat, Rhoqua, Nyalt, Inawatai (all different, 1 to 4)
-   Heights of the waterfalls: Height100, Height105, Height110, Height115 (all different, 1 to 4)
-   Countries where the waterfalls are located: Brazil, Nigeria, Tibet, Switzerland (all different, 1 to 4)

### Constraints:
-   The 115 ft tall waterfall is either the waterfall in Nigeria or the waterfall located in Tibet:
    This constraint states that the 115 ft tall waterfall is either in Nigeria or Tibet, but not both. So:
    Xor([Height115 == Nigeria, Height115 == Tibet]).

-   Inawatai is 100 ft tall:
    This constraint directly assigns the height of Inawatai to be 100 ft:
    Inawatai == Height100.

-   Nyalt is 10 ft taller than Rhoqua:
    This constraint states that Nyalt's height is 10 ft greater than Rhoqua's height. So:
    Nyalt_to_int == Rhoqua_to_int + 10.

-   The waterfall in Brazil is somewhat shorter than Rhoqua:
    This constraint implies that the waterfall in Brazil is shorter than Rhoqua, but not necessarily by a specific amount. So:
    Brazil_to_int < Rhoqua_to_int.

-   The waterfall in Brazil is 10 ft shorter than the waterfall located in Nigeria:
    This constraint specifies the height difference between the waterfalls in Brazil and Nigeria. So:
    Brazil_to_int == Nigeria_to_int + 10.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Sihat == 1, and Height100 == 1, and Brazil == 1, then Sihat is the 100 ft tall waterfall located in Brazil.

### Decision variables:
-   Names of the waterfalls: Sihat, Rhoqua, Nyalt, Inawatai (all different, 1 to 4)
-   Heights of the waterfalls: Height100, Height105, Height110, Height115 (all different, 1 to 4)
-   Countries where the waterfalls are located: Brazil, Nigeria, Tibet, Switzerland (all different, 1 to 4)

### Constraints:
-   The 115 ft tall waterfall is either the waterfall in Nigeria or the waterfall located in Tibet:
    This constraint states that the 115 ft tall waterfall is either in Nigeria or Tibet, but not both. So:
    Xor([Height115 == Nigeria, Height115 == Tibet]).

-   Inawatai is 100 ft tall:
    This constraint directly assigns the height of Inawatai to be 100 ft:
    Inawatai == Height100.

-   Nyalt is 10 ft taller than Rhoqua:
    This constraint states that Nyalt's height is 10 ft greater than Rhoqua's height. So:
    Nyalt_to_int == Rhoqua_to_int + 10.

-   The waterfall in Brazil is somewhat shorter than Rhoqua:
    This constraint implies that the waterfall in Brazil is shorter than Rhoqua, but not necessarily by a specific amount. So:
    Brazil_to_int < Rhoqua_to_int.

-   The waterfall in Brazil is 10 ft shorter than the waterfall located in Nigeria:
    This constraint specifies the height difference between the waterfalls in Brazil and Nigeria. So:
    Brazil_to_int == Nigeria_to_int + 10.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of waterfall, height, and country)
# e.g. if sihat == 1 and height100 == 1 and brazil == 1, then Sihat is the 100 ft tall waterfall located in Brazil
sihat, rhoqua, nyalt, inawatai = waterfalls = intvar(1, 4, shape=4)
height100, height105, height110, height115 = heights = intvar(1, 4, shape=4)
brazil, nigeria, tibet, switzerland = countries = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
waterfall_to_int = None  # N/A
height_to_int = {height100: 100, height105: 105, height110: 110, height115: 115}  # in ft
country_to_int = {brazil: 1, nigeria: 2, tibet: 3, switzerland: 4}  # arbitrary order


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(waterfalls)
m += AllDifferent(heights)
m += AllDifferent(countries)

# Clue 1: The 115 ft tall waterfall is either in Nigeria or Tibet
m += Xor([
    height115 == nigeria,
    height115 == tibet
])

# Clue 2: Inawatai is 100 ft tall
m += inawatai == height100

# Clue 3: Nyalt is 10 ft taller than Rhoqua
m += nyalt == rhoqua + 10

# Clue 4: The waterfall in Brazil is somewhat shorter than Rhoqua
m += brazil < rhoqua

# Clue 5: The waterfall in Brazil is 10 ft shorter than the waterfall in Nigeria
m += brazil == nigeria + 10

```
None
False
False
False
Wrong: 3, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Evan played 9 games.
Vincent played first base.
The player who played third base played 2 more games than the person who played center field.
Charles played 2 more games than the player who played center field.
Charles was either the boy who played 9 games or the person who played 10 games.

Entities:
players: Charles, Evan, Karl, Vincent
games: 8, 9, 10, 11
positions: center field, first base, shortstop, third base
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Charles == 1, and Evan == 1, and CenterField == 1, then Charles played 8 games in center field.

### Decision variables:
-   Names of the players: Charles, Evan, Karl, Vincent (all different, 1 to 4)
-   Number of games played: 8, 9, 10, 11 (all different, 1 to 4)
-   Positions played: CenterField, FirstBase, Shortstop, ThirdBase (all different, 1 to 4)

### Constraints:
-   Evan played 9 games:
    This constraint directly assigns the number of games played by Evan:
    Evan == 9.

-   Vincent played first base:
    This constraint directly assigns the position played by Vincent:
    Vincent == FirstBase.

-   The player who played third base played 2 more games than the person who played center field:
    For this, we will need to add a constraint for each possible assignment of games played by the player in third base and center field, such that the games played by the third base player is 2 more than the games played by the center field player. So, the constraints will be of the form:
    p1 == ThirdBase and p2 == CenterField => p1_to_int == p2_to_int + 2, for all p1, p2 in games played.

-   Charles played 2 more games than the player who played center field:
    For this, we will need to add a constraint for each possible assignment of games played by Charles and the player in center field, such that Charles played 2 more games than the center field player. So, the constraints will be of the form:
    p1 == Charles and p2 == CenterField => p1_to_int == p2_to_int + 2, for all p1, p2 in games played.

-   Charles was either the boy who played 9 games or the person who played 10 games:
    This is a constraint that states that Charles played either 9 or 10 games, but not both. So:
    Xor([Charles == 9, Charles == 10]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Charles == 1, and Evan == 1, and CenterField == 1, then Charles played 8 games in center field.

### Decision variables:
-   Names of the players: Charles, Evan, Karl, Vincent (all different, 1 to 4)
-   Number of games played: 8, 9, 10, 11 (all different, 1 to 4)
-   Positions played: CenterField, FirstBase, Shortstop, ThirdBase (all different, 1 to 4)

### Constraints:
-   Evan played 9 games:
    This constraint directly assigns the number of games played by Evan:
    Evan == 9.

-   Vincent played first base:
    This constraint directly assigns the position played by Vincent:
    Vincent == FirstBase.

-   The player who played third base played 2 more games than the person who played center field:
    For this, we will need to add a constraint for each possible assignment of games played by the player in third base and center field, such that the games played by the third base player is 2 more than the games played by the center field player. So, the constraints will be of the form:
    p1 == ThirdBase and p2 == CenterField => p1_to_int == p2_to_int + 2, for all p1, p2 in games played.

-   Charles played 2 more games than the player who played center field:
    For this, we will need to add a constraint for each possible assignment of games played by Charles and the player in center field, such that Charles played 2 more games than the center field player. So, the constraints will be of the form:
    p1 == Charles and p2 == CenterField => p1_to_int == p2_to_int + 2, for all p1, p2 in games played.

-   Charles was either the boy who played 9 games or the person who played 10 games:
    This is a constraint that states that Charles played either 9 or 10 games, but not both. So:
    Xor([Charles == 9, Charles == 10]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of player, games, and position)
# e.g. if charles == 1 and evan == 1 and centerfield == 1, then Charles played 8 games in center field
charles, evan, karl, vincent = players = intvar(1, 4, shape=4)
games8, games9, games10, games11 = games = intvar(1, 4, shape=4)
centerfield, firstbase, shortstop, thirdbase = positions = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
player_to_int = None  # N/A
games_to_int = {games8: 8, games9: 9, games10: 10, games11: 11}  # number of games
position_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def played_more_games(var1, var2, diff):
    """
    Formulate the constraint that var1 played exactly diff more games than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(games_to_int[p1] == games_to_int[p2] + diff)
            for p1 in games for p2 in games]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(players)
m += AllDifferent(games)
m += AllDifferent(positions)

# Clue 1: Evan played 9 games
m += evan == games9

# Clue 2: Vincent played first base
m += vincent == firstbase

# Clue 3: The player who played third base played 2 more games than the person who played center field
m += played_more_games(thirdbase, centerfield, 2)

# Clue 4: Charles played 2 more games than the player who played center field
m += played_more_games(charles, centerfield, 2)

# Clue 5: Charles was either the boy who played 9 games or the person who played 10 games
m += Xor([
    charles == games9,
    charles == games10
])

```
[['charles', 'games10', 'thirdbase'], ['vincent', 'games11', 'firstbase'], ['evan', 'games9', 'shortstop'], ['karl', 'games8', 'centerfield']]
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Edmund paid 1 dollar less than the one who got the water.
The diner who paid $4 had the iced tea.
Angela paid more than the one who got the cream soda.
The diner who paid $5 was either the one who got the cream soda or the one who got the iced tea.
The four diners were the diner who paid $5, the one who got the iced tea, the one who got the root beer and Irene.

Entities:
names: Angela, Edmund, Homer, Irene
prices: $4, $5, $6, $7
drinks: cream soda, iced tea, root beer, water
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Angela == 1, and Price4 == 1, and CreamSoda == 1, then Angela paid $4 for the cream soda.

### Decision variables:
-   Names of the diners: Angela, Edmund, Homer, Irene (all different, 1 to 4)
-   Prices paid by the diners: Price4, Price5, Price6, Price7 (all different, 1 to 4)
-   Drinks ordered by the diners: CreamSoda, IcedTea, RootBeer, Water (all different, 1 to 4)

### Constraints:
-   Edmund paid 1 dollar less than the one who got the water:
    For this, we will need to add a constraint for each possible assignment of prices to Edmund and the water drink, such that Edmund's price is 1 less than the water drink's price. So, the constraints will be of the form:
    p1 == Edmund and p2 == Water => p1_to_int == p2_to_int - 1, for all p1, p2 in prices.

-   The diner who paid $4 had the iced tea:
    This is a constraint that states that the diner who paid $4 had the iced tea. So:
    Price4 == IcedTea.

-   Angela paid more than the one who got the cream soda:
    For this, we will need to add a constraint for each possible assignment of prices to Angela and the cream soda drink, such that Angela's price is greater than the cream soda drink's price. So, the constraints will be of the form:
    p1 == Angela and p2 == CreamSoda => p1_to_int > p2_to_int, for all p1, p2 in prices.

-   The diner who paid $5 was either the one who got the cream soda or the one who got the iced tea:
    This is a constraint that states that the diner who paid $5 had either the cream soda or the iced tea. So:
    Xor([Price5 == CreamSoda, Price5 == IcedTea]).

-   The four diners were the diner who paid $5, the one who got the iced tea, the one who got the root beer, and Irene:
    This is a constraint that states that the four diners are the ones who paid $5, got the iced tea, got the root beer, and Irene. So:
    AllDifferent([Price5, IcedTea, RootBeer, Irene]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Angela == 1, and Price4 == 1, and CreamSoda == 1, then Angela paid $4 for the cream soda.

### Decision variables:
-   Names of the diners: Angela, Edmund, Homer, Irene (all different, 1 to 4)
-   Prices paid by the diners: Price4, Price5, Price6, Price7 (all different, 1 to 4)
-   Drinks ordered by the diners: CreamSoda, IcedTea, RootBeer, Water (all different, 1 to 4)

### Constraints:
-   Edmund paid 1 dollar less than the one who got the water:
    For this, we will need to add a constraint for each possible assignment of prices to Edmund and the water drink, such that Edmund's price is 1 less than the water drink's price. So, the constraints will be of the form:
    p1 == Edmund and p2 == Water => p1_to_int == p2_to_int - 1, for all p1, p2 in prices.

-   The diner who paid $4 had the iced tea:
    This is a constraint that states that the diner who paid $4 had the iced tea. So:
    Price4 == IcedTea.

-   Angela paid more than the one who got the cream soda:
    For this, we will need to add a constraint for each possible assignment of prices to Angela and the cream soda drink, such that Angela's price is greater than the cream soda drink's price. So, the constraints will be of the form:
    p1 == Angela and p2 == CreamSoda => p1_to_int > p2_to_int, for all p1, p2 in prices.

-   The diner who paid $5 was either the one who got the cream soda or the one who got the iced tea:
    This is a constraint that states that the diner who paid $5 had either the cream soda or the iced tea. So:
    Xor([Price5 == CreamSoda, Price5 == IcedTea]).

-   The four diners were the diner who paid $5, the one who got the iced tea, the one who got the root beer, and Irene:
    This is a constraint that states that the four diners are the ones who paid $5, got the iced tea, got the root beer, and Irene. So:
    AllDifferent([Price5, IcedTea, RootBeer, Irene]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of diner, price, and drink)
# e.g. if angela == 1 and price4 == 1 and cream_soda == 1, then Angela paid $4 for the cream soda
angela, edmund, homer, irene = diners = intvar(1, 4, shape=4)
price4, price5, price6, price7 = prices = intvar(1, 4, shape=4)
cream_soda, iced_tea, root_beer, water = drinks = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
diner_to_int = None  # N/A
price_to_int = {price4: 4, price5: 5, price6: 6, price7: 7}  # in dollars
drink_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def paid_less_than(var1, var2, diff):
    """
    Formulate the constraint that var1 paid diff dollars less than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] - diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(diners)
m += AllDifferent(prices)
m += AllDifferent(drinks)

# Clue 1: Edmund paid 1 dollar less than the one who got the water:
m += paid_less_than(edmund, water, 1)

# Clue 2: The diner who paid $4 had the iced tea:
m += price4 == iced_tea

# Clue 3: Angela paid more than the one who got the cream soda:
m += [((p1 == angela) & (p2 == cream_soda)).implies(price_to_int[p1] > price_to_int[p2)
      for p1 in prices for p2 in prices]

# Clue 4: The diner who paid $5 was either the one who got the cream soda or the one who got the iced tea:
m += Xor([
    price5 == cream_soda,
    price5 == iced_tea
])

# Clue 5: The four diners were the diner who paid $5, the one who got the iced tea, the one who got the root beer, and Irene:
m += AllDifferent([price5, iced_tea, root_beer, irene])

```
None
Error when trying to check solution from predicted model: invalid syntax (<string>, line 1)
False
False
Error in constraint evaluation: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
Ingram had 7 goals this season.
The four players are Underwood, the player from the Ice Hogs, the player from the Monsters and the player from the Checkers.
Parrish scored 1 goal more than Quinn.
The player with 9 goals is from the Ice Hogs.
Ingram is either the player from the Checkers or the player with 6 goals.

Entities:
players: Ingram, Parrish, Quinn, Underwood
goals: 6, 7, 8, 9
teams: Checkers, Comets, Ice Hogs, Monsters
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ingram == 1, and Goals7 == 1, and Checkers == 1, then Ingram from the Checkers scored 7 goals.

### Decision variables:
-   Names of the players: Ingram, Parrish, Quinn, Underwood (all different, 1 to 4)
-   Number of goals scored: Goals6, Goals7, Goals8, Goals9 (all different, 1 to 4)
-   Teams: Checkers, Comets, Ice Hogs, Monsters (all different, 1 to 4)

### Constraints:
-   Ingram had 7 goals this season:
    This constraint directly assigns 7 goals to Ingram:
    Ingram == Goals7.

-   The four players are Underwood, the player from the Ice Hogs, the player from the Monsters, and the player from the Checkers:
    This constraint states that each player corresponds to one of the mentioned teams. So, we will have:
    AllDifferent([Underwood, Ice Hogs, Monsters, Checkers]).

-   Parrish scored 1 goal more than Quinn:
    This constraint states that the number of goals scored by Parrish is 1 more than Quinn:
    p1 == Parrish and p2 == Quinn => p1_to_int == p2_to_int + 1, for all p1, p2 in goals.

-   The player with 9 goals is from the Ice Hogs:
    This constraint directly assigns 9 goals to the player from the Ice Hogs:
    Ice Hogs == Goals9.

-   Ingram is either the player from the Checkers or the player with 6 goals:
    This constraint states that Ingram is either from the Checkers or scored 6 goals, but not both:
    Xor([Ingram == Checkers, Ingram == Goals6]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ingram == 1, and Goals7 == 1, and Checkers == 1, then Ingram from the Checkers scored 7 goals.

### Decision variables:
-   Names of the players: Ingram, Parrish, Quinn, Underwood (all different, 1 to 4)
-   Number of goals scored: Goals6, Goals7, Goals8, Goals9 (all different, 1 to 4)
-   Teams: Checkers, Comets, Ice Hogs, Monsters (all different, 1 to 4)

### Constraints:
-   Ingram had 7 goals this season:
    This constraint directly assigns 7 goals to Ingram:
    Ingram == Goals7.

-   The four players are Underwood, the player from the Ice Hogs, the player from the Monsters, and the player from the Checkers:
    This constraint states that each player corresponds to one of the mentioned teams. So, we will have:
    AllDifferent([Underwood, Ice Hogs, Monsters, Checkers]).

-   Parrish scored 1 goal more than Quinn:
    This constraint states that the number of goals scored by Parrish is 1 more than Quinn:
    p1 == Parrish and p2 == Quinn => p1_to_int == p2_to_int + 1, for all p1, p2 in goals.

-   The player with 9 goals is from the Ice Hogs:
    This constraint directly assigns 9 goals to the player from the Ice Hogs:
    Ice Hogs == Goals9.

-   Ingram is either the player from the Checkers or the player with 6 goals:
    This constraint states that Ingram is either from the Checkers or scored 6 goals, but not both:
    Xor([Ingram == Checkers, Ingram == Goals6]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of player, goals, and team)
# e.g. if ingram == 1 and goals7 == 1 and checkers == 1, then Ingram from the Checkers scored 7 goals
ingram, parrish, quinn, underwood = players = intvar(1, 4, shape=4)
goals6, goals7, goals8, goals9 = goals = intvar(1, 4, shape=4)
checkers, comets, ice_hogs, monsters = teams = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
player_to_int = None  # N/A
goals_to_int = {goals6: 6, goals7: 7, goals8: 8, goals9: 9}  # number of goals
team_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def scored_more_than(var1, var2):
    """
    Formulate the constraint that var1 scored more goals than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(goals_to_int[p1] > goals_to_int[p2])
            for p1 in goals for p2 in goals]


def scored_exactly_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 scored exactly diff more goals than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(goals_to_int[p1] == goals_to_int[p2] + diff)
            for p1 in goals for p2 in goals]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(players)
m += AllDifferent(goals)
m += AllDifferent(teams)

# Clue 1: Ingram had 7 goals this season
m += ingram == goals7

# Clue 2: The four players are Underwood, the player from the Ice Hogs, the player from the Monsters, and the player from the Checkers
m += AllDifferent([underwood, ice_hogs, monsters, checkers])

# Clue 3: Parrish scored 1 goal more than Quinn
m += scored_exactly_more_than(parrish, quinn, 1)

# Clue 4: The player with 9 goals is from the Ice Hogs
m += ice_hogs == goals9

# Clue 5: Ingram is either the player from the Checkers or the player with 6 goals
m += Xor([
    ingram == checkers,
    ingram == goals6
])

```
[['ingram', 'goals7', 'checkers'], ['quinn', 'goals8', 'monsters'], ['underwood', 'goals6', 'comets'], ['parrish', 'goals9', 'ice_hogs']]
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Jorge is either the skydiver who wears the red suit or the jumper who started in 1982.
The skydiver who wears the pink suit started skydiving 1 year before Otis.
The jumper who wears the yellow suit started skydiving sometime after Philip.
The jumper who wears the lime green suit started skydiving sometime after the jumper who wears the yellow suit.
The jumper who wears the pink suit started skydiving 2 years before Shaun.

Entities:
names: Jorge, Otis, Philip, Shaun
years: 1982, 1983, 1984, 1985
suit colors: lime green, pink, red, yellow
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Jorge == 1, and Year1982 == 1, and LimeGreen == 1, then Jorge is the skydiver who started in 1982 and wears the lime green suit.

### Decision variables:
-   Names of the skydivers: Jorge, Otis, Philip, Shaun (all different, 1 to 4)
-   Starting years of skydiving: 1982, 1983, 1984, 1985 (all different, 1 to 4)
-   Suit colors: LimeGreen, Pink, Red, Yellow (all different, 1 to 4)

### Constraints:
-   Jorge is either the skydiver who wears the red suit or the jumper who started in 1982:
    This is a constraint that states that Jorge's suit color is either red or Jorge started skydiving in 1982, but not both. So:
    Xor([Jorge == Red, Jorge == Year1982]).

-   The skydiver who wears the pink suit started skydiving 1 year before Otis:
    For this, we will need to add a constraint for each possible assignment of starting years for the skydiver who wears the pink suit and Otis, such that the pink suit skydiver's starting year is 1 less than Otis's starting year. So, the constraints will be of the form:
    y1 == Pink and y2 == Otis => y1_to_int == y2_to_int - 1, for all y1, y2 in starting years.

-   The jumper who wears the yellow suit started skydiving sometime after Philip:
    For this, we will need to add a constraint for each possible assignment of starting years for the jumper who wears the yellow suit and Philip, such that the yellow suit jumper's starting year is greater than Philip's starting year. So, the constraints will be of the form:
    y1 == Yellow and y2 == Philip => y1_to_int > y2_to_int, for all y1, y2 in starting years.

-   The jumper who wears the lime green suit started skydiving sometime after the jumper who wears the yellow suit:
    For this, we will need to add a constraint for each possible assignment of starting years for the jumper who wears the lime green suit and the jumper who wears the yellow suit, such that the lime green suit jumper's starting year is greater than the yellow suit jumper's starting year. So, the constraints will be of the form:
    y1 == LimeGreen and y2 == Yellow => y1_to_int > y2_to_int, for all y1, y2 in starting years.

-   The jumper who wears the pink suit started skydiving 2 years before Shaun:
    For this, we will need to add a constraint for each possible assignment of starting years for the jumper who wears the pink suit and Shaun, such that the pink suit jumper's starting year is 2 less than Shaun's starting year. So, the constraints will be of the form:
    y1 == Pink and y2 == Shaun => y1_to_int == y2_to_int - 2, for all y1, y2 in starting years.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Jorge == 1, and Year1982 == 1, and LimeGreen == 1, then Jorge is the skydiver who started in 1982 and wears the lime green suit.

### Decision variables:
-   Names of the skydivers: Jorge, Otis, Philip, Shaun (all different, 1 to 4)
-   Starting years of skydiving: 1982, 1983, 1984, 1985 (all different, 1 to 4)
-   Suit colors: LimeGreen, Pink, Red, Yellow (all different, 1 to 4)

### Constraints:
-   Jorge is either the skydiver who wears the red suit or the jumper who started in 1982:
    This is a constraint that states that Jorge's suit color is either red or Jorge started skydiving in 1982, but not both. So:
    Xor([Jorge == Red, Jorge == Year1982]).

-   The skydiver who wears the pink suit started skydiving 1 year before Otis:
    For this, we will need to add a constraint for each possible assignment of starting years for the skydiver who wears the pink suit and Otis, such that the pink suit skydiver's starting year is 1 less than Otis's starting year. So, the constraints will be of the form:
    y1 == Pink and y2 == Otis => y1_to_int == y2_to_int - 1, for all y1, y2 in starting years.

-   The jumper who wears the yellow suit started skydiving sometime after Philip:
    For this, we will need to add a constraint for each possible assignment of starting years for the jumper who wears the yellow suit and Philip, such that the yellow suit jumper's starting year is greater than Philip's starting year. So, the constraints will be of the form:
    y1 == Yellow and y2 == Philip => y1_to_int > y2_to_int, for all y1, y2 in starting years.

-   The jumper who wears the lime green suit started skydiving sometime after the jumper who wears the yellow suit:
    For this, we will need to add a constraint for each possible assignment of starting years for the jumper who wears the lime green suit and the jumper who wears the yellow suit, such that the lime green suit jumper's starting year is greater than the yellow suit jumper's starting year. So, the constraints will be of the form:
    y1 == LimeGreen and y2 == Yellow => y1_to_int > y2_to_int, for all y1, y2 in starting years.

-   The jumper who wears the pink suit started skydiving 2 years before Shaun:
    For this, we will need to add a constraint for each possible assignment of starting years for the jumper who wears the pink suit and Shaun, such that the pink suit jumper's starting year is 2 less than Shaun's starting year. So, the constraints will be of the form:
    y1 == Pink and y2 == Shaun => y1_to_int == y2_to_int - 2, for all y1, y2 in starting years.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of skydiver, starting year, and suit color)
# e.g. if jorge == 1 and year1982 == 1 and limegreen == 1, then Jorge started skydiving in 1982 and wears the lime green suit
jorge, otis, philip, shaun = skydivers = intvar(1, 4, shape=4)
year1982, year1983, year1984, year1985 = starting_years = intvar(1, 4, shape=4)
limegreen, pink, red, yellow = suit_colors = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
skydiver_to_int = None  # N/A
year_to_int = {year1982: 1982, year1983: 1983, year1984: 1984, year1985: 1985}  # in years
suit_to_int = {limegreen: 1, pink: 2, red: 3, yellow: 4}  # arbitrary order


# Helper functions (for formulating comparison constraints)
def started_before_than(var1, var2):
    """
    Formulate the constraint that var1 started before var2.
    """
    return [((y1 == var1) & (y2 == var2)).implies(year_to_int[y1] < year_to_int[y2])
            for y1 in starting_years for y2 in starting_years]


def started_exactly_before_than(var1, var2, diff):
    """
    Formulate the constraint that var1 started exactly diff years before var2.
    """
    return [((y1 == var1) & (y2 == var2)).implies(year_to_int[y1] == year_to_int[y2] - diff)
            for y1 in starting_years for y2 in starting_years]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(skydivers)
m += AllDifferent(starting_years)
m += AllDifferent(suit_colors)

# Clue 1: Jorge is either the skydiver who wears the red suit or the jumper who started in 1982:
m += Xor([
    jorge == red,
    jorge == year1982
])

# Clue 2: The skydiver who wears the pink suit started skydiving 1 year before Otis:
m += started_exactly_before_than(pink, otis, 1)

# Clue 3: The jumper who wears the yellow suit started skydiving sometime after Philip:
m += started_before_than(yellow, philip)

# Clue 4: The jumper who wears the lime green suit started skydiving sometime after the jumper who wears the yellow suit:
m += started_before_than(limegreen, yellow)

# Clue 5: The jumper who wears the pink suit started skydiving 2 years before Shaun:
m += started_exactly_before_than(pink, shaun, 2)

```
[['jorge', 'year1982', 'pink'], ['otis', 'year1983', 'limegreen'], ['shaun', 'year1984', 'yellow'], ['philip', 'year1985', 'red']]
False
False
False
Wrong: 2, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The variety that requires 190 degree water costs 1 dollar less than the variety that requires 195 degree water.
The Pouchong costs 1 dollar less than the Red Robe.
The Pouchong needs 195 degree water.
The four teas are the Ali Shan, the variety that costs $6, the variety that requires 200 degree water and the tea that requires 190 degree water.

Entities:
teas: Ali Shan, Jin Xuan, Pouchong, Red Robe
prices: $4, $5, $6, $7
temperatures: 190 degree, 195 degree, 200 degree, 215 degree
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ali Shan == 1, and Price4 == 1, and Temp190 == 1, then Ali Shan costs $4 and requires 190-degree water.

### Decision variables:
-   Types of teas: Ali Shan, Jin Xuan, Pouchong, Red Robe (all different, 1 to 4)
-   Prices of teas: Price4, Price5, Price6, Price7 (all different, 1 to 4)
-   Water temperatures: Temp190, Temp195, Temp200, Temp215 (all different, 1 to 4)

### Constraints:
-   The variety that requires 190-degree water costs 1 dollar less than the variety that requires 195-degree water:
    For this, we will need to add a constraint for each possible assignment of teas requiring 190-degree and 195-degree water, such that the tea requiring 190-degree water costs 1 dollar less than the tea requiring 195-degree water. So, the constraints will be of the form:
    t1 == Temp190 and t2 == Temp195 => t1_price == t2_price - 1, for all t1, t2 in teas.

-   The Pouchong costs 1 dollar less than the Red Robe:
    For this, we will need to add a constraint stating that the Pouchong costs 1 dollar less than the Red Robe. So, the constraint will be:
    Pouchong_price == RedRobe_price - 1.

-   The Pouchong needs 195-degree water:
    This is a constraint that directly states that the Pouchong requires 195-degree water:
    Pouchong == Temp195.

-   The four teas are the Ali Shan, the variety that costs $6, the variety that requires 200-degree water, and the tea that requires 190-degree water:
    This constraint specifies the four teas mentioned in the problem statement. It can be represented as:
    AllDifferent([AliShan, Price6, Temp200, Temp190]).

### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ali Shan == 1, and Price4 == 1, and Temp190 == 1, then Ali Shan costs $4 and requires 190-degree water.

### Decision variables:
-   Types of teas: Ali Shan, Jin Xuan, Pouchong, Red Robe (all different, 1 to 4)
-   Prices of teas: Price4, Price5, Price6, Price7 (all different, 1 to 4)
-   Water temperatures: Temp190, Temp195, Temp200, Temp215 (all different, 1 to 4)

### Constraints:
-   The variety that requires 190-degree water costs 1 dollar less than the variety that requires 195-degree water:
    For this, we will need to add a constraint for each possible assignment of teas requiring 190-degree and 195-degree water, such that the tea requiring 190-degree water costs 1 dollar less than the tea requiring 195-degree water. So, the constraints will be of the form:
    t1 == Temp190 and t2 == Temp195 => t1_price == t2_price - 1, for all t1, t2 in teas.

-   The Pouchong costs 1 dollar less than the Red Robe:
    For this, we will need to add a constraint stating that the Pouchong costs 1 dollar less than the Red Robe. So, the constraint will be:
    Pouchong_price == RedRobe_price - 1.

-   The Pouchong needs 195-degree water:
    This is a constraint that directly states that the Pouchong requires 195-degree water:
    Pouchong == Temp195.

-   The four teas are the Ali Shan, the variety that costs $6, the variety that requires 200-degree water, and the tea that requires 190-degree water:
    This constraint specifies the four teas mentioned in the problem statement. It can be represented as:
    AllDifferent([AliShan, Price6, Temp200, Temp190]).

```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of tea, price, and temperature)
# e.g. if alishan == 1 and price4 == 1 and temp190 == 1, then Ali Shan costs $4 and requires 190-degree water
alishan, jinxuan, pouchong, redrobe = teas = intvar(1, 4, shape=4)
price4, price5, price6, price7 = prices = intvar(1, 4, shape=4)
temp190, temp195, temp200, temp215 = temperatures = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
tea_to_int = None  # N/A
price_to_int = {price4: 4, price5: 5, price6: 6, price7: 7}  # in dollars
temp_to_int = {temp190: 190, temp195: 195, temp200: 200, temp215: 215}  # in degrees


# Helper functions (for formulating comparison constraints)
def costs_less_than(var1, var2, diff):
    """
    Formulate the constraint that var1 costs diff dollars less than var2.
    """
    return [((t1 == var1) & (t2 == var2)).implies(price_to_int[t1] == price_to_int[t2] - diff)
            for t1 in prices for t2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(teas)
m += AllDifferent(prices)
m += AllDifferent(temperatures)

# Clue 1: The variety that requires 190-degree water costs 1 dollar less than the variety that requires 195-degree water:
m += costs_less_than(temp190, temp195, 1)

# Clue 2: The Pouchong costs 1 dollar less than the Red Robe:
m += pouchong == redrobe - 1

# Clue 3: The Pouchong needs 195-degree water:
m += pouchong == temp195

# Clue 4: The four teas are the Ali Shan, the variety that costs $6, the variety that requires 200-degree water, and the tea that requires 190-degree water:
m += AllDifferent([alishan, price6, temp200, temp190])

```
[['pouchong', 'price6', 'temp195'], ['redrobe', 'price7', 'temp200'], ['jinxuan', 'price5', 'temp190'], ['alishan', 'price4', 'temp215']]
True
True
False
Wrong: 1, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The flier leaving in April will bring shamrock.
The passenger with the rabbit's foot will leave 1 month after Troy.
The flier with the horseshoe will leave 1 month after Doug.
The flier with the horseshoe is either Peggy or the passenger leaving in January.

Entities:
fliers: Doug, Eloise, Peggy, Troy
months: January, February, March, April
lucky charms: coin, horseshoe, rabbit's foot, shamrock
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Doug == 1, and January == 1, and Coin == 1, then Doug is the flier leaving in January with a coin.

### Decision variables:
-   Names of the fliers: Doug, Eloise, Peggy, Troy (all different, 1 to 4)
-   Months of departure: January, February, March, April (all different, 1 to 4)
-   Lucky charms: Coin, Horseshoe, RabbitFoot, Shamrock (all different, 1 to 4)

### Constraints:
-   The flier leaving in April will bring shamrock:
    For this, we will need to add a constraint for each possible assignment of the fliers and lucky charms, such that the flier leaving in April has the shamrock. So, the constraints will be of the form:
    f1 == April and l1 == Shamrock, for all f1, l1 in months and lucky charms.

-   The passenger with the rabbit's foot will leave 1 month after Troy:
    For this, we will need to add a constraint for each possible assignment of the fliers and months of departure, such that the flier with the rabbit's foot leaves 1 month after Troy. So, the constraints will be of the form:
    f1 == Troy and f2 == RabbitFoot => f1_to_int + 1 == f2_to_int, for all f1, f2 in fliers.

-   The flier with the horseshoe will leave 1 month after Doug:
    For this, we will need to add a constraint for each possible assignment of the fliers and months of departure, such that the flier with the horseshoe leaves 1 month after Doug. So, the constraints will be of the form:
    f1 == Doug and f2 == Horseshoe => f1_to_int + 1 == f2_to_int, for all f1, f2 in fliers.

-   The flier with the horseshoe is either Peggy or the passenger leaving in January:
    This is a constraint that states that the flier with the horseshoe is either Peggy or the flier leaving in January, but not both. So:
    Xor([Horseshoe == Peggy, January == Horseshoe]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Doug == 1, and January == 1, and Coin == 1, then Doug is the flier leaving in January with a coin.

### Decision variables:
-   Names of the fliers: Doug, Eloise, Peggy, Troy (all different, 1 to 4)
-   Months of departure: January, February, March, April (all different, 1 to 4)
-   Lucky charms: Coin, Horseshoe, RabbitFoot, Shamrock (all different, 1 to 4)

### Constraints:
-   The flier leaving in April will bring shamrock:
    For this, we will need to add a constraint for each possible assignment of the fliers and lucky charms, such that the flier leaving in April has the shamrock. So, the constraints will be of the form:
    f1 == April and l1 == Shamrock, for all f1, l1 in months and lucky charms.

-   The passenger with the rabbit's foot will leave 1 month after Troy:
    For this, we will need to add a constraint for each possible assignment of the fliers and months of departure, such that the flier with the rabbit's foot leaves 1 month after Troy. So, the constraints will be of the form:
    f1 == Troy and f2 == RabbitFoot => f1_to_int + 1 == f2_to_int, for all f1, f2 in fliers.

-   The flier with the horseshoe will leave 1 month after Doug:
    For this, we will need to add a constraint for each possible assignment of the fliers and months of departure, such that the flier with the horseshoe leaves 1 month after Doug. So, the constraints will be of the form:
    f1 == Doug and f2 == Horseshoe => f1_to_int + 1 == f2_to_int, for all f1, f2 in fliers.

-   The flier with the horseshoe is either Peggy or the passenger leaving in January:
    This is a constraint that states that the flier with the horseshoe is either Peggy or the flier leaving in January, but not both. So:
    Xor([Horseshoe == Peggy, January == Horseshoe]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of flier, month, and lucky charm)
# e.g. if doug == 1 and january == 1 and coin == 1, then Doug will leave in January with a coin
doug, eloise, peggy, troy = fliers = intvar(1, 4, shape=4)
january, february, march, april = months = intvar(1, 4, shape=4)
coin, horseshoe, rabbitfoot, shamrock = lucky_charms = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
flier_to_int = None  # N/A
month_to_int = {january: 1, february: 2, march: 3, april: 4}  # in months
lucky_charm_to_int = {coin: 1, horseshoe: 2, rabbitfoot: 3, shamrock: 4}  # in lucky charms


# Helper functions (for formulating comparison constraints)
def bring_lucky_charm(var1, var2):
    """
    Formulate the constraint that var1 will bring var2 as the lucky charm.
    """
    return [((f1 == var1) & (l1 == var2))
            for f1 in months for l1 in lucky_charms]


def leave_after(var1, var2):
    """
    Formulate the constraint that var1 will leave after var2.
    """
    return [((f1 == var1) & (f2 == var2)).implies(month_to_int[f1] == month_to_int[f2] + 1)
            for f1 in fliers for f2 in fliers]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(fliers)
m += AllDifferent(months)
m += AllDifferent(lucky_charms)

# Clue 1: The flier leaving in April will bring shamrock:
m += bring_lucky_charm(april, shamrock)

# Clue 2: The passenger with the rabbit's foot will leave 1 month after Troy:
m += leave_after(rabbitfoot, troy)

# Clue 3: The flier with the horseshoe will leave 1 month after Doug:
m += leave_after(horseshoe, doug)

# Clue 4: The flier with the horseshoe is either Peggy or the passenger leaving in January:
m += Xor([
    horseshoe == peggy,
    january == horseshoe
])

```
None
Error when trying to check solution from predicted model: name 'IV2772' is not defined
False
False
Error in constraint evaluation: name 'IV2796' is not defined
---------------------------------------------------------------------------------------------

Clues:
Ronda's sandwich and the sandwich with havarti cheese are different sandwiches.
Ronda's order costs $5.
Lula's order is either the 3 dollars sandwich or the order that costs 5 dollars.
The sandwich with cheddar cheese costs less than the order with havarti cheese.
Yolanda's sandwich costs 2 dollars less than the order with swiss cheese.

Entities:
customers: Lula, Ronda, Sue, Yolanda
prices: $2, $3, $4, $5
cheeses: cheddar, havarti, muenster, swiss
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Lula == 1, and Price2 == 1, and Cheddar == 1, then Lula ordered the $2 sandwich with cheddar cheese.

### Decision variables:
-   Names of the customers: Lula, Ronda, Sue, Yolanda (all different, 1 to 4)
-   Prices of the orders: Price2, Price3, Price4, Price5 (all different, 1 to 4)
-   Types of cheeses: Cheddar, Havarti, Muenster, Swiss (all different, 1 to 4)

### Constraints:
-   Ronda's sandwich and the sandwich with havarti cheese are different sandwiches:
    This constraint ensures that Ronda's sandwich is not the one with havarti cheese:
    Ronda != Havarti.

-   Ronda's order costs $5:
    This constraint directly assigns the $5 price to Ronda's order:
    Ronda == Price5.

-   Lula's order is either the $3 sandwich or the order that costs $5:
    This constraint states that Lula's order is either $3 or $5:
    Lula == Price3 or Lula == Price5.

-   The sandwich with cheddar cheese costs less than the order with havarti cheese:
    This constraint ensures that the order with cheddar cheese costs less than the order with havarti cheese:
    Cheddar < Havarti.

-   Yolanda's sandwich costs $2 less than the order with swiss cheese:
    This constraint states that Yolanda's order costs $2 less than the order with swiss cheese:
    Yolanda_to_int + 2 == Swiss_to_int.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Lula == 1, and Price2 == 1, and Cheddar == 1, then Lula ordered the $2 sandwich with cheddar cheese.

### Decision variables:
-   Names of the customers: Lula, Ronda, Sue, Yolanda (all different, 1 to 4)
-   Prices of the orders: Price2, Price3, Price4, Price5 (all different, 1 to 4)
-   Types of cheeses: Cheddar, Havarti, Muenster, Swiss (all different, 1 to 4)

### Constraints:
-   Ronda's sandwich and the sandwich with havarti cheese are different sandwiches:
    This constraint ensures that Ronda's sandwich is not the one with havarti cheese:
    Ronda != Havarti.

-   Ronda's order costs $5:
    This constraint directly assigns the $5 price to Ronda's order:
    Ronda == Price5.

-   Lula's order is either the $3 sandwich or the order that costs $5:
    This constraint states that Lula's order is either $3 or $5:
    Lula == Price3 or Lula == Price5.

-   The sandwich with cheddar cheese costs less than the order with havarti cheese:
    This constraint ensures that the order with cheddar cheese costs less than the order with havarti cheese:
    Cheddar < Havarti.

-   Yolanda's sandwich costs $2 less than the order with swiss cheese:
    This constraint states that Yolanda's order costs $2 less than the order with swiss cheese:
    Yolanda_to_int + 2 == Swiss_to_int.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of customer, price, and cheese)
# e.g. if lula == 1 and price2 == 1 and cheddar == 1, then Lula ordered the $2 sandwich with cheddar cheese
lula, ronda, sue, yolanda = customers = intvar(1, 4, shape=4)
price2, price3, price4, price5 = prices = intvar(1, 4, shape=4)
cheddar, havarti, muenster, swiss = cheeses = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
customer_to_int = None  # N/A
price_to_int = {price2: 2, price3: 3, price4: 4, price5: 5}  # in dollars
cheese_to_int = {cheddar: 1, havarti: 2, muenster: 3, swiss: 4}  # arbitrary order


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(customers)
m += AllDifferent(prices)
m += AllDifferent(cheeses)

# Clue 1: Ronda's sandwich and the sandwich with havarti cheese are different sandwiches:
m += ronda != havarti

# Clue 2: Ronda's order costs $5:
m += ronda == price5

# Clue 3: Lula's order is either the $3 sandwich or the order that costs $5:
m += (lula == price3) | (lula == price5)

# Clue 4: The sandwich with cheddar cheese costs less than the order with havarti cheese:
m += cheddar < havarti

# Clue 5: Yolanda's sandwich costs $2 less than the order with swiss cheese:
m += (yolanda + 2) == swiss

```
[['yolanda', 'price2', 'cheddar'], ['sue', 'price4', 'muenster'], ['ronda', 'price5', 'swiss'], ['lula', 'price3', 'havarti']]
False
False
False
Wrong: 3, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The rocket developed by Vexatech will launch 1 month after the Exatris.
The rocket developed by SpaceZen will launch sometime after the Beritron.
The Worul is made by Techtrin.
The Exatris will launch in January.
The Cornick is either the rocket that will launch in April or the rocket developed by Rubicorp.

Entities:
rockets: Beritron, Cornick, Exatris, Worul
months: January, February, March, April
companies: Rubicorp, SpaceZen, Techtrin, Vexatech
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Beritron == 1, and January == 1, and Rubicorp == 1, then Beritron is the rocket that will launch in January developed by Rubicorp.

### Decision variables:
-   Names of the rockets: Beritron, Cornick, Exatris, Worul (all different, 1 to 4)
-   Months of launch: January, February, March, April (all different, 1 to 4)
-   Companies developing the rockets: Rubicorp, SpaceZen, Techtrin, Vexatech (all different, 1 to 4)

### Constraints:
-   The rocket developed by Vexatech will launch 1 month after the Exatris:
    For this, we will need to add a constraint for each possible assignment of the months of launch for Vexatech's rocket and the Exatris, such that Vexatech's rocket's month of launch is 1 more than the Exatris's month of launch. So, the constraints will be of the form:
    m1 == Vexatech and m2 == Exatris => m1_to_int == m2_to_int + 1, for all m1, m2 in months of launch.

-   The rocket developed by SpaceZen will launch sometime after the Beritron:
    For this, we will need to add a constraint for each possible assignment of the months of launch for SpaceZen's rocket and the Beritron, such that SpaceZen's rocket's month of launch is greater than the Beritron's month of launch. So, the constraints will be of the form:
    m1 == SpaceZen and m2 == Beritron => m1_to_int > m2_to_int, for all m1, m2 in months of launch.

-   The Worul is made by Techtrin:
    This is a constraint that states that the Worul rocket is made by Techtrin. So:
    Worul == Techtrin.

-   The Exatris will launch in January:
    This is a constraint that states that the Exatris rocket will launch in January. So:
    Exatris == January.

-   The Cornick is either the rocket that will launch in April or the rocket developed by Rubicorp:
    This is a constraint that states that the Cornick rocket will either launch in April or be developed by Rubicorp, but not both. So:
    Xor([Cornick == April, Cornick == Rubicorp]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Beritron == 1, and January == 1, and Rubicorp == 1, then Beritron is the rocket that will launch in January developed by Rubicorp.

### Decision variables:
-   Names of the rockets: Beritron, Cornick, Exatris, Worul (all different, 1 to 4)
-   Months of launch: January, February, March, April (all different, 1 to 4)
-   Companies developing the rockets: Rubicorp, SpaceZen, Techtrin, Vexatech (all different, 1 to 4)

### Constraints:
-   The rocket developed by Vexatech will launch 1 month after the Exatris:
    For this, we will need to add a constraint for each possible assignment of the months of launch for Vexatech's rocket and the Exatris, such that Vexatech's rocket's month of launch is 1 more than the Exatris's month of launch. So, the constraints will be of the form:
    m1 == Vexatech and m2 == Exatris => m1_to_int == m2_to_int + 1, for all m1, m2 in months of launch.

-   The rocket developed by SpaceZen will launch sometime after the Beritron:
    For this, we will need to add a constraint for each possible assignment of the months of launch for SpaceZen's rocket and the Beritron, such that SpaceZen's rocket's month of launch is greater than the Beritron's month of launch. So, the constraints will be of the form:
    m1 == SpaceZen and m2 == Beritron => m1_to_int > m2_to_int, for all m1, m2 in months of launch.

-   The Worul is made by Techtrin:
    This is a constraint that states that the Worul rocket is made by Techtrin. So:
    Worul == Techtrin.

-   The Exatris will launch in January:
    This is a constraint that states that the Exatris rocket will launch in January. So:
    Exatris == January.

-   The Cornick is either the rocket that will launch in April or the rocket developed by Rubicorp:
    This is a constraint that states that the Cornick rocket will either launch in April or be developed by Rubicorp, but not both. So:
    Xor([Cornick == April, Cornick == Rubicorp]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of rocket, month, and company)
# e.g. if beritron == 1 and january == 1 and rubicorp == 1, then Beritron will launch in January developed by Rubicorp
beritron, cornick, exatris, worul = rockets = intvar(1, 4, shape=4)
january, february, march, april = months = intvar(1, 4, shape=4)
rubicorp, spacezen, techtrin, vexatech = companies = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
rocket_to_int = None  # N/A
month_to_int = {january: 1, february: 2, march: 3, april: 4}  # in months
company_to_int = {rubicorp: 1, spacezen: 2, techtrin: 3, vexatech: 4}  # in companies


# Helper functions (for formulating comparison constraints)
def launch_after_than(var1, var2):
    """
    Formulate the constraint that var1 launches after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] > month_to_int[m2])
            for m1 in months for m2 in months]


def launch_exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 launches exactly diff months after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] == month_to_int[m2] + diff)
            for m1 in months for m2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(rockets)
m += AllDifferent(months)
m += AllDifferent(companies)

# Clue 1: The rocket developed by Vexatech will launch 1 month after the Exatris:
m += launch_exactly_after_than(vexatech, exatris, 1)

# Clue 2: The rocket developed by SpaceZen will launch sometime after the Beritron:
m += launch_after_than(spacezen, beritron)

# Clue 3: The Worul is made by Techtrin:
m += worul == techtrin

# Clue 4: The Exatris will launch in January:
m += exatris == january

# Clue 5: The Cornick is either the rocket that will launch in April or the rocket developed by Rubicorp:
m += Xor([
    cornick == april,
    cornick == rubicorp
])

```
[['beritron', 'february', 'vexatech'], ['cornick', 'april', 'spacezen'], ['exatris', 'january', 'rubicorp'], ['worul', 'march', 'techtrin']]
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The student who will major in Physics was awarded $5000 less than the student who will major in Biology.
Wilma will major in Mathematics.
Delores was awarded $5000 more than Anna.
Anna was awarded some amount less than the person who will major in Mathematics.
Wilma is either the person who received the 35000 dollars scholarship or the person who received the 25000 dollars scholarship.

Entities:
names: Anna, Delores, Wilma, Yvonne
scholarships: $25000, $30000, $35000, $40000
majors: Biology, Mathematics, Physics, Theology
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Anna == 1, and Scholarship25000 == 1, and Biology == 1, then Anna received a $25000 scholarship for majoring in Biology.

### Decision variables:
-   Names of the students: Anna, Delores, Wilma, Yvonne (all different, 1 to 4)
-   Scholarship amounts: Scholarship25000, Scholarship30000, Scholarship35000, Scholarship40000 (all different, 1 to 4)
-   Majors: Biology, Mathematics, Physics, Theology (all different, 1 to 4)

### Constraints:
-   The student majoring in Physics was awarded $5000 less than the student majoring in Biology:
    For this, we will need to add a constraint for each possible assignment of majors to the students majoring in Physics and Biology, such that the Physics student's scholarship amount is $5000 less than the Biology student's scholarship amount. So, the constraints will be of the form:
    m1 == Physics and m2 == Biology => s2_to_int == s1_to_int + 5000, for all m1, m2 in majors and s1, s2 in scholarships.

-   Wilma will major in Mathematics:
    This is a constraint that directly assigns Wilma to major in Mathematics:
    Wilma == Mathematics.

-   Delores was awarded $5000 more than Anna:
    For this, we will need to add a constraint for each possible assignment of scholarships to Delores and Anna, such that Delores's scholarship amount is $5000 more than Anna's scholarship amount. So, the constraints will be of the form:
    s1 == Delores and s2 == Anna => s1_to_int == s2_to_int + 5000, for all s1, s2 in scholarships.

-   Anna was awarded some amount less than the person majoring in Mathematics:
    For this, we will need to add a constraint for each possible assignment of scholarships to Anna and the student majoring in Mathematics, such that Anna's scholarship amount is less than the Mathematics student's scholarship amount. So, the constraints will be of the form:
    s1 == Anna and s2 == Mathematics => s1_to_int < s2_to_int, for all s1, s2 in scholarships.

-   Wilma is either the person who received the $35000 scholarship or the person who received the $25000 scholarship:
    This is a constraint that states that Wilma received either the $35000 scholarship or the $25000 scholarship, but not both. So:
    Xor([Wilma == Scholarship35000, Wilma == Scholarship25000]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Anna == 1, and Scholarship25000 == 1, and Biology == 1, then Anna received a $25000 scholarship for majoring in Biology.

### Decision variables:
-   Names of the students: Anna, Delores, Wilma, Yvonne (all different, 1 to 4)
-   Scholarship amounts: Scholarship25000, Scholarship30000, Scholarship35000, Scholarship40000 (all different, 1 to 4)
-   Majors: Biology, Mathematics, Physics, Theology (all different, 1 to 4)

### Constraints:
-   The student majoring in Physics was awarded $5000 less than the student majoring in Biology:
    For this, we will need to add a constraint for each possible assignment of majors to the students majoring in Physics and Biology, such that the Physics student's scholarship amount is $5000 less than the Biology student's scholarship amount. So, the constraints will be of the form:
    m1 == Physics and m2 == Biology => s2_to_int == s1_to_int + 5000, for all m1, m2 in majors and s1, s2 in scholarships.

-   Wilma will major in Mathematics:
    This is a constraint that directly assigns Wilma to major in Mathematics:
    Wilma == Mathematics.

-   Delores was awarded $5000 more than Anna:
    For this, we will need to add a constraint for each possible assignment of scholarships to Delores and Anna, such that Delores's scholarship amount is $5000 more than Anna's scholarship amount. So, the constraints will be of the form:
    s1 == Delores and s2 == Anna => s1_to_int == s2_to_int + 5000, for all s1, s2 in scholarships.

-   Anna was awarded some amount less than the person majoring in Mathematics:
    For this, we will need to add a constraint for each possible assignment of scholarships to Anna and the student majoring in Mathematics, such that Anna's scholarship amount is less than the Mathematics student's scholarship amount. So, the constraints will be of the form:
    s1 == Anna and s2 == Mathematics => s1_to_int < s2_to_int, for all s1, s2 in scholarships.

-   Wilma is either the person who received the $35000 scholarship or the person who received the $25000 scholarship:
    This is a constraint that states that Wilma received either the $35000 scholarship or the $25000 scholarship, but not both. So:
    Xor([Wilma == Scholarship35000, Wilma == Scholarship25000]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of student, scholarship, and major)
# e.g. if anna == 1 and scholarship25000 == 1 and biology == 1, then Anna received a $25000 scholarship for majoring in Biology
anna, delores, wilma, yvonne = students = intvar(1, 4, shape=4)
scholarship25000, scholarship30000, scholarship35000, scholarship40000 = scholarships = intvar(1, 4, shape=4)
biology, mathematics, physics, theology = majors = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
student_to_int = None  # N/A
scholarship_to_int = {scholarship25000: 25000, scholarship30000: 30000, scholarship35000: 35000, scholarship40000: 40000}  # in dollars
major_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def awarded_less_than(var1, var2, diff):
    """
    Formulate the constraint that var1 was awarded diff dollars less than var2.
    """
    return [((s1 == var1) & (s2 == var2)).implies(s2_to_int == s1_to_int + diff)
            for s1 in scholarships for s2 in scholarships]


def awarded_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 was awarded diff dollars more than var2.
    """
    return [((s1 == var1) & (s2 == var2)).implies(s1_to_int == s2_to_int + diff)
            for s1 in scholarships for s2 in scholarships]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(students)
m += AllDifferent(scholarships)
m += AllDifferent(majors)

# Clue 1: The student majoring in Physics was awarded $5000 less than the student majoring in Biology:
m += awarded_less_than(physics, biology, 5000)

# Clue 2: Wilma will major in Mathematics:
m += wilma == mathematics

# Clue 3: Delores was awarded $5000 more than Anna:
m += awarded_more_than(delores, anna, 5000)

# Clue 4: Anna was awarded some amount less than the person majoring in Mathematics:
m += awarded_less_than(anna, mathematics, 0)

# Clue 5: Wilma is either the person who received the $35000 scholarship or the person who received the $25000 scholarship:
m += Xor([
    wilma == scholarship35000,
    wilma == scholarship25000
])

```
None
Error when trying to check solution from predicted model: invalid syntax (<string>, line 1)
False
False
Error in constraint evaluation: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
The four butterflies were the swallowtail butterfly, Rena's purchase, the insect that sold for $90, and Phillip's purchase.
Otis's purchase was either the peacock butterfly or the swallowtail butterfly.
Brandon's purchase cost 30 dollars less than Otis's purchase.
Rena's purchase cost 15 dollars less than the swallowtail butterfly.
The insect that sold for $75 was the torturix butterfly.

Entities:
winners: Brandon, Otis, Phillip, Rena
prices: $45, $60, $75, $90
butterflies: peacock, peppered, swallowtail, torturix
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Brandon == 1, and Price45 == 1, and Peacock == 1, then Brandon purchased the peacock butterfly for $45.

### Decision variables:
-   Names of the winners: Brandon, Otis, Phillip, Rena (all different, 1 to 4)
-   Prices of the purchases: Price45, Price60, Price75, Price90 (all different, 1 to 4)
-   Types of butterflies: Peacock, Peppered, Swallowtail, Torturix (all different, 1 to 4)

### Constraints:
-   The four butterflies were the swallowtail butterfly, Rena's purchase, the insect that sold for $90, and Phillip's purchase:
    This constraint implies that each butterfly and purchase price is unique. So, we need to ensure that each butterfly and purchase price is assigned to a different winner. This can be represented as:
    AllDifferent([Swallowtail, Rena, Price90, Phillip]).

-   Otis's purchase was either the peacock butterfly or the swallowtail butterfly:
    This constraint states that Otis's purchase was either the peacock butterfly or the swallowtail butterfly. So, we need to add a constraint to represent this:
    Or([Otis == Peacock, Otis == Swallowtail]).

-   Brandon's purchase cost 30 dollars less than Otis's purchase:
    This constraint implies that the price of Brandon's purchase is $30 less than the price of Otis's purchase. So, we need to add a constraint to represent this:
    p1 == Brandon and p2 == Otis => p1_to_int == p2_to_int - 30, for all p1, p2 in prices.

-   Rena's purchase cost 15 dollars less than the swallowtail butterfly:
    This constraint states that Rena's purchase cost is $15 less than the swallowtail butterfly. So, we need to add a constraint to represent this:
    p1 == Rena and p2 == Swallowtail => p1_to_int == p2_to_int - 15, for all p1, p2 in prices.

-   The insect that sold for $75 was the torturix butterfly:
    This constraint states that the butterfly that sold for $75 was the torturix butterfly. So, we need to add a constraint to represent this:
    Price75 == Torturix.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Brandon == 1, and Price45 == 1, and Peacock == 1, then Brandon purchased the peacock butterfly for $45.

### Decision variables:
-   Names of the winners: Brandon, Otis, Phillip, Rena (all different, 1 to 4)
-   Prices of the purchases: Price45, Price60, Price75, Price90 (all different, 1 to 4)
-   Types of butterflies: Peacock, Peppered, Swallowtail, Torturix (all different, 1 to 4)

### Constraints:
-   The four butterflies were the swallowtail butterfly, Rena's purchase, the insect that sold for $90, and Phillip's purchase:
    This constraint implies that each butterfly and purchase price is unique. So, we need to ensure that each butterfly and purchase price is assigned to a different winner. This can be represented as:
    AllDifferent([Swallowtail, Rena, Price90, Phillip]).

-   Otis's purchase was either the peacock butterfly or the swallowtail butterfly:
    This constraint states that Otis's purchase was either the peacock butterfly or the swallowtail butterfly. So, we need to add a constraint to represent this:
    Or([Otis == Peacock, Otis == Swallowtail]).

-   Brandon's purchase cost 30 dollars less than Otis's purchase:
    This constraint implies that the price of Brandon's purchase is $30 less than the price of Otis's purchase. So, we need to add a constraint to represent this:
    p1 == Brandon and p2 == Otis => p1_to_int == p2_to_int - 30, for all p1, p2 in prices.

-   Rena's purchase cost 15 dollars less than the swallowtail butterfly:
    This constraint states that Rena's purchase cost is $15 less than the swallowtail butterfly. So, we need to add a constraint to represent this:
    p1 == Rena and p2 == Swallowtail => p1_to_int == p2_to_int - 15, for all p1, p2 in prices.

-   The insect that sold for $75 was the torturix butterfly:
    This constraint states that the butterfly that sold for $75 was the torturix butterfly. So, we need to add a constraint to represent this:
    Price75 == Torturix.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of winner, price, and butterfly)
# e.g. if brandon == 1 and price45 == 1 and peacock == 1, then Brandon purchased the peacock butterfly for $45
brandon, otis, phillip, rena = winners = intvar(1, 4, shape=4)
price45, price60, price75, price90 = prices = intvar(1, 4, shape=4)
peacock, peppered, swallowtail, torturix = butterflies = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
winner_to_int = None  # N/A
price_to_int = {price45: 45, price60: 60, price75: 75, price90: 90}  # in dollars
butterfly_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def cost_less_than(var1, var2, diff):
    """
    Formulate the constraint that var1's cost is $diff less than var2's cost.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] - diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(winners)
m += AllDifferent(prices)
m += AllDifferent(butterflies)

# Clue 1: The four butterflies were the swallowtail butterfly, Rena's purchase, the insect that sold for $90, and Phillip's purchase
m += AllDifferent([swallowtail, rena, price90, phillip])

# Clue 2: Otis's purchase was either the peacock butterfly or the swallowtail butterfly
m += Or([
    otis == peacock,
    otis == swallowtail
])

# Clue 3: Brandon's purchase cost 30 dollars less than Otis's purchase
m += cost_less_than(brandon, otis, 30)

# Clue 4: Rena's purchase cost 15 dollars less than the swallowtail butterfly
m += cost_less_than(rena, swallowtail, 15)

# Clue 5: The insect that sold for $75 was the torturix butterfly
m += price75 == torturix

```
None
Error when trying to check solution from predicted model: invalid syntax (<string>, line 1)
False
False
Error in constraint evaluation: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
The ambassador with the 9 day visit will leave sometime after Fitzgerald.
Quinn will leave 2 months after Bender.
The person leaving in January is either the ambassador with the 3 day visit or Fitzgerald.
Quinn will leave 1 month before the ambassador with the 7 day visit.

Entities:
diplomats: Bender, Fitzgerald, Owens, Quinn
months: January, February, March, April
durations: 2 day, 3 day, 7 day, 9 day
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Bender == 1, and January == 1, and Day2 == 1, then Bender is the ambassador leaving in January with a 2-day visit.

### Decision variables:
-   Names of the diplomats: Bender, Fitzgerald, Owens, Quinn (all different, 1 to 4)
-   Months of departure: January, February, March, April (all different, 1 to 4)
-   Visit durations: Day2, Day3, Day7, Day9 (all different, 1 to 4)

### Constraints:
-   The ambassador with the 9-day visit will leave sometime after Fitzgerald:
    For this, we will need to add a constraint for each possible assignment of the months of departure for the ambassador with the 9-day visit and Fitzgerald, such that the ambassador with the 9-day visit's month of departure is greater than Fitzgerald's month of departure. So, the constraints will be of the form:
    m1 == Day9 and m2 == Fitzgerald => m1_to_int > m2_to_int, for all m1, m2 in months of departure.

-   Quinn will leave 2 months after Bender:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Quinn and Bender, such that Quinn's month of departure is 2 more than Bender's month of departure. So, the constraints will be of the form:
    m1 == Quinn and m2 == Bender => m1_to_int == m2_to_int + 2, for all m1, m2 in months of departure.

-   The person leaving in January is either the ambassador with the 3-day visit or Fitzgerald:
    This is a constraint that states that the person leaving in January is either the ambassador with the 3-day visit or Fitzgerald, but not both. So:
    Xor([January == Day3, January == Fitzgerald]).

-   Quinn will leave 1 month before the ambassador with the 7-day visit:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Quinn and the ambassador with the 7-day visit, such that Quinn's month of departure is 1 less than the 7-day ambassador's month of departure. So, the constraints will be of the form:
    m1 == Quinn and m2 == Day7 => m1_to_int == m2_to_int - 1, for all m1, m2 in months of departure.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Bender == 1, and January == 1, and Day2 == 1, then Bender is the ambassador leaving in January with a 2-day visit.

### Decision variables:
-   Names of the diplomats: Bender, Fitzgerald, Owens, Quinn (all different, 1 to 4)
-   Months of departure: January, February, March, April (all different, 1 to 4)
-   Visit durations: Day2, Day3, Day7, Day9 (all different, 1 to 4)

### Constraints:
-   The ambassador with the 9-day visit will leave sometime after Fitzgerald:
    For this, we will need to add a constraint for each possible assignment of the months of departure for the ambassador with the 9-day visit and Fitzgerald, such that the ambassador with the 9-day visit's month of departure is greater than Fitzgerald's month of departure. So, the constraints will be of the form:
    m1 == Day9 and m2 == Fitzgerald => m1_to_int > m2_to_int, for all m1, m2 in months of departure.

-   Quinn will leave 2 months after Bender:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Quinn and Bender, such that Quinn's month of departure is 2 more than Bender's month of departure. So, the constraints will be of the form:
    m1 == Quinn and m2 == Bender => m1_to_int == m2_to_int + 2, for all m1, m2 in months of departure.

-   The person leaving in January is either the ambassador with the 3-day visit or Fitzgerald:
    This is a constraint that states that the person leaving in January is either the ambassador with the 3-day visit or Fitzgerald, but not both. So:
    Xor([January == Day3, January == Fitzgerald]).

-   Quinn will leave 1 month before the ambassador with the 7-day visit:
    For this, we will need to add a constraint for each possible assignment of the months of departure for Quinn and the ambassador with the 7-day visit, such that Quinn's month of departure is 1 less than the 7-day ambassador's month of departure. So, the constraints will be of the form:
    m1 == Quinn and m2 == Day7 => m1_to_int == m2_to_int - 1, for all m1, m2 in months of departure.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of diplomat, month, and duration)
# e.g. if bender == 1 and january == 1 and days2 == 1, then Bender will leave in January and for 2 days
bender, fitzgerald, owens, quinn = diplomats = intvar(1, 4, shape=4)
january, february, march, april = months = intvar(1, 4, shape=4)
days2, days3, days7, days9 = durations = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
diplomat_to_int = None  # N/A
month_to_int = {january: 1, february: 2, march: 3, april: 4}  # in months
duration_to_int = {days2: 2, days3: 3, days7: 7, days9: 9}  # in days


# Helper functions (for formulating comparison constraints)
def left_after_than(var1, var2):
    """
    Formulate the constraint that var1 left after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] > month_to_int[m2])
            for m1 in months for m2 in months]


def left_exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 left exactly diff months after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] == month_to_int[m2] + diff)
            for m1 in months for m2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(diplomats)
m += AllDifferent(months)
m += AllDifferent(durations)

# Clue 1: The ambassador with the 9-day visit will leave sometime after Fitzgerald:
m += left_after_than(days9, fitzgerald)

# Clue 2: Quinn will leave 2 months after Bender:
m += left_exactly_after_than(quinn, bender, 2)

# Clue 3: The person leaving in January is either the ambassador with the 3-day visit or Fitzgerald:
m += Xor([
    january == days3,
    january == fitzgerald
])

# Clue 4: Quinn will leave 1 month before the ambassador with the 7-day visit:
m += left_exactly_after_than(quinn, days7, -1)

```
[['bender', 'january', 'days3'], ['fitzgerald', 'february', 'days2'], ['owens', 'april', 'days7'], ['quinn', 'march', 'days9']]
True
True
True
Wrong: 0, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The person who came in at 8:00am asked for wheat bread.
Tricia came in a half-hour after Ora.
Of Felicia and the customer who ordered flatbread, one came in at 7:30am and the other came in at 7:00am.
Of the customer who ordered wheat bread; and the person who ordered pumpernickel, one came in at 8:30am and the other was Tricia.

Entities:
breads: flatbread, pumpernickel, rye bread, wheat bread
times: 7:00am, 7:30am, 8:00am, 8:30am
customers: Felicia, Isabel, Ora, Tricia
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Felicia == 1, and WheatBread == 1, and Time800 == 1, then Felicia came in at 8:00 am and ordered wheat bread.

### Decision variables:
-   Names of the customers: Felicia, Isabel, Ora, Tricia (all different, 1 to 4)
-   Types of bread ordered: Flatbread, Pumpernickel, RyeBread, WheatBread (all different, 1 to 4)
-   Times of arrival: Time700, Time730, Time800, Time830 (all different, 1 to 4)

### Constraints:
-   The person who came in at 8:00 am asked for wheat bread:
    This constraint directly assigns the person who came in at 8:00 am to the one who ordered wheat bread:
    Time800 == WheatBread.

-   Tricia came in a half-hour after Ora:
    This constraint states that the time difference between Tricia and Ora is 0.5 hours:
    abs(Time800 - Tricia) == 1, for Tricia == Ora.

-   Of Felicia and the customer who ordered flatbread, one came in at 7:30 am and the other came in at 7:00 am:
    This constraint assigns the times of arrival for Felicia and the customer who ordered flatbread:
    (Time700 == Felicia and Time730 == Flatbread) or (Time700 == Flatbread and Time730 == Felicia).

-   Of the customer who ordered wheat bread and the person who ordered pumpernickel, one came in at 8:30 am and the other was Tricia:
    This constraint assigns the times of arrival for the customer who ordered wheat bread and the person who ordered pumpernickel:
    (Time830 == WheatBread and Time800 == Pumpernickel) or (Time830 == Pumpernickel and Time800 == WheatBread) and Tricia == WheatBread.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Felicia == 1, and WheatBread == 1, and Time800 == 1, then Felicia came in at 8:00 am and ordered wheat bread.

### Decision variables:
-   Names of the customers: Felicia, Isabel, Ora, Tricia (all different, 1 to 4)
-   Types of bread ordered: Flatbread, Pumpernickel, RyeBread, WheatBread (all different, 1 to 4)
-   Times of arrival: Time700, Time730, Time800, Time830 (all different, 1 to 4)

### Constraints:
-   The person who came in at 8:00 am asked for wheat bread:
    This constraint directly assigns the person who came in at 8:00 am to the one who ordered wheat bread:
    Time800 == WheatBread.

-   Tricia came in a half-hour after Ora:
    This constraint states that the time difference between Tricia and Ora is 0.5 hours:
    abs(Time800 - Tricia) == 1, for Tricia == Ora.

-   Of Felicia and the customer who ordered flatbread, one came in at 7:30 am and the other came in at 7:00 am:
    This constraint assigns the times of arrival for Felicia and the customer who ordered flatbread:
    (Time700 == Felicia and Time730 == Flatbread) or (Time700 == Flatbread and Time730 == Felicia).

-   Of the customer who ordered wheat bread and the person who ordered pumpernickel, one came in at 8:30 am and the other was Tricia:
    This constraint assigns the times of arrival for the customer who ordered wheat bread and the person who ordered pumpernickel:
    (Time830 == WheatBread and Time800 == Pumpernickel) or (Time830 == Pumpernickel and Time800 == WheatBread) and Tricia == WheatBread.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of customer, bread, and time)
# e.g. if felicia == 1 and wheat_bread == 1 and time800 == 1, then Felicia came in at 8:00 am and ordered wheat bread
felicia, isabel, ora, tricia = customers = intvar(1, 4, shape=4)
flatbread, pumpernickel, ryebread, wheatbread = breads = intvar(1, 4, shape=4)
time700, time730, time800, time830 = times = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
customer_to_int = None  # N/A
bread_to_int = None  # N/A
time_to_int = {time700: 7, time730: 7.5, time800: 8, time830: 8.5}  # in hours


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(customers)
m += AllDifferent(breads)
m += AllDifferent(times)

# Clue 1: The person who came in at 8:00 am asked for wheat bread
m += time800 == wheatbread

# Clue 2: Tricia came in a half-hour after Ora
m += abs(time800 - tricia) == 1

# Clue 3: Of Felicia and the customer who ordered flatbread, one came in at 7:30 am and the other came in at 7:00 am
m += ((time700 == felicia) & (time730 == flatbread)) | ((time700 == flatbread) & (time730 == felicia))

# Clue 4: Of the customer who ordered wheat bread and the person who ordered pumpernickel, one came in at 8:30 am and the other was Tricia
m += ((time830 == wheatbread) & (time800 == pumpernickel)) | ((time830 == pumpernickel) & (time800 == wheatbread))
m += tricia == wheatbread

```
None
False
False
Error in model evaluation: list.remove(x): x not in list
Wrong: 4, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The 75 million year old fossil costs 500 dollars less than the pilodontus.
The senosaurus is 85 million years old.
The 75 million year old fossil costs 500 dollars less than the 78 million year old fossil.
The 75 million year old fossil costs less than the archadon.
The 69 million year old fossil costs 250 dollars more than the 78 million year old fossil.

Entities:
dinosaurs: archadon, mirasaurus, pilodontus, senosaurus
price: $500, $750, $1000, $1250
ages: 69 million, 75 million, 78 million, 85 million
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Archadon == 1, and Price500 == 1, and Age69 == 1, then Archadon is the dinosaur with a 69 million-year-old fossil that costs $500.

### Decision variables:
-   Names of the dinosaurs: Archadon, Mirasaurus, Pilodontus, Senosaurus (all different, 1 to 4)
-   Prices of the fossils: Price500, Price750, Price1000, Price1250 (all different, 1 to 4)
-   Ages of the fossils: Age69, Age75, Age78, Age85 (all different, 1 to 4)

### Constraints:
-   The 75 million year old fossil costs $500 less than the Pilodontus:
    For this, we will need to add a constraint for each possible assignment of the prices of the 75 million year old fossil and the Pilodontus, such that the price of the 75 million year old fossil is $500 less than the Pilodontus. So, the constraints will be of the form:
    p1 == Age75 and p2 == Pilodontus => p1_to_int == p2_to_int - 500, for all p1, p2 in prices.

-   The Senosaurus is 85 million years old:
    This is a simple constraint that states the age of the Senosaurus:
    Senosaurus == Age85.

-   The 75 million year old fossil costs $500 less than the 78 million year old fossil:
    For this, we will need to add a constraint for each possible assignment of the prices of the 75 million year old fossil and the 78 million year old fossil, such that the price of the 75 million year old fossil is $500 less than the 78 million year old fossil. So, the constraints will be of the form:
    p1 == Age75 and p2 == Age78 => p1_to_int == p2_to_int - 500, for all p1, p2 in prices.

-   The 75 million year old fossil costs less than the Archadon:
    For this, we will need to add a constraint for each possible assignment of the prices of the 75 million year old fossil and the Archadon, such that the price of the 75 million year old fossil is less than the Archadon. So, the constraints will be of the form:
    p1 == Age75 and p2 == Archadon => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   The 69 million year old fossil costs $250 more than the 78 million year old fossil:
    For this, we will need to add a constraint for each possible assignment of the prices of the 69 million year old fossil and the 78 million year old fossil, such that the price of the 69 million year old fossil is $250 more than the 78 million year old fossil. So, the constraints will be of the form:
    p1 == Age69 and p2 == Age78 => p1_to_int == p2_to_int + 250, for all p1, p2 in prices.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Archadon == 1, and Price500 == 1, and Age69 == 1, then Archadon is the dinosaur with a 69 million-year-old fossil that costs $500.

### Decision variables:
-   Names of the dinosaurs: Archadon, Mirasaurus, Pilodontus, Senosaurus (all different, 1 to 4)
-   Prices of the fossils: Price500, Price750, Price1000, Price1250 (all different, 1 to 4)
-   Ages of the fossils: Age69, Age75, Age78, Age85 (all different, 1 to 4)

### Constraints:
-   The 75 million year old fossil costs $500 less than the Pilodontus:
    For this, we will need to add a constraint for each possible assignment of the prices of the 75 million year old fossil and the Pilodontus, such that the price of the 75 million year old fossil is $500 less than the Pilodontus. So, the constraints will be of the form:
    p1 == Age75 and p2 == Pilodontus => p1_to_int == p2_to_int - 500, for all p1, p2 in prices.

-   The Senosaurus is 85 million years old:
    This is a simple constraint that states the age of the Senosaurus:
    Senosaurus == Age85.

-   The 75 million year old fossil costs $500 less than the 78 million year old fossil:
    For this, we will need to add a constraint for each possible assignment of the prices of the 75 million year old fossil and the 78 million year old fossil, such that the price of the 75 million year old fossil is $500 less than the 78 million year old fossil. So, the constraints will be of the form:
    p1 == Age75 and p2 == Age78 => p1_to_int == p2_to_int - 500, for all p1, p2 in prices.

-   The 75 million year old fossil costs less than the Archadon:
    For this, we will need to add a constraint for each possible assignment of the prices of the 75 million year old fossil and the Archadon, such that the price of the 75 million year old fossil is less than the Archadon. So, the constraints will be of the form:
    p1 == Age75 and p2 == Archadon => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   The 69 million year old fossil costs $250 more than the 78 million year old fossil:
    For this, we will need to add a constraint for each possible assignment of the prices of the 69 million year old fossil and the 78 million year old fossil, such that the price of the 69 million year old fossil is $250 more than the 78 million year old fossil. So, the constraints will be of the form:
    p1 == Age69 and p2 == Age78 => p1_to_int == p2_to_int + 250, for all p1, p2 in prices.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of dinosaur, price, and age)
# e.g. if archadon == 1 and price500 == 1 and age69 == 1, then Archadon has a 69 million-year-old fossil that costs $500
archadon, mirasaurus, pilodontus, senosaurus = dinosaurs = intvar(1, 4, shape=4)
price500, price750, price1000, price1250 = prices = intvar(1, 4, shape=4)
age69, age75, age78, age85 = ages = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
dinosaur_to_int = None  # N/A
price_to_int = {price500: 500, price750: 750, price1000: 1000, price1250: 1250}  # in dollars
age_to_int = {age69: 69, age75: 75, age78: 78, age85: 85}  # in million years


# Helper functions (for formulating comparison constraints)
def costs_less_than(var1, var2):
    """
    Formulate the constraint that var1 costs less than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] < price_to_int[p2])
            for p1 in prices for p2 in prices]


def costs_exactly_less_than(var1, var2, diff):
    """
    Formulate the constraint that var1 costs exactly $diff less than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] - diff)
            for p1 in prices for p2 in prices]


def costs_more_than(var1, var2):
    """
    Formulate the constraint that var1 costs more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] > price_to_int[p2])
            for p1 in prices for p2 in prices]


def costs_exactly_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 costs exactly $diff more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] + diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(dinosaurs)
m += AllDifferent(prices)
m += AllDifferent(ages)

# Clue 1: The 75 million year old fossil costs $500 less than the Pilodontus:
m += costs_exactly_less_than(age75, pilodontus, 500)

# Clue 2: The Senosaurus is 85 million years old:
m += senosaurus == age85

# Clue 3: The 75 million year old fossil costs $500 less than the 78 million year old fossil:
m += costs_exactly_less_than(age75, age78, 500)

# Clue 4: The 75 million year old fossil costs less than the Archadon:
m += costs_less_than(age75, archadon)

# Clue 5: The 69 million year old fossil costs $250 more than the 78 million year old fossil:
m += costs_exactly_more_than(age69, age78, 250)

```
[['archadon', 'price1250', 'age69'], ['senosaurus', 'price750', 'age85'], ['mirasaurus', 'price500', 'age75'], ['pilodontus', 'price1000', 'age78']]
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Henrietta's task starts 2 hours after Glenn's job.
Glenn's task is the dining room.
Glenn's chore starts 1 hour after the mud room assignment.
Henrietta's task is the living room.
The mud room assignment starts sometime before Willie's assignment.

Entities:
children: Glenn, Henrietta, Olivia, Willie
times: 8:00am, 9:00am, 10:00am, 11:00am
rooms: dining room, laundry room, living room, mud room
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Glenn == 1, and Time8am == 1, and DiningRoom == 1, then Glenn's task is in the dining room starting at 8:00 am.

### Decision variables:
-   Names of the children: Glenn, Henrietta, Olivia, Willie (all different, 1 to 4)
-   Times of tasks: 8:00am, 9:00am, 10:00am, 11:00am (all different, 1 to 4)
-   Rooms for tasks: dining room, laundry room, living room, mud room (all different, 1 to 4)

### Constraints:
-   Henrietta's task starts 2 hours after Glenn's job:
    For this, we will need to add a constraint for each possible assignment of times for Henrietta and Glenn's tasks, such that Henrietta's task time is 2 hours after Glenn's task time. So, the constraints will be of the form:
    t1 == Henrietta and t2 == Glenn => t1_to_int == t2_to_int + 2, for all t1, t2 in task times.

-   Glenn's task is the dining room:
    This is a constraint that states Glenn's task is in the dining room. So:
    Glenn == DiningRoom.

-   Glenn's task starts 1 hour after the mud room assignment:
    For this, we will need to add a constraint for each possible assignment of times for Glenn's task and the mud room assignment, such that Glenn's task time is 1 hour after the mud room assignment time. So, the constraints will be of the form:
    t1 == Glenn and t2 == MudRoom => t1_to_int == t2_to_int + 1, for all t1, t2 in task times.

-   Henrietta's task is the living room:
    This is a constraint that states Henrietta's task is in the living room. So:
    Henrietta == LivingRoom.

-   The mud room assignment starts sometime before Willie's assignment:
    For this, we will need to add a constraint for each possible assignment of times for the mud room assignment and Willie's assignment, such that the mud room assignment time is before Willie's assignment time. So, the constraints will be of the form:
    t1 == MudRoom and t2 == Willie => t1_to_int < t2_to_int, for all t1, t2 in task times.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Glenn == 1, and Time8am == 1, and DiningRoom == 1, then Glenn's task is in the dining room starting at 8:00 am.

### Decision variables:
-   Names of the children: Glenn, Henrietta, Olivia, Willie (all different, 1 to 4)
-   Times of tasks: 8:00am, 9:00am, 10:00am, 11:00am (all different, 1 to 4)
-   Rooms for tasks: dining room, laundry room, living room, mud room (all different, 1 to 4)

### Constraints:
-   Henrietta's task starts 2 hours after Glenn's job:
    For this, we will need to add a constraint for each possible assignment of times for Henrietta and Glenn's tasks, such that Henrietta's task time is 2 hours after Glenn's task time. So, the constraints will be of the form:
    t1 == Henrietta and t2 == Glenn => t1_to_int == t2_to_int + 2, for all t1, t2 in task times.

-   Glenn's task is the dining room:
    This is a constraint that states Glenn's task is in the dining room. So:
    Glenn == DiningRoom.

-   Glenn's task starts 1 hour after the mud room assignment:
    For this, we will need to add a constraint for each possible assignment of times for Glenn's task and the mud room assignment, such that Glenn's task time is 1 hour after the mud room assignment time. So, the constraints will be of the form:
    t1 == Glenn and t2 == MudRoom => t1_to_int == t2_to_int + 1, for all t1, t2 in task times.

-   Henrietta's task is the living room:
    This is a constraint that states Henrietta's task is in the living room. So:
    Henrietta == LivingRoom.

-   The mud room assignment starts sometime before Willie's assignment:
    For this, we will need to add a constraint for each possible assignment of times for the mud room assignment and Willie's assignment, such that the mud room assignment time is before Willie's assignment time. So, the constraints will be of the form:
    t1 == MudRoom and t2 == Willie => t1_to_int < t2_to_int, for all t1, t2 in task times.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of child, time, and room)
# e.g. if glenn == 1 and time8am == 1 and dining_room == 1, then Glenn's task is in the dining room starting at 8:00 am
glenn, henrietta, olivia, willie = children = intvar(1, 4, shape=4)
time8am, time9am, time10am, time11am = times = intvar(1, 4, shape=4)
dining_room, laundry_room, living_room, mud_room = rooms = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
child_to_int = None  # N/A
time_to_int = {time8am: 8, time9am: 9, time10am: 10, time11am: 11}  # in hours
room_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def starts_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 starts diff hours after var2.
    """
    return [((t1 == var1) & (t2 == var2)).implies(time_to_int[t1] == time_to_int[t2] + diff)
            for t1 in times for t2 in times]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(children)
m += AllDifferent(times)
m += AllDifferent(rooms)

# Clue 1: Henrietta's task starts 2 hours after Glenn's job:
m += starts_after_than(henrietta, glenn, 2)

# Clue 2: Glenn's task is the dining room:
m += glenn == dining_room

# Clue 3: Glenn's task starts 1 hour after the mud room assignment:
m += starts_after_than(glenn, mud_room, 1)

# Clue 4: Henrietta's task is the living room:
m += henrietta == living_room

# Clue 5: The mud room assignment starts sometime before Willie's assignment:
m += [((t1 == mud_room) & (t2 == willie)).implies(time_to_int[t1] < time_to_int[t2])
      for t1 in times for t2 in times]

```
[['olivia', 'time8am', 'mud_room'], ['henrietta', 'time11am', 'living_room'], ['glenn', 'time9am', 'dining_room'], ['willie', 'time10am', 'laundry_room']]
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Mr. Ayers will dive on July 14.
Mr. Drake will dive 1 day after the diver going out with Hilda.
The customer going out on July 14 will go out with Hilda.
The customer going out with Vicki is either Mr. Gallegos or the customer going out on July 14.
The customer going out with Nadine will dive 1 day before Mr. Ayers.

Entities:
customers: Mr. Ayers, Mr. Drake, Mr. Erickson, Mr. Gallegos
dates: July 13, July 14, July 15, July 16
guides: Hilda, Jorge, Nadine, Vicki
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Mr. Ayers == 1, and July14 == 1, and Hilda == 1, then Mr. Ayers will dive on July 14 with Hilda.

### Decision variables:
-   Names of the customers: Mr. Ayers, Mr. Drake, Mr. Erickson, Mr. Gallegos (all different, 1 to 4)
-   Dates of diving: July 13, July 14, July 15, July 16 (all different, 1 to 4)
-   Guides: Hilda, Jorge, Nadine, Vicki (all different, 1 to 4)

### Constraints:
-   Mr. Ayers will dive on July 14:
    This constraint directly assigns Mr. Ayers to dive on July 14:
    Mr. Ayers == July14.

-   Mr. Drake will dive 1 day after the diver going out with Hilda:
    For this, we will need to add a constraint for each possible assignment of dates of diving for Mr. Drake and Hilda, such that Mr. Drake's date of diving is 1 more than Hilda's date of diving. So, the constraints will be of the form:
    d1 == Mr. Drake and d2 == Hilda => d1_to_int == d2_to_int + 1, for all d1, d2 in dates of diving.

-   The customer going out on July 14 will go out with Hilda:
    This constraint directly assigns the customer going out on July 14 to go out with Hilda:
    July14 == Hilda.

-   The customer going out with Vicki is either Mr. Gallegos or the customer going out on July 14:
    This is a constraint that states that the customer going out with Vicki is either Mr. Gallegos or the customer going out on July 14, but not both. So:
    Xor([Vicki == Mr. Gallegos, Vicki == July14]).

-   The customer going out with Nadine will dive 1 day before Mr. Ayers:
    For this, we will need to add a constraint for each possible assignment of dates of diving for the customer going out with Nadine and Mr. Ayers, such that the customer going out with Nadine's date of diving is 1 less than Mr. Ayers's date of diving. So, the constraints will be of the form:
    d1 == Nadine and d2 == Mr. Ayers => d1_to_int == d2_to_int - 1, for all d1, d2 in dates of diving.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Mr. Ayers == 1, and July14 == 1, and Hilda == 1, then Mr. Ayers will dive on July 14 with Hilda.

### Decision variables:
-   Names of the customers: Mr. Ayers, Mr. Drake, Mr. Erickson, Mr. Gallegos (all different, 1 to 4)
-   Dates of diving: July 13, July 14, July 15, July 16 (all different, 1 to 4)
-   Guides: Hilda, Jorge, Nadine, Vicki (all different, 1 to 4)

### Constraints:
-   Mr. Ayers will dive on July 14:
    This constraint directly assigns Mr. Ayers to dive on July 14:
    Mr. Ayers == July14.

-   Mr. Drake will dive 1 day after the diver going out with Hilda:
    For this, we will need to add a constraint for each possible assignment of dates of diving for Mr. Drake and Hilda, such that Mr. Drake's date of diving is 1 more than Hilda's date of diving. So, the constraints will be of the form:
    d1 == Mr. Drake and d2 == Hilda => d1_to_int == d2_to_int + 1, for all d1, d2 in dates of diving.

-   The customer going out on July 14 will go out with Hilda:
    This constraint directly assigns the customer going out on July 14 to go out with Hilda:
    July14 == Hilda.

-   The customer going out with Vicki is either Mr. Gallegos or the customer going out on July 14:
    This is a constraint that states that the customer going out with Vicki is either Mr. Gallegos or the customer going out on July 14, but not both. So:
    Xor([Vicki == Mr. Gallegos, Vicki == July14]).

-   The customer going out with Nadine will dive 1 day before Mr. Ayers:
    For this, we will need to add a constraint for each possible assignment of dates of diving for the customer going out with Nadine and Mr. Ayers, such that the customer going out with Nadine's date of diving is 1 less than Mr. Ayers's date of diving. So, the constraints will be of the form:
    d1 == Nadine and d2 == Mr. Ayers => d1_to_int == d2_to_int - 1, for all d1, d2 in dates of diving.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of customer, date, and guide)
# e.g. if ayers == 1 and july14 == 1 and hilda == 1, then Mr. Ayers will dive on July 14 with Hilda
ayers, drake, erickson, gallegos = customers = intvar(1, 4, shape=4)
july13, july14, july15, july16 = dates = intvar(1, 4, shape=4)
hilda, jorge, nadine, vicki = guides = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
customer_to_int = None  # N/A
date_to_int = {july13: 13, july14: 14, july15: 15, july16: 16}  # in days
guide_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def dive_after_than(var1, var2):
    """
    Formulate the constraint that var1 dives after var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(date_to_int[d1] == date_to_int[d2] + 1)
            for d1 in dates for d2 in dates]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(customers)
m += AllDifferent(dates)
m += AllDifferent(guides)

# Clue 1: Mr. Ayers will dive on July 14
m += ayers == july14

# Clue 2: Mr. Drake will dive 1 day after the diver going out with Hilda
m += dive_after_than(drake, hilda)

# Clue 3: The customer going out on July 14 will go out with Hilda
m += july14 == hilda

# Clue 4: The customer going out with Vicki is either Mr. Gallegos or the customer going out on July 14
m += Xor([
    vicki == gallegos,
    vicki == july14
])

# Clue 5: The customer going out with Nadine will dive 1 day before Mr. Ayers
m += dive_after_than(nadine, ayers)

```
[['gallegos', 'july16', 'vicki'], ['erickson', 'july13', 'jorge'], ['ayers', 'july14', 'hilda'], ['drake', 'july15', 'nadine']]
False
False
False
Wrong: 1, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The Ethel Street project begins 1 month after Cal Craft's project.
The job starting in May will be headed by Ed Erickson.
The Juniper Lane project starts in April.
Al Anderson's project begins 2 months before the Fred Lane project.

Entities:
Streets: Ethel Street, Fred Lane, Juniper Lane, Quince Street
managers: Al Anderson, Cal Craft, Ed Erickson, Hal Hamilton
months: April, May, June, July
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ethel Street == 1, and Al Anderson == 1, and April == 1, then the project on Ethel Street is managed by Al Anderson and starts in April.

### Decision variables:
-   Streets: Ethel Street, Fred Lane, Juniper Lane, Quince Street (all different, 1 to 4)
-   Managers: Al Anderson, Cal Craft, Ed Erickson, Hal Hamilton (all different, 1 to 4)
-   Months: April, May, June, July (all different, 1 to 4)

### Constraints:
-   The Ethel Street project begins 1 month after Cal Craft's project:
    For this, we will need to add a constraint for each possible assignment of the months for Ethel Street and Cal Craft's project, such that Ethel Street's month is 1 more than Cal Craft's month. So, the constraints will be of the form:
    m1 == Ethel Street and m2 == Cal Craft => m1_to_int == m2_to_int + 1, for all m1, m2 in months.

-   The job starting in May will be headed by Ed Erickson:
    This is a constraint that states that the project starting in May is managed by Ed Erickson. So:
    May == Ed Erickson.

-   The Juniper Lane project starts in April:
    This is a constraint that states that the project on Juniper Lane starts in April. So:
    Juniper Lane == April.

-   Al Anderson's project begins 2 months before the Fred Lane project:
    For this, we will need to add a constraint for each possible assignment of the months for Al Anderson's project and Fred Lane's project, such that Al Anderson's month is 2 less than Fred Lane's month. So, the constraints will be of the form:
    m1 == Al Anderson and m2 == Fred Lane => m1_to_int == m2_to_int - 2, for all m1, m2 in months.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ethel Street == 1, and Al Anderson == 1, and April == 1, then the project on Ethel Street is managed by Al Anderson and starts in April.

### Decision variables:
-   Streets: Ethel Street, Fred Lane, Juniper Lane, Quince Street (all different, 1 to 4)
-   Managers: Al Anderson, Cal Craft, Ed Erickson, Hal Hamilton (all different, 1 to 4)
-   Months: April, May, June, July (all different, 1 to 4)

### Constraints:
-   The Ethel Street project begins 1 month after Cal Craft's project:
    For this, we will need to add a constraint for each possible assignment of the months for Ethel Street and Cal Craft's project, such that Ethel Street's month is 1 more than Cal Craft's month. So, the constraints will be of the form:
    m1 == Ethel Street and m2 == Cal Craft => m1_to_int == m2_to_int + 1, for all m1, m2 in months.

-   The job starting in May will be headed by Ed Erickson:
    This is a constraint that states that the project starting in May is managed by Ed Erickson. So:
    May == Ed Erickson.

-   The Juniper Lane project starts in April:
    This is a constraint that states that the project on Juniper Lane starts in April. So:
    Juniper Lane == April.

-   Al Anderson's project begins 2 months before the Fred Lane project:
    For this, we will need to add a constraint for each possible assignment of the months for Al Anderson's project and Fred Lane's project, such that Al Anderson's month is 2 less than Fred Lane's month. So, the constraints will be of the form:
    m1 == Al Anderson and m2 == Fred Lane => m1_to_int == m2_to_int - 2, for all m1, m2 in months.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of street, manager, and month)
# e.g. if ethel_street == 1 and al_anderson == 1 and april == 1, then the project on Ethel Street is managed by Al Anderson and starts in April
ethel_street, fred_lane, juniper_lane, quince_street = streets = intvar(1, 4, shape=4)
al_anderson, cal_craft, ed_erickson, hal_hamilton = managers = intvar(1, 4, shape=4)
april, may, june, july = months = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
street_to_int = None  # N/A
manager_to_int = None  # N/A
month_to_int = {april: 1, may: 2, june: 3, july: 4}  # in months


# Helper functions (for formulating comparison constraints)
def starts_after_than(var1, var2):
    """
    Formulate the constraint that var1 starts after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] == month_to_int[m2] + 1)
            for m1 in months for m2 in months]


def starts_exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 starts exactly diff months after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] == month_to_int[m2] + diff)
            for m1 in months for m2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(streets)
m += AllDifferent(managers)
m += AllDifferent(months)

# Clue 1: The Ethel Street project begins 1 month after Cal Craft's project:
m += starts_after_than(ethel_street, cal_craft)

# Clue 2: The job starting in May will be headed by Ed Erickson:
m += may == ed_erickson

# Clue 3: The Juniper Lane project starts in April:
m += juniper_lane == april

# Clue 4: Al Anderson's project begins 2 months before the Fred Lane project:
m += starts_exactly_after_than(al_anderson, fred_lane, -2)

```
[['ethel_street', 'hal_hamilton', 'july'], ['fred_lane', 'cal_craft', 'june'], ['juniper_lane', 'al_anderson', 'april'], ['quince_street', 'ed_erickson', 'may']]
True
True
True
Wrong: 0, Total: 7
---------------------------------------------------------------------------------------------

Clues:
Ingram had 7 goals this season.
The four players are Underwood, the player from the Ice Hogs, the player from the Monsters and the player from the Checkers.
Parrish scored 1 goal more than Quinn.
The player with 9 goals is from the Ice Hogs.
Ingram is either the player from the Checkers or the player with 6 goals.

Entities:
players: Ingram, Parrish, Quinn, Underwood
goals: 6, 7, 8, 9
teams: Checkers, Comets, Ice Hogs, Monsters
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ingram == 1, and Goals7 == 1, and Checkers == 1, then Ingram from the Checkers scored 7 goals.

### Decision variables:
-   Names of the players: Ingram, Parrish, Quinn, Underwood (all different, 1 to 4)
-   Number of goals scored: Goals6, Goals7, Goals8, Goals9 (all different, 1 to 4)
-   Teams: Checkers, Comets, Ice Hogs, Monsters (all different, 1 to 4)

### Constraints:
-   Ingram had 7 goals this season:
    This constraint directly assigns 7 goals to Ingram:
    Ingram == Goals7.

-   The four players are Underwood, the player from the Ice Hogs, the player from the Monsters, and the player from the Checkers:
    This constraint states that each player corresponds to one of the mentioned teams. So, we will have:
    AllDifferent([Underwood, Ice Hogs, Monsters, Checkers]).

-   Parrish scored 1 goal more than Quinn:
    This constraint states that the number of goals scored by Parrish is 1 more than Quinn:
    p1 == Parrish and p2 == Quinn => p1_to_int == p2_to_int + 1, for all p1, p2 in goals.

-   The player with 9 goals is from the Ice Hogs:
    This constraint directly assigns 9 goals to the player from the Ice Hogs:
    Ice Hogs == Goals9.

-   Ingram is either the player from the Checkers or the player with 6 goals:
    This constraint states that Ingram is either from the Checkers or scored 6 goals, but not both:
    Xor([Ingram == Checkers, Ingram == Goals6]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ingram == 1, and Goals7 == 1, and Checkers == 1, then Ingram from the Checkers scored 7 goals.

### Decision variables:
-   Names of the players: Ingram, Parrish, Quinn, Underwood (all different, 1 to 4)
-   Number of goals scored: Goals6, Goals7, Goals8, Goals9 (all different, 1 to 4)
-   Teams: Checkers, Comets, Ice Hogs, Monsters (all different, 1 to 4)

### Constraints:
-   Ingram had 7 goals this season:
    This constraint directly assigns 7 goals to Ingram:
    Ingram == Goals7.

-   The four players are Underwood, the player from the Ice Hogs, the player from the Monsters, and the player from the Checkers:
    This constraint states that each player corresponds to one of the mentioned teams. So, we will have:
    AllDifferent([Underwood, Ice Hogs, Monsters, Checkers]).

-   Parrish scored 1 goal more than Quinn:
    This constraint states that the number of goals scored by Parrish is 1 more than Quinn:
    p1 == Parrish and p2 == Quinn => p1_to_int == p2_to_int + 1, for all p1, p2 in goals.

-   The player with 9 goals is from the Ice Hogs:
    This constraint directly assigns 9 goals to the player from the Ice Hogs:
    Ice Hogs == Goals9.

-   Ingram is either the player from the Checkers or the player with 6 goals:
    This constraint states that Ingram is either from the Checkers or scored 6 goals, but not both:
    Xor([Ingram == Checkers, Ingram == Goals6]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of player, goals, and team)
# e.g. if ingram == 1 and goals7 == 1 and checkers == 1, then Ingram from the Checkers scored 7 goals
ingram, parrish, quinn, underwood = players = intvar(1, 4, shape=4)
goals6, goals7, goals8, goals9 = goals = intvar(1, 4, shape=4)
checkers, comets, ice_hogs, monsters = teams = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
player_to_int = None  # N/A
goals_to_int = {goals6: 6, goals7: 7, goals8: 8, goals9: 9}  # number of goals
team_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def scored_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 scored exactly diff more goals than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(goals_to_int[p1] == goals_to_int[p2] + diff)
            for p1 in goals for p2 in goals]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(players)
m += AllDifferent(goals)
m += AllDifferent(teams)

# Clue 1: Ingram had 7 goals this season
m += ingram == goals7

# Clue 2: The four players are Underwood, the player from the Ice Hogs, the player from the Monsters, and the player from the Checkers
m += AllDifferent([underwood, ice_hogs, monsters, checkers])

# Clue 3: Parrish scored 1 goal more than Quinn
m += scored_more_than(parrish, quinn, 1)

# Clue 4: The player with 9 goals is from the Ice Hogs
m += ice_hogs == goals9

# Clue 5: Ingram is either the player from the Checkers or the player with 6 goals
m += Xor([
    ingram == checkers,
    ingram == goals6
])

```
[['ingram', 'goals7', 'checkers'], ['quinn', 'goals8', 'monsters'], ['underwood', 'goals6', 'comets'], ['parrish', 'goals9', 'ice_hogs']]
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Natasha's study starts 2 months after the project on the Odyssey.
Of the assignment on the Liberty and the assignment on the Escape, one is Felix's assignment and the other starts in March.
The study on the Liberty starts 2 months after Eunice's project.

Entities:
students: Eunice, Felix, Natasha, Stacy
months: March, April, May, June
ships: Escape, Liberty, Odyssey, Osprey
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Eunice == 1, and March == 1, and Escape == 1, then Eunice's study on the Escape starts in March.

### Decision variables:
-   Names of the students: Eunice, Felix, Natasha, Stacy (all different, 1 to 4)
-   Months of study start: March, April, May, June (all different, 1 to 4)
-   Ships for assignments: Escape, Liberty, Odyssey, Osprey (all different, 1 to 4)

### Constraints:
-   Natasha's study starts 2 months after the project on the Odyssey:
    For this, we will need to add a constraint for each possible assignment of the months of study start for Natasha and the Odyssey project, such that Natasha's month of study start is 2 more than the Odyssey project's month of start. So, the constraints will be of the form:
    m1 == Natasha and m2 == Odyssey => m1_to_int == m2_to_int + 2, for all m1, m2 in months of study start.

-   Of the assignment on the Liberty and the assignment on the Escape, one is Felix's assignment and the other starts in March:
    This is a constraint that states that one of the assignments is Felix's and the other starts in March. So, we will need to add a constraint that ensures this condition:
    (Felix == Liberty and March == Escape) or (Felix == Escape and March == Liberty).

-   The study on the Liberty starts 2 months after Eunice's project:
    For this, we will need to add a constraint for each possible assignment of the months of study start for Liberty and Eunice's project, such that Liberty's month of study start is 2 more than Eunice's project's month of start. So, the constraints will be of the form:
    m1 == Liberty and m2 == Eunice => m1_to_int == m2_to_int + 2, for all m1, m2 in months of study start.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Eunice == 1, and March == 1, and Escape == 1, then Eunice's study on the Escape starts in March.

### Decision variables:
-   Names of the students: Eunice, Felix, Natasha, Stacy (all different, 1 to 4)
-   Months of study start: March, April, May, June (all different, 1 to 4)
-   Ships for assignments: Escape, Liberty, Odyssey, Osprey (all different, 1 to 4)

### Constraints:
-   Natasha's study starts 2 months after the project on the Odyssey:
    For this, we will need to add a constraint for each possible assignment of the months of study start for Natasha and the Odyssey project, such that Natasha's month of study start is 2 more than the Odyssey project's month of start. So, the constraints will be of the form:
    m1 == Natasha and m2 == Odyssey => m1_to_int == m2_to_int + 2, for all m1, m2 in months of study start.

-   Of the assignment on the Liberty and the assignment on the Escape, one is Felix's assignment and the other starts in March:
    This is a constraint that states that one of the assignments is Felix's and the other starts in March. So, we will need to add a constraint that ensures this condition:
    (Felix == Liberty and March == Escape) or (Felix == Escape and March == Liberty).

-   The study on the Liberty starts 2 months after Eunice's project:
    For this, we will need to add a constraint for each possible assignment of the months of study start for Liberty and Eunice's project, such that Liberty's month of study start is 2 more than Eunice's project's month of start. So, the constraints will be of the form:
    m1 == Liberty and m2 == Eunice => m1_to_int == m2_to_int + 2, for all m1, m2 in months of study start.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of student, month, and ship)
# e.g. if eunice == 1 and march == 1 and escape == 1, then Eunice's study on the Escape starts in March
eunice, felix, natasha, stacy = students = intvar(1, 4, shape=4)
march, april, may, june = months = intvar(1, 4, shape=4)
escape, liberty, odyssey, osprey = ships = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
student_to_int = None  # N/A
month_to_int = {march: 1, april: 2, may: 3, june: 4}  # in months
ship_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def starts_after(var1, var2, diff):
    """
    Formulate the constraint that var1 starts diff months after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] == month_to_int[m2] + diff)
            for m1 in months for m2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(students)
m += AllDifferent(months)
m += AllDifferent(ships)

# Clue 1: Natasha's study starts 2 months after the project on the Odyssey:
m += starts_after(natasha, odyssey, 2)

# Clue 2: Of the assignment on the Liberty and the assignment on the Escape, one is Felix's assignment and the other starts in March:
m += ((felix == liberty) & (march == escape)) | ((felix == escape) & (march == liberty))

# Clue 3: The study on the Liberty starts 2 months after Eunice's project:
m += starts_after(liberty, eunice, 2)

```
[['eunice', 'march', 'escape'], ['natasha', 'june', 'osprey'], ['felix', 'may', 'liberty'], ['stacy', 'april', 'odyssey']]
True
True
True
Wrong: 1, Total: 6
---------------------------------------------------------------------------------------------

Clues:
The project headed by Dr. Golden will go online sometime before the Zynga Complex.
The project headed by Dr. Weber will go online 1 year before the Bale-Hahn SSC.
The Egert Facility will go online 1 year after the ISON-X42.
The project headed by Dr. Owens will go online 1 year after the ISON-X42.

Entities:
years: 2016, 2017, 2018, 2019
names: Bale-Hahn SSC, Egert Facility, ISON-X42, Zynga Complex
scientists: Dr. Farley, Dr. Golden, Dr. Owens, Dr. Weber
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Bale-Hahn SSC == 1, and Dr. Farley == 1, and Year2016 == 1, then Bale-Hahn SSC, headed by Dr. Farley, will go online in 2016.

### Decision variables:
-   Names of the projects: Bale-Hahn SSC, Egert Facility, ISON-X42, Zynga Complex (all different, 1 to 4)
-   Scientists heading the projects: Dr. Farley, Dr. Golden, Dr. Owens, Dr. Weber (all different, 1 to 4)
-   Years of going online: 2016, 2017, 2018, 2019 (all different, 1 to 4)

### Constraints:
-   The project headed by Dr. Golden will go online sometime before the Zynga Complex:
    For this, we will need to add a constraint for each possible assignment of the years of going online for Dr. Golden and the Zynga Complex, such that Dr. Golden's year of going online is less than the Zynga Complex's year of going online. So, the constraints will be of the form:
    y1 == Dr. Golden and y2 == Zynga Complex => y1_to_int < y2_to_int, for all y1, y2 in years.

-   The project headed by Dr. Weber will go online 1 year before the Bale-Hahn SSC:
    For this, we will need to add a constraint for each possible assignment of the years of going online for Dr. Weber and the Bale-Hahn SSC, such that Dr. Weber's year of going online is 1 less than the Bale-Hahn SSC's year of going online. So, the constraints will be of the form:
    y1 == Dr. Weber and y2 == Bale-Hahn SSC => y1_to_int == y2_to_int - 1, for all y1, y2 in years.

-   The Egert Facility will go online 1 year after the ISON-X42:
    For this, we will need to add a constraint for each possible assignment of the years of going online for the Egert Facility and the ISON-X42, such that the Egert Facility's year of going online is 1 more than the ISON-X42's year of going online. So, the constraints will be of the form:
    y1 == Egert Facility and y2 == ISON-X42 => y1_to_int == y2_to_int + 1, for all y1, y2 in years.

-   The project headed by Dr. Owens will go online 1 year after the ISON-X42:
    For this, we will need to add a constraint for each possible assignment of the years of going online for Dr. Owens and the ISON-X42, such that Dr. Owens's year of going online is 1 more than the ISON-X42's year of going online. So, the constraints will be of the form:
    y1 == Dr. Owens and y2 == ISON-X42 => y1_to_int == y2_to_int + 1, for all y1, y2 in years.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Bale-Hahn SSC == 1, and Dr. Farley == 1, and Year2016 == 1, then Bale-Hahn SSC, headed by Dr. Farley, will go online in 2016.

### Decision variables:
-   Names of the projects: Bale-Hahn SSC, Egert Facility, ISON-X42, Zynga Complex (all different, 1 to 4)
-   Scientists heading the projects: Dr. Farley, Dr. Golden, Dr. Owens, Dr. Weber (all different, 1 to 4)
-   Years of going online: 2016, 2017, 2018, 2019 (all different, 1 to 4)

### Constraints:
-   The project headed by Dr. Golden will go online sometime before the Zynga Complex:
    For this, we will need to add a constraint for each possible assignment of the years of going online for Dr. Golden and the Zynga Complex, such that Dr. Golden's year of going online is less than the Zynga Complex's year of going online. So, the constraints will be of the form:
    y1 == Dr. Golden and y2 == Zynga Complex => y1_to_int < y2_to_int, for all y1, y2 in years.

-   The project headed by Dr. Weber will go online 1 year before the Bale-Hahn SSC:
    For this, we will need to add a constraint for each possible assignment of the years of going online for Dr. Weber and the Bale-Hahn SSC, such that Dr. Weber's year of going online is 1 less than the Bale-Hahn SSC's year of going online. So, the constraints will be of the form:
    y1 == Dr. Weber and y2 == Bale-Hahn SSC => y1_to_int == y2_to_int - 1, for all y1, y2 in years.

-   The Egert Facility will go online 1 year after the ISON-X42:
    For this, we will need to add a constraint for each possible assignment of the years of going online for the Egert Facility and the ISON-X42, such that the Egert Facility's year of going online is 1 more than the ISON-X42's year of going online. So, the constraints will be of the form:
    y1 == Egert Facility and y2 == ISON-X42 => y1_to_int == y2_to_int + 1, for all y1, y2 in years.

-   The project headed by Dr. Owens will go online 1 year after the ISON-X42:
    For this, we will need to add a constraint for each possible assignment of the years of going online for Dr. Owens and the ISON-X42, such that Dr. Owens's year of going online is 1 more than the ISON-X42's year of going online. So, the constraints will be of the form:
    y1 == Dr. Owens and y2 == ISON-X42 => y1_to_int == y2_to_int + 1, for all y1, y2 in years.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of project, scientist, and year)
# e.g. if bale_hahn == 1 and dr_farley == 1 and year2016 == 1, then Bale-Hahn SSC, headed by Dr. Farley, will go online in 2016
bale_hahn, egert, ison_x42, zynga = projects = intvar(1, 4, shape=4)
dr_farley, dr_golden, dr_owens, dr_weber = scientists = intvar(1, 4, shape=4)
year2016, year2017, year2018, year2019 = years = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
project_to_int = None  # N/A
scientist_to_int = None  # N/A
year_to_int = {year2016: 2016, year2017: 2017, year2018: 2018, year2019: 2019}  # in years


# Helper functions (for formulating comparison constraints)
def online_before(var1, var2):
    """
    Formulate the constraint that var1 goes online before var2.
    """
    return [((y1 == var1) & (y2 == var2)).implies(year_to_int[y1] < year_to_int[y2])
            for y1 in years for y2 in years]


def online_exactly_before(var1, var2, diff):
    """
    Formulate the constraint that var1 goes online exactly diff years before var2.
    """
    return [((y1 == var1) & (y2 == var2)).implies(year_to_int[y1] == year_to_int[y2] - diff)
            for y1 in years for y2 in years]


def online_exactly_after(var1, var2, diff):
    """
    Formulate the constraint that var1 goes online exactly diff years after var2.
    """
    return [((y1 == var1) & (y2 == var2)).implies(year_to_int[y1] == year_to_int[y2] + diff)
            for y1 in years for y2 in years]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(projects)
m += AllDifferent(scientists)
m += AllDifferent(years)

# Clue 1: The project headed by Dr. Golden will go online sometime before the Zynga Complex:
m += online_before(dr_golden, zynga)

# Clue 2: The project headed by Dr. Weber will go online 1 year before the Bale-Hahn SSC:
m += online_exactly_before(dr_weber, bale_hahn, 1)

# Clue 3: The Egert Facility will go online 1 year after the ISON-X42:
m += online_exactly_after(egert, ison_x42, 1)

# Clue 4: The project headed by Dr. Owens will go online 1 year after the ISON-X42:
m += online_exactly_after(dr_owens, ison_x42, 1)

```
[['bale_hahn', 'dr_farley', 'year2019'], ['ison_x42', 'dr_golden', 'year2016'], ['egert', 'dr_owens', 'year2017'], ['zynga', 'dr_weber', 'year2018']]
True
True
True
Wrong: 0, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The model made by Torvia costs 25 dollars more than the model made by Honwa.
The camera made by Honwa is either the Zenix 2C or the MX-827.
Of the $600 model and the FC-520, one is made by Honwa and the other is made by Dayero.
The Zenix 2C costs less than the FC-520.

Entities:
companies: Banion, Dayero, Honwa, Torvia
prices: $550, $575, $600, $625
cameras: DM-5000, FC-520, MX-827, Zenix 2C
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Banion == 1, and Price550 == 1, and DM5000 == 1, then Banion made the DM-5000 model priced at $550.

### Decision variables:
-   Companies: Banion, Dayero, Honwa, Torvia (all different, 1 to 4)
-   Prices of the models: Price550, Price575, Price600, Price625 (all different, 1 to 4)
-   Cameras: DM-5000, FC-520, MX-827, Zenix 2C (all different, 1 to 4)

### Constraints:
-   The model made by Torvia costs 25 dollars more than the model made by Honwa:
    For this, we will need to add a constraint for each possible assignment of prices to Torvia and Honwa's models, such that Torvia's price is 25 dollars more than Honwa's price. So, the constraints will be of the form:
    p1 == Torvia and p2 == Honwa => p1_to_int == p2_to_int + 25, for all p1, p2 in prices.

-   The camera made by Honwa is either the Zenix 2C or the MX-827:
    This is a constraint that states that the camera made by Honwa is either the Zenix 2C or the MX-827, but not both. So:
    Xor([Honwa == Zenix2C, Honwa == MX827]).

-   Of the $600 model and the FC-520, one is made by Honwa and the other is made by Dayero:
    This is a constraint that states that one of the $600 model and the FC-520 is made by Honwa and the other is made by Dayero. So:
    (Price600 == Honwa and FC520 == Dayero) or (Price600 == Dayero and FC520 == Honwa).

-   The Zenix 2C costs less than the FC-520:
    For this, we will need to add a constraint for each possible assignment of prices to the Zenix 2C and the FC-520, such that the Zenix 2C's price is less than the FC-520's price. So, the constraints will be of the form:
    p1 == Zenix2C and p2 == FC520 => p1_to_int < p2_to_int, for all p1, p2 in prices.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Banion == 1, and Price550 == 1, and DM5000 == 1, then Banion made the DM-5000 model priced at $550.

### Decision variables:
-   Companies: Banion, Dayero, Honwa, Torvia (all different, 1 to 4)
-   Prices of the models: Price550, Price575, Price600, Price625 (all different, 1 to 4)
-   Cameras: DM-5000, FC-520, MX-827, Zenix 2C (all different, 1 to 4)

### Constraints:
-   The model made by Torvia costs 25 dollars more than the model made by Honwa:
    For this, we will need to add a constraint for each possible assignment of prices to Torvia and Honwa's models, such that Torvia's price is 25 dollars more than Honwa's price. So, the constraints will be of the form:
    p1 == Torvia and p2 == Honwa => p1_to_int == p2_to_int + 25, for all p1, p2 in prices.

-   The camera made by Honwa is either the Zenix 2C or the MX-827:
    This is a constraint that states that the camera made by Honwa is either the Zenix 2C or the MX-827, but not both. So:
    Xor([Honwa == Zenix2C, Honwa == MX827]).

-   Of the $600 model and the FC-520, one is made by Honwa and the other is made by Dayero:
    This is a constraint that states that one of the $600 model and the FC-520 is made by Honwa and the other is made by Dayero. So:
    (Price600 == Honwa and FC520 == Dayero) or (Price600 == Dayero and FC520 == Honwa).

-   The Zenix 2C costs less than the FC-520:
    For this, we will need to add a constraint for each possible assignment of prices to the Zenix 2C and the FC-520, such that the Zenix 2C's price is less than the FC-520's price. So, the constraints will be of the form:
    p1 == Zenix2C and p2 == FC520 => p1_to_int < p2_to_int, for all p1, p2 in prices.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of company, price, and camera)
# e.g. if banion == 1 and price550 == 1 and dm5000 == 1, then Banion made the DM-5000 model priced at $550
banion, dayero, honwa, torvia = companies = intvar(1, 4, shape=4)
price550, price575, price600, price625 = prices = intvar(1, 4, shape=4)
dm5000, fc520, mx827, zenix2c = cameras = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
company_to_int = None  # N/A
price_to_int = {price550: 550, price575: 575, price600: 600, price625: 625}  # in dollars
camera_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def cost_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 costs diff dollars more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] + diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(companies)
m += AllDifferent(prices)
m += AllDifferent(cameras)

# Clue 1: The model made by Torvia costs 25 dollars more than the model made by Honwa:
m += cost_more_than(torvia, honwa, 25)

# Clue 2: The camera made by Honwa is either the Zenix 2C or the MX-827:
m += Xor([
    honwa == zenix2c,
    honwa == mx827
])

# Clue 3: Of the $600 model and the FC-520, one is made by Honwa and the other is made by Dayero:
m += ((price600 == honwa) & (fc520 == dayero)) | ((price600 == dayero) & (fc520 == honwa))

# Clue 4: The Zenix 2C costs less than the FC-520:
m += [((p1 == zenix2c) & (p2 == fc520)).implies(price_to_int[p1] < price_to_int[p2])
      for p1 in prices for p2 in prices]

```
[['banion', 'price550', 'zenix2c'], ['dayero', 'price575', 'fc520'], ['honwa', 'price600', 'mx827'], ['torvia', 'price625', 'dm5000']]
True
True
True
Wrong: 1, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The football facility holds more people than Underwood Arena.
The basketball facility holds 80 more people than Vazquez Arena.
Young Arena holds 230 people.
Underwood Arena holds 40 fewer people than Vazquez Arena.
The facility with seating for 190 people is either the lacrosse facility or Underwood Arena.

Entities:
arenas: Gentry, Underwood, Vazquez, Young
capacities: 110, 150, 190, 230
sports: basketball, football, lacrosse, soccer
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Gentry == 1, and Capacity110 == 1, and Basketball == 1, then Gentry is the basketball facility with a capacity of 110 people.

### Decision variables:
-   Names of the arenas: Gentry, Underwood, Vazquez, Young (all different, 1 to 4)
-   Capacities of the arenas: Capacity110, Capacity150, Capacity190, Capacity230 (all different, 1 to 4)
-   Sports played in the arenas: Basketball, Football, Lacrosse, Soccer (all different, 1 to 4)

### Constraints:
-   The football facility holds more people than Underwood Arena:
    For this, we will need to add a constraint for each possible assignment of capacities to the football facility and Underwood Arena, such that the football facility's capacity is greater than Underwood Arena's capacity. So, the constraints will be of the form:
    c1 == Football and c2 == Underwood => c1_to_int > c2_to_int, for all c1, c2 in capacities.

-   The basketball facility holds 80 more people than Vazquez Arena:
    For this, we will need to add a constraint for each possible assignment of capacities to the basketball facility and Vazquez Arena, such that the basketball facility's capacity is 80 more than Vazquez Arena's capacity. So, the constraints will be of the form:
    c1 == Basketball and c2 == Vazquez => c1_to_int == c2_to_int + 80, for all c1, c2 in capacities.

-   Young Arena holds 230 people:
    This is a simple constraint where the capacity of Young Arena is fixed to 230:
    Young == Capacity230.

-   Underwood Arena holds 40 fewer people than Vazquez Arena:
    For this, we will need to add a constraint for each possible assignment of capacities to Underwood Arena and Vazquez Arena, such that Underwood Arena's capacity is 40 less than Vazquez Arena's capacity. So, the constraints will be of the form:
    c1 == Underwood and c2 == Vazquez => c1_to_int == c2_to_int - 40, for all c1, c2 in capacities.

-   The facility with seating for 190 people is either the lacrosse facility or Underwood Arena:
    This is a constraint that states that the facility with a capacity of 190 people is either the lacrosse facility or Underwood Arena, but not both. So:
    Xor([Capacity190 == Lacrosse, Capacity190 == Underwood]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Gentry == 1, and Capacity110 == 1, and Basketball == 1, then Gentry is the basketball facility with a capacity of 110 people.

### Decision variables:
-   Names of the arenas: Gentry, Underwood, Vazquez, Young (all different, 1 to 4)
-   Capacities of the arenas: Capacity110, Capacity150, Capacity190, Capacity230 (all different, 1 to 4)
-   Sports played in the arenas: Basketball, Football, Lacrosse, Soccer (all different, 1 to 4)

### Constraints:
-   The football facility holds more people than Underwood Arena:
    For this, we will need to add a constraint for each possible assignment of capacities to the football facility and Underwood Arena, such that the football facility's capacity is greater than Underwood Arena's capacity. So, the constraints will be of the form:
    c1 == Football and c2 == Underwood => c1_to_int > c2_to_int, for all c1, c2 in capacities.

-   The basketball facility holds 80 more people than Vazquez Arena:
    For this, we will need to add a constraint for each possible assignment of capacities to the basketball facility and Vazquez Arena, such that the basketball facility's capacity is 80 more than Vazquez Arena's capacity. So, the constraints will be of the form:
    c1 == Basketball and c2 == Vazquez => c1_to_int == c2_to_int + 80, for all c1, c2 in capacities.

-   Young Arena holds 230 people:
    This is a simple constraint where the capacity of Young Arena is fixed to 230:
    Young == Capacity230.

-   Underwood Arena holds 40 fewer people than Vazquez Arena:
    For this, we will need to add a constraint for each possible assignment of capacities to Underwood Arena and Vazquez Arena, such that Underwood Arena's capacity is 40 less than Vazquez Arena's capacity. So, the constraints will be of the form:
    c1 == Underwood and c2 == Vazquez => c1_to_int == c2_to_int - 40, for all c1, c2 in capacities.

-   The facility with seating for 190 people is either the lacrosse facility or Underwood Arena:
    This is a constraint that states that the facility with a capacity of 190 people is either the lacrosse facility or Underwood Arena, but not both. So:
    Xor([Capacity190 == Lacrosse, Capacity190 == Underwood]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of arena, capacity, and sport)
# e.g. if gentry == 1 and capacity110 == 1 and basketball == 1, then Gentry is the basketball facility with a capacity of 110 people
gentry, underwood, vazquez, young = arenas = intvar(1, 4, shape=4)
capacity110, capacity150, capacity190, capacity230 = capacities = intvar(1, 4, shape=4)
basketball, football, lacrosse, soccer = sports = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
arena_to_int = None  # N/A
capacity_to_int = {capacity110: 110, capacity150: 150, capacity190: 190, capacity230: 230}  # in people
sport_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def holds_more_than(var1, var2):
    """
    Formulate the constraint that var1 holds more people than var2.
    """
    return [((c1 == var1) & (c2 == var2)).implies(capacity_to_int[c1] > capacity_to_int[c2])
            for c1 in capacities for c2 in capacities]


def holds_exactly_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 holds exactly diff more people than var2.
    """
    return [((c1 == var1) & (c2 == var2)).implies(capacity_to_int[c1] == capacity_to_int[c2] + diff)
            for c1 in capacities for c2 in capacities]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(arenas)
m += AllDifferent(capacities)
m += AllDifferent(sports)

# Clue 1: The football facility holds more people than Underwood Arena:
m += holds_more_than(football, underwood)

# Clue 2: The basketball facility holds 80 more people than Vazquez Arena:
m += holds_exactly_more_than(basketball, vazquez, 80)

# Clue 3: Young Arena holds 230 people:
m += young == capacity230

# Clue 4: Underwood Arena holds 40 fewer people than Vazquez Arena:
m += holds_exactly_more_than(underwood, vazquez, -40)

# Clue 5: The facility with seating for 190 people is either the lacrosse facility or Underwood Arena:
m += Xor([
    capacity190 == lacrosse,
    capacity190 == underwood
])

```
[['underwood', 'capacity110', 'soccer'], ['vazquez', 'capacity150', 'football'], ['gentry', 'capacity190', 'lacrosse'], ['young', 'capacity230', 'basketball']]
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Hope paid less than Delia.
Patricia had the cappuccino.
The one who had the cafe americano paid 1 dollar more than Patricia.
Hope paid more than the one who had the cafe americano.
The one who had the chai tea paid 1 dollar more than the one who had the cafe americano.

Entities:
names: Delia, Hope, Patricia, Wayne
prices: $5, $6, $7, $8
drinks: cafe americano, cafe latte, cappuccino, chai tea
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Delia == 1, and Price5 == 1, and Americano == 1, then Delia had the cafe americano for $5.

### Decision variables:
-   Names of the persons: Delia, Hope, Patricia, Wayne (all different, 1 to 4)
-   Prices of the drinks: Price5, Price6, Price7, Price8 (all different, 1 to 4)
-   Types of drinks: Americano, Latte, Cappuccino, Chai (all different, 1 to 4)

### Constraints:
-   Hope paid less than Delia:
    For this, we will need to add a constraint for each possible assignment of prices to Hope and Delia, such that Hope's price is less than Delia's price. So, the constraints will be of the form:
    p1 == Hope and p2 == Delia => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   Patricia had the cappuccino:
    This is a constraint that directly assigns the cappuccino to Patricia:
    Patricia == Cappuccino.

-   The one who had the cafe americano paid 1 dollar more than Patricia:
    For this, we will need to add a constraint for each possible assignment of prices to the person who had the cafe americano and Patricia, such that the cafe americano's price is 1 dollar more than Patricia's price. So, the constraints will be of the form:
    p1 == Americano and p2 == Patricia => p1_to_int == p2_to_int + 1, for all p1, p2 in prices.

-   Hope paid more than the one who had the cafe americano:
    For this, we will need to add a constraint for each possible assignment of prices to Hope and the person who had the cafe americano, such that Hope's price is greater than the cafe americano's price. So, the constraints will be of the form:
    p1 == Hope and p2 == Americano => p1_to_int > p2_to_int, for all p1, p2 in prices.

-   The one who had the chai tea paid 1 dollar more than the one who had the cafe americano:
    For this, we will need to add a constraint for each possible assignment of prices to the person who had the chai tea and the person who had the cafe americano, such that the chai tea's price is 1 dollar more than the cafe americano's price. So, the constraints will be of the form:
    p1 == Chai and p2 == Americano => p1_to_int == p2_to_int + 1, for all p1, p2 in prices.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Delia == 1, and Price5 == 1, and Americano == 1, then Delia had the cafe americano for $5.

### Decision variables:
-   Names of the persons: Delia, Hope, Patricia, Wayne (all different, 1 to 4)
-   Prices of the drinks: Price5, Price6, Price7, Price8 (all different, 1 to 4)
-   Types of drinks: Americano, Latte, Cappuccino, Chai (all different, 1 to 4)

### Constraints:
-   Hope paid less than Delia:
    For this, we will need to add a constraint for each possible assignment of prices to Hope and Delia, such that Hope's price is less than Delia's price. So, the constraints will be of the form:
    p1 == Hope and p2 == Delia => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   Patricia had the cappuccino:
    This is a constraint that directly assigns the cappuccino to Patricia:
    Patricia == Cappuccino.

-   The one who had the cafe americano paid 1 dollar more than Patricia:
    For this, we will need to add a constraint for each possible assignment of prices to the person who had the cafe americano and Patricia, such that the cafe americano's price is 1 dollar more than Patricia's price. So, the constraints will be of the form:
    p1 == Americano and p2 == Patricia => p1_to_int == p2_to_int + 1, for all p1, p2 in prices.

-   Hope paid more than the one who had the cafe americano:
    For this, we will need to add a constraint for each possible assignment of prices to Hope and the person who had the cafe americano, such that Hope's price is greater than the cafe americano's price. So, the constraints will be of the form:
    p1 == Hope and p2 == Americano => p1_to_int > p2_to_int, for all p1, p2 in prices.

-   The one who had the chai tea paid 1 dollar more than the one who had the cafe americano:
    For this, we will need to add a constraint for each possible assignment of prices to the person who had the chai tea and the person who had the cafe americano, such that the chai tea's price is 1 dollar more than the cafe americano's price. So, the constraints will be of the form:
    p1 == Chai and p2 == Americano => p1_to_int == p2_to_int + 1, for all p1, p2 in prices.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of person, price, and drink)
# e.g. if delia == 1 and price5 == 1 and americano == 1, then Delia had the cafe americano for $5
delia, hope, patricia, wayne = persons = intvar(1, 4, shape=4)
price5, price6, price7, price8 = prices = intvar(1, 4, shape=4)
americano, latte, cappuccino, chai = drinks = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
person_to_int = None  # N/A
price_to_int = {price5: 5, price6: 6, price7: 7, price8: 8}  # in dollars
drink_to_int = {americano: 1, latte: 2, cappuccino: 3, chai: 4}  # in order


# Helper functions (for formulating comparison constraints)
def paid_less_than(var1, var2):
    """
    Formulate the constraint that var1 paid less than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] < price_to_int[p2])
            for p1 in prices for p2 in prices]


def paid_exactly_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 paid exactly $diff more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] + diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(persons)
m += AllDifferent(prices)
m += AllDifferent(drinks)

# Clue 1: Hope paid less than Delia:
m += paid_less_than(hope, delia)

# Clue 2: Patricia had the cappuccino:
m += patricia == cappuccino

# Clue 3: The one who had the cafe americano paid 1 dollar more than Patricia:
m += paid_exactly_more_than(americano, patricia, 1)

# Clue 4: Hope paid more than the one who had the cafe americano:
m += paid_less_than(americano, hope)

# Clue 5: The one who had the chai tea paid 1 dollar more than the one who had the cafe americano:
m += paid_exactly_more_than(chai, americano, 1)

```
[['delia', 'price8', 'latte'], ['patricia', 'price5', 'cappuccino'], ['wayne', 'price6', 'americano'], ['hope', 'price7', 'chai']]
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The Leden drove 25 miles farther than the automobile with a high speed of 75 MPH.
The Poltris drove 25 miles farther than the automobile with a high speed of 69 MPH.
The Awick drove somewhat less than the automobile with a high speed of 81 MPH.
The car with a high speed of 69 MPH drove somewhat farther than the automobile with a high speed of 81 MPH.

Entities:
cars: Awick, Leden, Poltris, Versem
distances: 525 miles, 550 miles, 575 miles, 600 miles
speeds: 62 MPH, 69 MPH, 75 MPH, 81 MPH
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Awick == 1, and Distance525 == 1, and Speed62 == 1, then Awick drove 525 miles at 62 MPH.

### Decision variables:
-   Names of the cars: Awick, Leden, Poltris, Versem (all different, 1 to 4)
-   Distances driven: Distance525, Distance550, Distance575, Distance600 (all different, 1 to 4)
-   Speeds of the cars: Speed62, Speed69, Speed75, Speed81 (all different, 1 to 4)

### Constraints:
-   The Leden drove 25 miles farther than the automobile with a high speed of 75 MPH:
    For this, we will need to add a constraint for each possible assignment of distances driven by Leden and the car with a high speed of 75 MPH, such that Leden's distance is 25 miles greater than the 75 MPH car's distance. So, the constraints will be of the form:
    d1 == Leden and d2 == Speed75 => d1_to_int == d2_to_int + 25, for all d1, d2 in distances.

-   The Poltris drove 25 miles farther than the automobile with a high speed of 69 MPH:
    For this, we will need to add a constraint for each possible assignment of distances driven by Poltris and the car with a high speed of 69 MPH, such that Poltris's distance is 25 miles greater than the 69 MPH car's distance. So, the constraints will be of the form:
    d1 == Poltris and d2 == Speed69 => d1_to_int == d2_to_int + 25, for all d1, d2 in distances.

-   The Awick drove somewhat less than the automobile with a high speed of 81 MPH:
    For this, we will need to add a constraint for each possible assignment of distances driven by Awick and the car with a high speed of 81 MPH, such that Awick's distance is less than the 81 MPH car's distance. So, the constraints will be of the form:
    d1 == Awick and d2 == Speed81 => d1_to_int < d2_to_int, for all d1, d2 in distances.

-   The car with a high speed of 69 MPH drove somewhat farther than the automobile with a high speed of 81 MPH:
    For this, we will need to add a constraint for each possible assignment of distances driven by the 69 MPH car and the 81 MPH car, such that the 69 MPH car's distance is greater than the 81 MPH car's distance. So, the constraints will be of the form:
    d1 == Speed69 and d2 == Speed81 => d1_to_int > d2_to_int, for all d1, d2 in distances.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Awick == 1, and Distance525 == 1, and Speed62 == 1, then Awick drove 525 miles at 62 MPH.

### Decision variables:
-   Names of the cars: Awick, Leden, Poltris, Versem (all different, 1 to 4)
-   Distances driven: Distance525, Distance550, Distance575, Distance600 (all different, 1 to 4)
-   Speeds of the cars: Speed62, Speed69, Speed75, Speed81 (all different, 1 to 4)

### Constraints:
-   The Leden drove 25 miles farther than the automobile with a high speed of 75 MPH:
    For this, we will need to add a constraint for each possible assignment of distances driven by Leden and the car with a high speed of 75 MPH, such that Leden's distance is 25 miles greater than the 75 MPH car's distance. So, the constraints will be of the form:
    d1 == Leden and d2 == Speed75 => d1_to_int == d2_to_int + 25, for all d1, d2 in distances.

-   The Poltris drove 25 miles farther than the automobile with a high speed of 69 MPH:
    For this, we will need to add a constraint for each possible assignment of distances driven by Poltris and the car with a high speed of 69 MPH, such that Poltris's distance is 25 miles greater than the 69 MPH car's distance. So, the constraints will be of the form:
    d1 == Poltris and d2 == Speed69 => d1_to_int == d2_to_int + 25, for all d1, d2 in distances.

-   The Awick drove somewhat less than the automobile with a high speed of 81 MPH:
    For this, we will need to add a constraint for each possible assignment of distances driven by Awick and the car with a high speed of 81 MPH, such that Awick's distance is less than the 81 MPH car's distance. So, the constraints will be of the form:
    d1 == Awick and d2 == Speed81 => d1_to_int < d2_to_int, for all d1, d2 in distances.

-   The car with a high speed of 69 MPH drove somewhat farther than the automobile with a high speed of 81 MPH:
    For this, we will need to add a constraint for each possible assignment of distances driven by the 69 MPH car and the 81 MPH car, such that the 69 MPH car's distance is greater than the 81 MPH car's distance. So, the constraints will be of the form:
    d1 == Speed69 and d2 == Speed81 => d1_to_int > d2_to_int, for all d1, d2 in distances.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of car, distance, and speed)
# e.g. if awick == 1 and distance525 == 1 and speed62 == 1, then Awick drove 525 miles at 62 MPH
awick, leden, poltris, versem = cars = intvar(1, 4, shape=4)
distance525, distance550, distance575, distance600 = distances = intvar(1, 4, shape=4)
speed62, speed69, speed75, speed81 = speeds = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
car_to_int = None  # N/A
distance_to_int = {distance525: 525, distance550: 550, distance575: 575, distance600: 600}  # in miles
speed_to_int = {speed62: 62, speed69: 69, speed75: 75, speed81: 81}  # in MPH


# Helper functions (for formulating comparison constraints)
def drove_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 drove diff miles more than var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(distance_to_int[d1] == distance_to_int[d2] + diff)
            for d1 in distances for d2 in distances]


def drove_less_than(var1, var2):
    """
    Formulate the constraint that var1 drove less miles than var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(distance_to_int[d1] < distance_to_int[d2])
            for d1 in distances for d2 in distances]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(cars)
m += AllDifferent(distances)
m += AllDifferent(speeds)

# Clue 1: The Leden drove 25 miles farther than the automobile with a high speed of 75 MPH:
m += drove_more_than(leden, speed75, 25)

# Clue 2: The Poltris drove 25 miles farther than the automobile with a high speed of 69 MPH:
m += drove_more_than(poltris, speed69, 25)

# Clue 3: The Awick drove somewhat less than the automobile with a high speed of 81 MPH:
m += drove_less_than(awick, speed81)

# Clue 4: The car with a high speed of 69 MPH drove somewhat farther than the automobile with a high speed of 81 MPH:
m += drove_more_than(speed69, speed81, 0)

```
None
False
False
False
Wrong: 1, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The report from Zearing was either the August 4 report or Edith Estes's report.
Hal Harrison's report was submitted sometime after Iva Ingram's sighting.
The August 5 sighting was from Islesboro.
The report from Tarzana was submitted 1 day before the sighting from Islesboro.
Benny Baron's report was received on August 7.

Entities:
witnesses: Benny Baron, Edith Estes, Hal Harrison, Iva Ingram
dates: August 4, August 5, August 6, August 7
towns: Islesboro, Long Barn, Tarzana, Zearing
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Benny Baron == 1, and August4 == 1, and Islesboro == 1, then Benny Baron's report was received on August 4 from Islesboro.

### Decision variables:
-   Names of the witnesses: Benny Baron, Edith Estes, Hal Harrison, Iva Ingram (all different, 1 to 4)
-   Dates of reports: August 4, August 5, August 6, August 7 (all different, 1 to 4)
-   Towns of sightings: Islesboro, Long Barn, Tarzana, Zearing (all different, 1 to 4)

### Constraints:
-   The report from Zearing was either the August 4 report or Edith Estes's report:
    This constraint states that the report from Zearing is either on August 4 or it is Edith Estes's report. So, we can represent this as:
    Or([Zearing == August4, Zearing == EdithEstes]).

-   Hal Harrison's report was submitted sometime after Iva Ingram's sighting:
    For this, we will need to add a constraint for each possible assignment of dates for Hal Harrison's report and Iva Ingram's sighting, such that Hal Harrison's report date is greater than Iva Ingram's sighting date. So, the constraints will be of the form:
    d1 == HalHarrison and d2 == IvaIngram => d1_to_int > d2_to_int, for all d1, d2 in dates.

-   The August 5 sighting was from Islesboro:
    This constraint states that the sighting on August 5 was from Islesboro. So, we can represent this as:
    Islesboro == August5.

-   The report from Tarzana was submitted 1 day before the sighting from Islesboro:
    For this, we will need to add a constraint for each possible assignment of dates for the report from Tarzana and the sighting from Islesboro, such that the report from Tarzana's date is 1 less than the Islesboro sighting date. So, the constraints will be of the form:
    d1 == Tarzana and d2 == Islesboro => d1_to_int == d2_to_int - 1, for all d1, d2 in dates.

-   Benny Baron's report was received on August 7:
    This constraint states that Benny Baron's report was received on August 7. So, we can represent this as:
    BennyBaron == August7.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Benny Baron == 1, and August4 == 1, and Islesboro == 1, then Benny Baron's report was received on August 4 from Islesboro.

### Decision variables:
-   Names of the witnesses: Benny Baron, Edith Estes, Hal Harrison, Iva Ingram (all different, 1 to 4)
-   Dates of reports: August 4, August 5, August 6, August 7 (all different, 1 to 4)
-   Towns of sightings: Islesboro, Long Barn, Tarzana, Zearing (all different, 1 to 4)

### Constraints:
-   The report from Zearing was either the August 4 report or Edith Estes's report:
    This constraint states that the report from Zearing is either on August 4 or it is Edith Estes's report. So, we can represent this as:
    Or([Zearing == August4, Zearing == EdithEstes]).

-   Hal Harrison's report was submitted sometime after Iva Ingram's sighting:
    For this, we will need to add a constraint for each possible assignment of dates for Hal Harrison's report and Iva Ingram's sighting, such that Hal Harrison's report date is greater than Iva Ingram's sighting date. So, the constraints will be of the form:
    d1 == HalHarrison and d2 == IvaIngram => d1_to_int > d2_to_int, for all d1, d2 in dates.

-   The August 5 sighting was from Islesboro:
    This constraint states that the sighting on August 5 was from Islesboro. So, we can represent this as:
    Islesboro == August5.

-   The report from Tarzana was submitted 1 day before the sighting from Islesboro:
    For this, we will need to add a constraint for each possible assignment of dates for the report from Tarzana and the sighting from Islesboro, such that the report from Tarzana's date is 1 less than the Islesboro sighting date. So, the constraints will be of the form:
    d1 == Tarzana and d2 == Islesboro => d1_to_int == d2_to_int - 1, for all d1, d2 in dates.

-   Benny Baron's report was received on August 7:
    This constraint states that Benny Baron's report was received on August 7. So, we can represent this as:
    BennyBaron == August7.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of witness, date, and town)
# e.g. if benny_baron == 1 and august4 == 1 and islesboro == 1, then Benny Baron's report was received on August 4 from Islesboro
benny_baron, edith_estes, hal_harrison, iva_ingram = witnesses = intvar(1, 4, shape=4)
august4, august5, august6, august7 = dates = intvar(1, 4, shape=4)
islesboro, long_barn, tarzana, zearing = towns = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
witness_to_int = None  # N/A
date_to_int = {august4: 1, august5: 2, august6: 3, august7: 4}  # in days
town_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def submitted_after(var1, var2):
    """
    Formulate the constraint that var1 was submitted after var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(date_to_int[d1] > date_to_int[d2])
            for d1 in dates for d2 in dates]


def submitted_exactly_before(var1, var2, diff):
    """
    Formulate the constraint that var1 was submitted exactly diff days before var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(date_to_int[d1] == date_to_int[d2] - diff)
            for d1 in dates for d2 in dates]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(witnesses)
m += AllDifferent(dates)
m += AllDifferent(towns)

# Clue 1: The report from Zearing was either the August 4 report or Edith Estes's report
m += Or([
    zearing == august4,
    zearing == edith_estes
])

# Clue 2: Hal Harrison's report was submitted sometime after Iva Ingram's sighting
m += submitted_after(hal_harrison, iva_ingram)

# Clue 3: The August 5 sighting was from Islesboro
m += islesboro == august5

# Clue 4: The report from Tarzana was submitted 1 day before the sighting from Islesboro
m += submitted_exactly_before(tarzana, islesboro, 1)

# Clue 5: Benny Baron's report was received on August 7
m += benny_baron == august7

```
None
Error when trying to check solution from predicted model: invalid syntax (<string>, line 1)
False
False
Error in constraint evaluation: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
Sunshine is either the condor with a wingspan of 102 inches or the 5-year-old bird.
The condor with a wingspan of 114 inches is 5 years old.
Pepper has a wingspan of 114 inches.
The four condors are the 9-year-old bird, Pepper, Merlin and the condor with a wingspan of 106 inches.
The 9-year-old bird has a wingspan 4 inches shorter than the 4-year-old bird.

Entities:
wingspans: 102 inches, 106 inches, 110 inches, 114 inches
names: Merlin, Pepper, Spike, Sunshine
ages: 4, 5, 8, 9
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Merlin == 1, and Wingspan102 == 1, and Age4 == 1, then Merlin is the 4-year-old bird with a wingspan of 102 inches.

### Decision variables:
-   Names of the birds: Merlin, Pepper, Spike, Sunshine (all different, 1 to 4)
-   Wingspans: 102 inches, 106 inches, 110 inches, 114 inches (all different, 1 to 4)
-   Ages: 4, 5, 8, 9 (all different, 1 to 4)

### Constraints:
-   Sunshine is either the condor with a wingspan of 102 inches or the 5-year-old bird:
    This is a constraint that states that Sunshine is either the bird with a wingspan of 102 inches or the 5-year-old bird, but not both. So:
    Xor([Sunshine == Wingspan102, Sunshine == Age5]).

-   The condor with a wingspan of 114 inches is 5 years old:
    This is a constraint that states that the bird with a wingspan of 114 inches is 5 years old. So:
    wingspan114 == Age5.

-   Pepper has a wingspan of 114 inches:
    This is a constraint that states that Pepper has a wingspan of 114 inches. So:
    Pepper == wingspan114.

-   The four condors are the 9-year-old bird, Pepper, Merlin, and the condor with a wingspan of 106 inches:
    This is a constraint that states the four condors are the 9-year-old bird, Pepper, Merlin, and the bird with a wingspan of 106 inches. So:
    AllDifferent([Age9, Pepper, Merlin, Wingspan106]).

-   The 9-year-old bird has a wingspan 4 inches shorter than the 4-year-old bird:
    This is a constraint that states that the 9-year-old bird has a wingspan 4 inches shorter than the 4-year-old bird. So:
    Age9_wingspan == Age4_wingspan - 4.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Merlin == 1, and Wingspan102 == 1, and Age4 == 1, then Merlin is the 4-year-old bird with a wingspan of 102 inches.

### Decision variables:
-   Names of the birds: Merlin, Pepper, Spike, Sunshine (all different, 1 to 4)
-   Wingspans: 102 inches, 106 inches, 110 inches, 114 inches (all different, 1 to 4)
-   Ages: 4, 5, 8, 9 (all different, 1 to 4)

### Constraints:
-   Sunshine is either the condor with a wingspan of 102 inches or the 5-year-old bird:
    This is a constraint that states that Sunshine is either the bird with a wingspan of 102 inches or the 5-year-old bird, but not both. So:
    Xor([Sunshine == Wingspan102, Sunshine == Age5]).

-   The condor with a wingspan of 114 inches is 5 years old:
    This is a constraint that states that the bird with a wingspan of 114 inches is 5 years old. So:
    wingspan114 == Age5.

-   Pepper has a wingspan of 114 inches:
    This is a constraint that states that Pepper has a wingspan of 114 inches. So:
    Pepper == wingspan114.

-   The four condors are the 9-year-old bird, Pepper, Merlin, and the condor with a wingspan of 106 inches:
    This is a constraint that states the four condors are the 9-year-old bird, Pepper, Merlin, and the bird with a wingspan of 106 inches. So:
    AllDifferent([Age9, Pepper, Merlin, Wingspan106]).

-   The 9-year-old bird has a wingspan 4 inches shorter than the 4-year-old bird:
    This is a constraint that states that the 9-year-old bird has a wingspan 4 inches shorter than the 4-year-old bird. So:
    Age9_wingspan == Age4_wingspan - 4.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of bird, wingspan, and age)
# e.g. if merlin == 1 and wingspan102 == 1 and age4 == 1, then Merlin is the 4-year-old bird with a wingspan of 102 inches
merlin, pepper, spike, sunshine = names = intvar(1, 4, shape=4)
wingspan102, wingspan106, wingspan110, wingspan114 = wingspans = intvar(1, 4, shape=4)
age4, age5, age8, age9 = ages = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
name_to_int = None  # N/A
wingspan_to_int = {wingspan102: 102, wingspan106: 106, wingspan110: 110, wingspan114: 114}  # in inches
age_to_int = {age4: 4, age5: 5, age8: 8, age9: 9}  # in years


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(names)
m += AllDifferent(wingspans)
m += AllDifferent(ages)

# Clue 1: Sunshine is either the condor with a wingspan of 102 inches or the 5-year-old bird:
m += Xor([
    sunshine == wingspan102,
    sunshine == age5
])

# Clue 2: The condor with a wingspan of 114 inches is 5 years old:
m += wingspan114 == age5

# Clue 3: Pepper has a wingspan of 114 inches:
m += pepper == wingspan114

# Clue 4: The four condors are the 9-year-old bird, Pepper, Merlin, and the condor with a wingspan of 106 inches:
m += AllDifferent([age9, pepper, merlin, wingspan106])

# Clue 5: The 9-year-old bird has a wingspan 4 inches shorter than the 4-year-old bird:
m += age9 * 4 == age4 + 4

```
[['pepper', 'wingspan114', 'age5'], ['sunshine', 'wingspan102', 'age9'], ['spike', 'wingspan106', 'age8'], ['merlin', 'wingspan110', 'age4']]
False
False
False
Wrong: 2, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The puzzle with the autumn leaves theme has somewhat more than the jigsaw puzzle with the rustic village theme.
The four puzzles are the puzzle made by Buralde, the jigsaw puzzle with the rustic village theme, the puzzle with the autumn leaves theme and the puzzle with 1000 pieces.
The jigsaw puzzle made by Buralde has the outer space theme.
The jigsaw puzzle made by Denlend has somewhat fewer than the jigsaw puzzle with the outer space theme.
The jigsaw puzzle made by Kimsight has 250 more pieces than the puzzle made by Denlend.

Entities:
companies: Buralde, Denlend, Irycia, Kimsight
pieces: 250, 500, 750, 1000
themes: autumn leaves, coral reef, outer space, rustic village
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Buralde == 1, and Pieces1000 == 1, and ThemeAutumnLeaves == 1, then Buralde made the puzzle with 1000 pieces and the autumn leaves theme.

### Decision variables:
-   Companies making the puzzles: Buralde, Denlend, Irycia, Kimsight (all different, 1 to 4)
-   Number of pieces in the puzzles: Pieces250, Pieces500, Pieces750, Pieces1000 (all different, 1 to 4)
-   Themes of the puzzles: ThemeAutumnLeaves, ThemeCoralReef, ThemeOuterSpace, ThemeRusticVillage (all different, 1 to 4)

### Constraints:
-   The puzzle with the autumn leaves theme has somewhat more pieces than the jigsaw puzzle with the rustic village theme:
    For this, we will need to add a constraint for each possible assignment of pieces to the autumn leaves theme and the rustic village theme, such that the number of pieces for the autumn leaves theme is somewhat more than the number of pieces for the rustic village theme. So, the constraints will be of the form:
    p1 == ThemeAutumnLeaves and p2 == ThemeRusticVillage => p1_to_int == p2_to_int + 1, for all p1, p2 in pieces.

-   The four puzzles are the puzzle made by Buralde, the jigsaw puzzle with the rustic village theme, the puzzle with the autumn leaves theme, and the puzzle with 1000 pieces:
    This is a constraint that states the four unique combinations of companies, themes, and number of pieces. So, we will have:
    AllDifferent([Buralde, Denlend, Irycia, Kimsight])
    AllDifferent([ThemeAutumnLeaves, ThemeCoralReef, ThemeOuterSpace, ThemeRusticVillage])
    AllDifferent([Pieces250, Pieces500, Pieces750, Pieces1000])

-   The jigsaw puzzle made by Buralde has the outer space theme:
    This is a constraint that specifies the theme of the puzzle made by Buralde. So, we will have:
    Buralde == ThemeOuterSpace.

-   The jigsaw puzzle made by Denlend has somewhat fewer pieces than the jigsaw puzzle with the outer space theme:
    For this, we will need to add a constraint for each possible assignment of pieces to the puzzle made by Denlend and the puzzle with the outer space theme, such that the number of pieces for the puzzle made by Denlend is somewhat fewer than the number of pieces for the outer space theme. So, the constraints will be of the form:
    p1 == Denlend and p2 == ThemeOuterSpace => p1_to_int == p2_to_int - 1, for all p1, p2 in pieces.

-   The jigsaw puzzle made by Kimsight has 250 more pieces than the puzzle made by Denlend:
    For this, we will need to add a constraint for each possible assignment of pieces to the puzzle made by Kimsight and the puzzle made by Denlend, such that the number of pieces for the puzzle made by Kimsight is 250 more than the number of pieces for the puzzle made by Denlend. So, the constraints will be of the form:
    p1 == Kimsight and p2 == Denlend => p1_to_int == p2_to_int + 250, for all p1, p2 in pieces.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Buralde == 1, and Pieces1000 == 1, and ThemeAutumnLeaves == 1, then Buralde made the puzzle with 1000 pieces and the autumn leaves theme.

### Decision variables:
-   Companies making the puzzles: Buralde, Denlend, Irycia, Kimsight (all different, 1 to 4)
-   Number of pieces in the puzzles: Pieces250, Pieces500, Pieces750, Pieces1000 (all different, 1 to 4)
-   Themes of the puzzles: ThemeAutumnLeaves, ThemeCoralReef, ThemeOuterSpace, ThemeRusticVillage (all different, 1 to 4)

### Constraints:
-   The puzzle with the autumn leaves theme has somewhat more pieces than the jigsaw puzzle with the rustic village theme:
    For this, we will need to add a constraint for each possible assignment of pieces to the autumn leaves theme and the rustic village theme, such that the number of pieces for the autumn leaves theme is somewhat more than the number of pieces for the rustic village theme. So, the constraints will be of the form:
    p1 == ThemeAutumnLeaves and p2 == ThemeRusticVillage => p1_to_int == p2_to_int + 1, for all p1, p2 in pieces.

-   The four puzzles are the puzzle made by Buralde, the jigsaw puzzle with the rustic village theme, the puzzle with the autumn leaves theme, and the puzzle with 1000 pieces:
    This is a constraint that states the four unique combinations of companies, themes, and number of pieces. So, we will have:
    AllDifferent([Buralde, Denlend, Irycia, Kimsight])
    AllDifferent([ThemeAutumnLeaves, ThemeCoralReef, ThemeOuterSpace, ThemeRusticVillage])
    AllDifferent([Pieces250, Pieces500, Pieces750, Pieces1000])

-   The jigsaw puzzle made by Buralde has the outer space theme:
    This is a constraint that specifies the theme of the puzzle made by Buralde. So, we will have:
    Buralde == ThemeOuterSpace.

-   The jigsaw puzzle made by Denlend has somewhat fewer pieces than the jigsaw puzzle with the outer space theme:
    For this, we will need to add a constraint for each possible assignment of pieces to the puzzle made by Denlend and the puzzle with the outer space theme, such that the number of pieces for the puzzle made by Denlend is somewhat fewer than the number of pieces for the outer space theme. So, the constraints will be of the form:
    p1 == Denlend and p2 == ThemeOuterSpace => p1_to_int == p2_to_int - 1, for all p1, p2 in pieces.

-   The jigsaw puzzle made by Kimsight has 250 more pieces than the puzzle made by Denlend:
    For this, we will need to add a constraint for each possible assignment of pieces to the puzzle made by Kimsight and the puzzle made by Denlend, such that the number of pieces for the puzzle made by Kimsight is 250 more than the number of pieces for the puzzle made by Denlend. So, the constraints will be of the form:
    p1 == Kimsight and p2 == Denlend => p1_to_int == p2_to_int + 250, for all p1, p2 in pieces.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of company, theme, and number of pieces)
# e.g. if buralde == 1 and pieces1000 == 1 and themeautumnleaves == 1, then Buralde made the puzzle with 1000 pieces and the autumn leaves theme
buralde, denlend, irycia, kimsight = companies = intvar(1, 4, shape=4)
pieces250, pieces500, pieces750, pieces1000 = pieces = intvar(1, 4, shape=4)
themeautumnleaves, themecoralreef, themeouterspace, themerusticvillage = themes = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
company_to_int = None  # N/A
pieces_to_int = {pieces250: 250, pieces500: 500, pieces750: 750, pieces1000: 1000}  # in pieces


# Helper functions (for formulating comparison constraints)
def somewhat_more_than(var1, var2):
    """
    Formulate the constraint that var1 has somewhat more pieces than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(pieces_to_int[p1] == pieces_to_int[p2] + 1)
            for p1 in pieces for p2 in pieces]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(companies)
m += AllDifferent(themes)
m += AllDifferent(pieces)

# Clue 1: The puzzle with the autumn leaves theme has somewhat more pieces than the jigsaw puzzle with the rustic village theme:
m += somewhat_more_than(themeautumnleaves, themerusticvillage)

# Clue 2: The four puzzles are the puzzle made by Buralde, the jigsaw puzzle with the rustic village theme, the puzzle with the autumn leaves theme, and the puzzle with 1000 pieces:
m += AllDifferent([buralde, denlend, irycia, kimsight])
m += AllDifferent([themerusticvillage, themecoralreef, themeouterspace, themeautumnleaves])
m += AllDifferent([pieces250, pieces500, pieces750, pieces1000])

# Clue 3: The jigsaw puzzle made by Buralde has the outer space theme:
m += buralde == themeouterspace

# Clue 4: The jigsaw puzzle made by Denlend has somewhat fewer pieces than the jigsaw puzzle with the outer space theme:
m += somewhat_more_than(denlend, themeouterspace)

# Clue 5: The jigsaw puzzle made by Kimsight has 250 more pieces than the puzzle made by Denlend:
m += [((p1 == kimsight) & (p2 == denlend)).implies(pieces_to_int[p1] == pieces_to_int[p2] + 250)
      for p1 in pieces for p2 in pieces]

```
None
False
False
False
Wrong: 5, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The worker who works in the green section served more riders than Brett.
Peter served 25 fewer riders than Willis.
Brett served more riders than Peter.
The person who works in the yellow section served 25 more riders than the worker who works in the orange section.
Peter is either the person who served 125 riders or the person who works in the blue section.

Entities:
employees: Brett, Peter, Victor, Willis
rides: 50 riders, 75 riders, 100 riders, 125 riders
section: blue, green, orange, yellow
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Brett == 1, and Blue == 1, and Riders50 == 1, then Brett works in the blue section and served 50 riders.

### Decision variables:
-   Names of the employees: Brett, Peter, Victor, Willis (all different, 1 to 4)
-   Number of riders served: Riders50, Riders75, Riders100, Riders125 (all different, 1 to 4)
-   Sections: Blue, Green, Orange, Yellow (all different, 1 to 4)

### Constraints:
-   The worker who works in the green section served more riders than Brett:
    For this, we will need to add a constraint for each possible assignment of employees and sections, such that the worker in the green section served more riders than Brett. So, the constraints will be of the form:
    e1 == Green and e2 == Brett => r1_to_int > r2_to_int, for all e1, e2 in employees and r1, r2 in riders served.

-   Peter served 25 fewer riders than Willis:
    For this, we will need to add a constraint for each possible assignment of employees and number of riders served, such that Peter served 25 fewer riders than Willis. So, the constraints will be of the form:
    e1 == Peter and e2 == Willis => r1_to_int == r2_to_int - 25, for all e1, e2 in employees and r1, r2 in riders served.

-   Brett served more riders than Peter:
    For this, we will need to add a constraint for each possible assignment of employees and number of riders served, such that Brett served more riders than Peter. So, the constraints will be of the form:
    e1 == Brett and e2 == Peter => r1_to_int > r2_to_int, for all e1, e2 in employees and r1, r2 in riders served.

-   The person who works in the yellow section served 25 more riders than the worker who works in the orange section:
    For this, we will need to add a constraint for each possible assignment of sections and number of riders served, such that the person in the yellow section served 25 more riders than the worker in the orange section. So, the constraints will be of the form:
    s1 == Yellow and s2 == Orange => r1_to_int == r2_to_int + 25, for all s1, s2 in sections and r1, r2 in riders served.

-   Peter is either the person who served 125 riders or the person who works in the blue section:
    This is a constraint that states that Peter is either the person who served 125 riders or the person who works in the blue section, but not both. So:
    Xor([Peter == Riders125, Peter == Blue]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Brett == 1, and Blue == 1, and Riders50 == 1, then Brett works in the blue section and served 50 riders.

### Decision variables:
-   Names of the employees: Brett, Peter, Victor, Willis (all different, 1 to 4)
-   Number of riders served: Riders50, Riders75, Riders100, Riders125 (all different, 1 to 4)
-   Sections: Blue, Green, Orange, Yellow (all different, 1 to 4)

### Constraints:
-   The worker who works in the green section served more riders than Brett:
    For this, we will need to add a constraint for each possible assignment of employees and sections, such that the worker in the green section served more riders than Brett. So, the constraints will be of the form:
    e1 == Green and e2 == Brett => r1_to_int > r2_to_int, for all e1, e2 in employees and r1, r2 in riders served.

-   Peter served 25 fewer riders than Willis:
    For this, we will need to add a constraint for each possible assignment of employees and number of riders served, such that Peter served 25 fewer riders than Willis. So, the constraints will be of the form:
    e1 == Peter and e2 == Willis => r1_to_int == r2_to_int - 25, for all e1, e2 in employees and r1, r2 in riders served.

-   Brett served more riders than Peter:
    For this, we will need to add a constraint for each possible assignment of employees and number of riders served, such that Brett served more riders than Peter. So, the constraints will be of the form:
    e1 == Brett and e2 == Peter => r1_to_int > r2_to_int, for all e1, e2 in employees and r1, r2 in riders served.

-   The person who works in the yellow section served 25 more riders than the worker who works in the orange section:
    For this, we will need to add a constraint for each possible assignment of sections and number of riders served, such that the person in the yellow section served 25 more riders than the worker in the orange section. So, the constraints will be of the form:
    s1 == Yellow and s2 == Orange => r1_to_int == r2_to_int + 25, for all s1, s2 in sections and r1, r2 in riders served.

-   Peter is either the person who served 125 riders or the person who works in the blue section:
    This is a constraint that states that Peter is either the person who served 125 riders or the person who works in the blue section, but not both. So:
    Xor([Peter == Riders125, Peter == Blue]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of employee, riders served, and section)
# e.g. if brett == 1 and riders50 == 1 and blue == 1, then Brett works in the blue section and served 50 riders
brett, peter, victor, willis = employees = intvar(1, 4, shape=4)
riders50, riders75, riders100, riders125 = rides = intvar(1, 4, shape=4)
blue, green, orange, yellow = sections = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
employee_to_int = None  # N/A
riders_to_int = {riders50: 50, riders75: 75, riders100: 100, riders125: 125}  # number of riders served
section_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def served_more_than(var1, var2):
    """
    Formulate the constraint that var1 served more riders than var2.
    """
    return [((e1 == var1) & (e2 == var2)).implies(riders_to_int[e1] > riders_to_int[e2])
            for e1 in rides for e2 in rides]


def served_fewer_than(var1, var2, diff):
    """
    Formulate the constraint that var1 served diff fewer riders than var2.
    """
    return [((e1 == var1) & (e2 == var2)).implies(riders_to_int[e1] == riders_to_int[e2] - diff)
            for e1 in rides for e2 in rides]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(employees)
m += AllDifferent(rides)
m += AllDifferent(sections)

# Clue 1: The worker who works in the green section served more riders than Brett:
m += served_more_than(green, brett)

# Clue 2: Peter served 25 fewer riders than Willis:
m += served_fewer_than(peter, willis, 25)

# Clue 3: Brett served more riders than Peter:
m += served_more_than(brett, peter)

# Clue 4: The person who works in the yellow section served 25 more riders than the worker who works in the orange section:
m += served_fewer_than(yellow, orange, -25)

# Clue 5: Peter is either the person who served 125 riders or the person who works in the blue section:
m += Xor([
    peter == riders125,
    peter == blue
])

```
[['victor', 'riders125', 'green'], ['brett', 'riders100', 'yellow'], ['peter', 'riders50', 'blue'], ['willis', 'riders75', 'orange']]
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The team from Venezuela finished with 4 gold medals.
The squad that won 2 gold medals ended with 6 silver medals.
The four teams were the squad from Zimbabwe, the team that won 3 gold medals, the squad that won 6 silver medals and the squad that won 8 silver medals.
The team from Dominica ended the games with 1 fewer gold medal than the squad that won 5 silver medals.

Entities:
countries: Dominica, Jordan, Venezuela, Zimbabwe
gold medals: 1, 2, 3, 4
silver medals: 2, 5, 6, 8
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Dominica == 1, and Gold1 == 1, and Silver2 == 1, then Dominica won 1 gold medal and 2 silver medals.

### Decision variables:
-   Countries: Dominica, Jordan, Venezuela, Zimbabwe (all different, 1 to 4)
-   Gold medals won: Gold1, Gold2, Gold3, Gold4 (all different, 1 to 4)
-   Silver medals won: Silver2, Silver5, Silver6, Silver8 (all different, 1 to 4)

### Constraints:
-   The team from Venezuela finished with 4 gold medals:
    This constraint directly assigns 4 gold medals to Venezuela:
    Venezuela == Gold4.

-   The squad that won 2 gold medals ended with 6 silver medals:
    This constraint directly assigns 2 gold medals and 6 silver medals to a squad:
    Squad_with_2_gold == Gold2 and Squad_with_2_gold == Silver6.

-   The four teams were the squad from Zimbabwe, the team that won 3 gold medals, the squad that won 6 silver medals, and the squad that won 8 silver medals:
    This constraint assigns each team to one of the countries and their corresponding medal counts:
    Zimbabwe == Squad_Zimbabwe,
    Team_with_3_gold == Gold3,
    Squad_with_6_silver == Silver6,
    Squad_with_8_silver == Silver8.

-   The team from Dominica ended the games with 1 fewer gold medal than the squad that won 5 silver medals:
    This constraint assigns the gold and silver medals to Dominica and the squad with 5 silver medals:
    Dominica == Gold_less_than_5_silver,
    Squad_with_5_silver == Silver5,
    Gold_less_than_5_silver == Squad_with_5_silver - 1.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Dominica == 1, and Gold1 == 1, and Silver2 == 1, then Dominica won 1 gold medal and 2 silver medals.

### Decision variables:
-   Countries: Dominica, Jordan, Venezuela, Zimbabwe (all different, 1 to 4)
-   Gold medals won: Gold1, Gold2, Gold3, Gold4 (all different, 1 to 4)
-   Silver medals won: Silver2, Silver5, Silver6, Silver8 (all different, 1 to 4)

### Constraints:
-   The team from Venezuela finished with 4 gold medals:
    This constraint directly assigns 4 gold medals to Venezuela:
    Venezuela == Gold4.

-   The squad that won 2 gold medals ended with 6 silver medals:
    This constraint directly assigns 2 gold medals and 6 silver medals to a squad:
    Squad_with_2_gold == Gold2 and Squad_with_2_gold == Silver6.

-   The four teams were the squad from Zimbabwe, the team that won 3 gold medals, the squad that won 6 silver medals, and the squad that won 8 silver medals:
    This constraint assigns each team to one of the countries and their corresponding medal counts:
    Zimbabwe == Squad_Zimbabwe,
    Team_with_3_gold == Gold3,
    Squad_with_6_silver == Silver6,
    Squad_with_8_silver == Silver8.

-   The team from Dominica ended the games with 1 fewer gold medal than the squad that won 5 silver medals:
    This constraint assigns the gold and silver medals to Dominica and the squad with 5 silver medals:
    Dominica == Gold_less_than_5_silver,
    Squad_with_5_silver == Silver5,
    Gold_less_than_5_silver == Squad_with_5_silver - 1.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of country, gold medals, and silver medals)
# e.g. if dominica == 1 and gold1 == 1 and silver2 == 1, then Dominica won 1 gold medal and 2 silver medals
dominica, jordan, venezuela, zimbabwe = countries = intvar(1, 4, shape=4)
gold1, gold2, gold3, gold4 = gold_medals = intvar(1, 4, shape=4)
silver2, silver5, silver6, silver8 = silver_medals = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
country_to_int = None  # N/A
gold_to_int = {gold1: 1, gold2: 2, gold3: 3, gold4: 4}  # in medals
silver_to_int = {silver2: 2, silver5: 5, silver6: 6, silver8: 8}  # in medals


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(countries)
m += AllDifferent(gold_medals)
m += AllDifferent(silver_medals)

# Clue 1: The team from Venezuela finished with 4 gold medals
m += venezuela == gold4

# Clue 2: The squad that won 2 gold medals ended with 6 silver medals
m += (gold2 == silver6)

# Clue 3: The four teams were the squad from Zimbabwe, the team that won 3 gold medals, the squad that won 6 silver medals, and the squad that won 8 silver medals
m += zimbabwe == dominica
m += gold3 == gold_medals
m += silver6 == silver_medals
m += silver8 == silver_medals

# Clue 4: The team from Dominica ended the games with 1 fewer gold medal than the squad that won 5 silver medals
m += dominica == (silver5 - 1)

```
None
Error when trying to check solution from predicted model: invalid syntax (<string>, line 1)
False
False
Error in constraint evaluation: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
The Vorckin impact crater is 125 meters wide.
The 150 meters wide one is either the Ordovician impact crater or the Permian impact crater.
The Ordovician impact crater is 25 meters wider than the Jurassic impact crater.
The Triassic impact crater is either the Ormagh impact crater or the 150 meters wide one.
The Cersay impact crater was formed during the Jurassic period.

Entities:
craters: Cersay, Moriwa, Ormagh, Vorckin
diameters: 100 meters, 125 meters, 150 meters, 175 meters
periods: Jurassic, Ordovician, Permian, Triassic
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Cersay == 1, and Diameter100 == 1, and Jurassic == 1, then Cersay is the crater with a 100-meter diameter formed during the Jurassic period.

### Decision variables:
-   Names of the craters: Cersay, Moriwa, Ormagh, Vorckin (all different, 1 to 4)
-   Diameters of the craters: Diameter100, Diameter125, Diameter150, Diameter175 (all different, 1 to 4)
-   Periods of formation: Jurassic, Ordovician, Permian, Triassic (all different, 1 to 4)

### Constraints:
-   The Vorckin impact crater is 125 meters wide:
    This constraint directly assigns the diameter of the Vorckin crater:
    Vorckin == Diameter125.

-   The 150 meters wide one is either the Ordovician impact crater or the Permian impact crater:
    This constraint states that the 150-meter wide crater is either the Ordovician or the Permian crater, but not both:
    Xor([Diameter150 == Ordovician, Diameter150 == Permian]).

-   The Ordovician impact crater is 25 meters wider than the Jurassic impact crater:
    This constraint states the difference in diameter between the Ordovician and Jurassic craters:
    Ordovician == Diameter100 + 25, Jurassic == Diameter100.

-   The Triassic impact crater is either the Ormagh impact crater or the 150 meters wide one:
    This constraint states that the Triassic crater is either Ormagh or the 150-meter wide crater, but not both:
    Xor([Triassic == Ormagh, Triassic == Diameter150]).

-   The Cersay impact crater was formed during the Jurassic period:
    This constraint directly assigns the period of formation for the Cersay crater:
    Cersay == Jurassic.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Cersay == 1, and Diameter100 == 1, and Jurassic == 1, then Cersay is the crater with a 100-meter diameter formed during the Jurassic period.

### Decision variables:
-   Names of the craters: Cersay, Moriwa, Ormagh, Vorckin (all different, 1 to 4)
-   Diameters of the craters: Diameter100, Diameter125, Diameter150, Diameter175 (all different, 1 to 4)
-   Periods of formation: Jurassic, Ordovician, Permian, Triassic (all different, 1 to 4)

### Constraints:
-   The Vorckin impact crater is 125 meters wide:
    This constraint directly assigns the diameter of the Vorckin crater:
    Vorckin == Diameter125.

-   The 150 meters wide one is either the Ordovician impact crater or the Permian impact crater:
    This constraint states that the 150-meter wide crater is either the Ordovician or the Permian crater, but not both:
    Xor([Diameter150 == Ordovician, Diameter150 == Permian]).

-   The Ordovician impact crater is 25 meters wider than the Jurassic impact crater:
    This constraint states the difference in diameter between the Ordovician and Jurassic craters:
    Ordovician == Diameter100 + 25, Jurassic == Diameter100.

-   The Triassic impact crater is either the Ormagh impact crater or the 150 meters wide one:
    This constraint states that the Triassic crater is either Ormagh or the 150-meter wide crater, but not both:
    Xor([Triassic == Ormagh, Triassic == Diameter150]).

-   The Cersay impact crater was formed during the Jurassic period:
    This constraint directly assigns the period of formation for the Cersay crater:
    Cersay == Jurassic.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of crater, diameter, and period)
# e.g. if cersay == 1 and diameter100 == 1 and jurassic == 1, then Cersay has a 100-meter diameter and was formed during the Jurassic period
cersay, moriwa, ormagh, vorckin = craters = intvar(1, 4, shape=4)
diameter100, diameter125, diameter150, diameter175 = diameters = intvar(1, 4, shape=4)
jurassic, ordovician, permian, triassic = periods = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
crater_to_int = None  # N/A
diameter_to_int = {diameter100: 100, diameter125: 125, diameter150: 150, diameter175: 175}  # in meters
period_to_int = None  # N/A


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(craters)
m += AllDifferent(diameters)
m += AllDifferent(periods)

# Clue 1: The Vorckin impact crater is 125 meters wide
m += vorckin == diameter125

# Clue 2: The 150 meters wide one is either the Ordovician impact crater or the Permian impact crater
m += Xor([
    diameter150 == ordovician,
    diameter150 == permian
])

# Clue 3: The Ordovician impact crater is 25 meters wider than the Jurassic impact crater
m += ordovician == diameter100 + 25
m += jurassic == diameter100

# Clue 4: The Triassic impact crater is either the Ormagh impact crater or the 150 meters wide one
m += Xor([
    triassic == ormagh,
    triassic == diameter150
])

# Clue 5: The Cersay impact crater was formed during the Jurassic period
m += cersay == jurassic

```
None
False
False
False
Wrong: 2, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The butterfly that was auctioned 7th sold for 20 dollars less than the insect won by Daniel.
The four butterflies were the insect that sold for $260, the butterfly that was auctioned 4th, the butterfly that was auctioned 7th and the butterfly won by Roland.
The butterfly won by Gabriel was the 8th lot.

Entities:
winners: Daniel, Gabriel, Roland, Vincent
prices: $250, $260, $270, $280
orders: 3rd, 4th, 7th, 8th
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Daniel == 1, and Price250 == 1, and Order3rd == 1, then Daniel won the insect that was the 3rd lot and sold for $250.

### Decision variables:
-   Winners of the insects: Daniel, Gabriel, Roland, Vincent (all different, 1 to 4)
-   Prices of the insects: Price250, Price260, Price270, Price280 (all different, 1 to 4)
-   Orders of the auctions: Order3rd, Order4th, Order7th, Order8th (all different, 1 to 4)

### Constraints:
-   The butterfly that was auctioned 7th sold for 20 dollars less than the insect won by Daniel:
    For this, we will need to add a constraint for each possible assignment of the prices of the 7th lot and the insect won by Daniel, such that the 7th lot's price is $20 less than Daniel's insect price. So, the constraints will be of the form:
    p1 == Price260 and p2 == Daniel => p1_to_int == p2_to_int - 20, for all p1, p2 in prices.

-   The four butterflies were the insect that sold for $260, the butterfly that was auctioned 4th, the butterfly that was auctioned 7th, and the butterfly won by Roland:
    This is a constraint that states the specific entities that correspond to the four butterflies. So, we will have constraints like:
    (Price260 == 1 or Order4th == 1 or Order7th == 1 or Roland == 1), and similarly for the other entities.

-   The butterfly won by Gabriel was the 8th lot:
    This is a constraint that states that Gabriel's insect corresponds to the 8th lot. So, we will have a constraint like:
    Gabriel == Order8th.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Daniel == 1, and Price250 == 1, and Order3rd == 1, then Daniel won the insect that was the 3rd lot and sold for $250.

### Decision variables:
-   Winners of the insects: Daniel, Gabriel, Roland, Vincent (all different, 1 to 4)
-   Prices of the insects: Price250, Price260, Price270, Price280 (all different, 1 to 4)
-   Orders of the auctions: Order3rd, Order4th, Order7th, Order8th (all different, 1 to 4)

### Constraints:
-   The butterfly that was auctioned 7th sold for 20 dollars less than the insect won by Daniel:
    For this, we will need to add a constraint for each possible assignment of the prices of the 7th lot and the insect won by Daniel, such that the 7th lot's price is $20 less than Daniel's insect price. So, the constraints will be of the form:
    p1 == Price260 and p2 == Daniel => p1_to_int == p2_to_int - 20, for all p1, p2 in prices.

-   The four butterflies were the insect that sold for $260, the butterfly that was auctioned 4th, the butterfly that was auctioned 7th, and the butterfly won by Roland:
    This is a constraint that states the specific entities that correspond to the four butterflies. So, we will have constraints like:
    (Price260 == 1 or Order4th == 1 or Order7th == 1 or Roland == 1), and similarly for the other entities.

-   The butterfly won by Gabriel was the 8th lot:
    This is a constraint that states that Gabriel's insect corresponds to the 8th lot. So, we will have a constraint like:
    Gabriel == Order8th.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of winner, price, and order)
# e.g. if daniel == 1 and price250 == 1 and order3rd == 1, then Daniel won the insect that was the 3rd lot and sold for $250
daniel, gabriel, roland, vincent = winners = intvar(1, 4, shape=4)
price250, price260, price270, price280 = prices = intvar(1, 4, shape=4)
order3rd, order4th, order7th, order8th = orders = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
winner_to_int = None  # N/A
price_to_int = {price250: 250, price260: 260, price270: 270, price280: 280}  # in dollars
order_to_int = {order3rd: 3, order4th: 4, order7th: 7, order8th: 8}  # in order


# Helper functions (for formulating comparison constraints)
def sold_for_less_than(var1, var2, diff):
    """
    Formulate the constraint that var1 sold for $diff less than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] - diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(winners)
m += AllDifferent(prices)
m += AllDifferent(orders)

# Clue 1: The butterfly that was auctioned 7th sold for 20 dollars less than the insect won by Daniel:
m += sold_for_less_than(price260, daniel, 20)

# Clue 2: The four butterflies were the insect that sold for $260, the butterfly that was auctioned 4th, the butterfly that was auctioned 7th, and the butterfly won by Roland:
m += ((price260 == 1) | (order4th == 1) | (order7th == 1) | (roland == 1))

# Clue 3: The butterfly won by Gabriel was the 8th lot:
m += gabriel == order8th

```
[['vincent', 'price270', 'order4th'], ['roland', 'price260', 'order7th'], ['gabriel', 'price250', 'order8th'], ['daniel', 'price280', 'order3rd']]
False
False
False
Wrong: 2, Total: 6
---------------------------------------------------------------------------------------------

Clues:
Greg threw the red darts.
Alton scored 7 points higher than Evan.
The contestant who threw the yellow darts scored somewhat higher than the player who threw the white darts.
The player who scored 48 points threw the yellow darts.
Greg scored 7 points higher than Jeffrey.

Entities:
players: Alton, Evan, Greg, Jeffrey
scores: 41, 48, 55, 62
colors: green, red, white, yellow
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Alton == 1, and Score41 == 1, and Green == 1, then Alton scored 41 points with green darts.

### Decision variables:
-   Names of the players: Alton, Evan, Greg, Jeffrey (all different, 1 to 4)
-   Scores: Score41, Score48, Score55, Score62 (all different, 1 to 4)
-   Colors of darts: Green, Red, White, Yellow (all different, 1 to 4)

### Constraints:
-   Greg threw the red darts:
    This constraint directly assigns Greg to the red darts:
    Greg == Red.

-   Alton scored 7 points higher than Evan:
    For this, we will need to add a constraint for each possible assignment of scores to Alton and Evan, such that Alton's score is 7 points higher than Evan's score. So, the constraints will be of the form:
    s1 == Alton and s2 == Evan => s1_to_int == s2_to_int + 7, for all s1, s2 in scores.

-   The contestant who threw the yellow darts scored somewhat higher than the player who threw the white darts:
    For this, we will need to add a constraint for each possible assignment of scores to the player who threw yellow darts and the player who threw white darts, such that the score of the player with yellow darts is somewhat higher than the score of the player with white darts. So, the constraints will be of the form:
    s1 == Yellow and s2 == White => s1_to_int > s2_to_int, for all s1, s2 in scores.

-   The player who scored 48 points threw the yellow darts:
    This constraint directly assigns the player who scored 48 points to the yellow darts:
    Score48 == Yellow.

-   Greg scored 7 points higher than Jeffrey:
    For this, we will need to add a constraint for each possible assignment of scores to Greg and Jeffrey, such that Greg's score is 7 points higher than Jeffrey's score. So, the constraints will be of the form:
    s1 == Greg and s2 == Jeffrey => s1_to_int == s2_to_int + 7, for all s1, s2 in scores.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Alton == 1, and Score41 == 1, and Green == 1, then Alton scored 41 points with green darts.

### Decision variables:
-   Names of the players: Alton, Evan, Greg, Jeffrey (all different, 1 to 4)
-   Scores: Score41, Score48, Score55, Score62 (all different, 1 to 4)
-   Colors of darts: Green, Red, White, Yellow (all different, 1 to 4)

### Constraints:
-   Greg threw the red darts:
    This constraint directly assigns Greg to the red darts:
    Greg == Red.

-   Alton scored 7 points higher than Evan:
    For this, we will need to add a constraint for each possible assignment of scores to Alton and Evan, such that Alton's score is 7 points higher than Evan's score. So, the constraints will be of the form:
    s1 == Alton and s2 == Evan => s1_to_int == s2_to_int + 7, for all s1, s2 in scores.

-   The contestant who threw the yellow darts scored somewhat higher than the player who threw the white darts:
    For this, we will need to add a constraint for each possible assignment of scores to the player who threw yellow darts and the player who threw white darts, such that the score of the player with yellow darts is somewhat higher than the score of the player with white darts. So, the constraints will be of the form:
    s1 == Yellow and s2 == White => s1_to_int > s2_to_int, for all s1, s2 in scores.

-   The player who scored 48 points threw the yellow darts:
    This constraint directly assigns the player who scored 48 points to the yellow darts:
    Score48 == Yellow.

-   Greg scored 7 points higher than Jeffrey:
    For this, we will need to add a constraint for each possible assignment of scores to Greg and Jeffrey, such that Greg's score is 7 points higher than Jeffrey's score. So, the constraints will be of the form:
    s1 == Greg and s2 == Jeffrey => s1_to_int == s2_to_int + 7, for all s1, s2 in scores.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of player, score, and color)
# e.g. if alton == 1 and score41 == 1 and green == 1, then Alton scored 41 points with green darts
alton, evan, greg, jeffrey = players = intvar(1, 4, shape=4)
score41, score48, score55, score62 = scores = intvar(1, 4, shape=4)
green, red, white, yellow = colors = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
player_to_int = None  # N/A
score_to_int = {score41: 41, score48: 48, score55: 55, score62: 62}  # in points
color_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def scored_higher_than(var1, var2, diff):
    """
    Formulate the constraint that var1 scored diff points higher than var2.
    """
    return [((s1 == var1) & (s2 == var2)).implies(score_to_int[s1] == score_to_int[s2] + diff)
            for s1 in scores for s2 in scores]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(players)
m += AllDifferent(scores)
m += AllDifferent(colors)

# Clue 1: Greg threw the red darts
m += greg == red

# Clue 2: Alton scored 7 points higher than Evan
m += scored_higher_than(alton, evan, 7)

# Clue 3: The contestant who threw the yellow darts scored somewhat higher than the player who threw the white darts
m += scored_higher_than(yellow, white, 1)

# Clue 4: The player who scored 48 points threw the yellow darts
m += score48 == yellow

# Clue 5: Greg scored 7 points higher than Jeffrey
m += scored_higher_than(greg, jeffrey, 7)

```
None
False
False
False
Wrong: 1, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Vasquez will leave sometime after Macdonald.
Vasquez will leave 1 month before the ambassador with the 5 day visit.
Gilbert is either the person leaving in January or the ambassador with the 4 day visit.
Macdonald will leave 1 month before the ambassador with the 4 day visit.
The ambassador with the 4 day visit will leave sometime before the ambassador with the 9 day visit.

Entities:
diplomats: Gilbert, Macdonald, Pickett, Vasquez
months: January, February, March, April
durations: 4 day, 5 day, 9 day, 10 day
### Decision variables:
- Diplomats: Gilbert, Macdonald, Pickett, Vasquez (1 to 4)
- Months: January, February, March, April (1 to 4)
- Durations: Day4, Day5, Day9, Day10 (1 to 4)

### Constraints:
1. Vasquez will leave sometime after Macdonald:
   \[ \text{Macdonald} < \text{Vasquez} \]

2. Vasquez will leave 1 month before the ambassador with the 5-day visit:
   \[ \text{Vasquez} + 1 = \text{Day5} \]

3. Gilbert is either the person leaving in January or the ambassador with the 4-day visit:
   \[ \text{Gilbert} = \text{January} \oplus \text{Gilbert} = \text{Day4} \]

4. Macdonald will leave 1 month before the ambassador with the 4-day visit:
   \[ \text{Macdonald} + 1 = \text{Day4} \]

5. The ambassador with the 4-day visit will leave sometime before the ambassador with the 9-day visit:
   \[ \text{Day4} < \text{Day9} \]

### Objective:
There is no objective function defined in the problem description.
### Decision variables:
- Diplomats: Gilbert, Macdonald, Pickett, Vasquez (1 to 4)
- Months: January, February, March, April (1 to 4)
- Durations: Day4, Day5, Day9, Day10 (1 to 4)

### Constraints:
1. Vasquez will leave sometime after Macdonald:
   \[ \text{Macdonald} < \text{Vasquez} \]

2. Vasquez will leave 1 month before the ambassador with the 5-day visit:
   \[ \text{Vasquez} + 1 = \text{Day5} \]

3. Gilbert is either the person leaving in January or the ambassador with the 4-day visit:
   \[ \text{Gilbert} = \text{January} \oplus \text{Gilbert} = \text{Day4} \]

4. Macdonald will leave 1 month before the ambassador with the 4-day visit:
   \[ \text{Macdonald} + 1 = \text{Day4} \]

5. The ambassador with the 4-day visit will leave sometime before the ambassador with the 9-day visit:
   \[ \text{Day4} < \text{Day9} \]

### Objective:
There is no objective function defined in the problem description.
```python
from cpmpy import *

# Decision variables
gilbert, macdonald, pickett, vasquez = diplomats = intvar(1, 4, shape=4)
january, february, march, april = months = intvar(1, 4, shape=4)
days4, days5, days9, days10 = durations = intvar(1, 4, shape=4)

# Constraints
m = Model()

# Clue 1: Vasquez will leave sometime after Macdonald
m += macdonald < vasquez

# Clue 2: Vasquez will leave 1 month before the ambassador with the 5-day visit
m += vasquez + 1 == days5

# Clue 3: Gilbert is either the person leaving in January or the ambassador with the 4-day visit
m += (gilbert == january) ^ (gilbert == days4)

# Clue 4: Macdonald will leave 1 month before the ambassador with the 4-day visit
m += macdonald + 1 == days4

# Clue 5: The ambassador with the 4-day visit will leave sometime before the ambassador with the 9-day visit
m += days4 < days9

```
None
False
False
False
Wrong: 7, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Hattie and the student who will major in Theology are different students.
The student who will major in English is either Tracy or the student who received the $25,000 scholarship.
Hattie was awarded $10,000 more than the person who will major in Physics.
The student who received the $40,000 scholarship will major in Theology.
Ora was awarded some amount less than the student who will major in Archaeology.

Entities:
names: Erma, Hattie, Ora, Tracy
scholarships: $25,000, $30,000, $35,000, $40,000
majors: Archaeology, English, Physics, Theology
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Erma == 1, and $25,000 == 1, and Archaeology == 1, then Erma received a $25,000 scholarship to major in Archaeology.

### Decision variables:
-   Names of the students: Erma, Hattie, Ora, Tracy (all different, 1 to 4)
-   Scholarship amounts: $25,000, $30,000, $35,000, $40,000 (all different, 1 to 4)
-   Majors: Archaeology, English, Physics, Theology (all different, 1 to 4)

### Constraints:
-   Hattie and the student majoring in Theology are different students:
    This is a constraint that states that Hattie and the student majoring in Theology are different. So:
    Hattie != Theology.

-   The student majoring in English is either Tracy or the student who received the $25,000 scholarship:
    This is a constraint that states that the student majoring in English is either Tracy or the student who received the $25,000 scholarship, but not both. So:
    Xor([English == Tracy, English == $25,000]).

-   Hattie was awarded $10,000 more than the person majoring in Physics:
    For this, we will need to add a constraint for each possible assignment of scholarships to Hattie and the person majoring in Physics, such that Hattie's scholarship amount is $10,000 more than the person majoring in Physics. So, the constraints will be of the form:
    s1 == Hattie and s2 == Physics => s1_to_int == s2_to_int + 10, for all s1, s2 in scholarships.

-   The student who received the $40,000 scholarship will major in Theology:
    This is a constraint that states that the student who received the $40,000 scholarship will major in Theology. So:
    $40,000 == Theology.

-   Ora was awarded some amount less than the student majoring in Archaeology:
    For this, we will need to add a constraint for each possible assignment of scholarships to Ora and the student majoring in Archaeology, such that Ora's scholarship amount is less than the student majoring in Archaeology. So, the constraints will be of the form:
    s1 == Ora and s2 == Archaeology => s1_to_int < s2_to_int, for all s1, s2 in scholarships.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Erma == 1, and $25,000 == 1, and Archaeology == 1, then Erma received a $25,000 scholarship to major in Archaeology.

### Decision variables:
-   Names of the students: Erma, Hattie, Ora, Tracy (all different, 1 to 4)
-   Scholarship amounts: $25,000, $30,000, $35,000, $40,000 (all different, 1 to 4)
-   Majors: Archaeology, English, Physics, Theology (all different, 1 to 4)

### Constraints:
-   Hattie and the student majoring in Theology are different students:
    This is a constraint that states that Hattie and the student majoring in Theology are different. So:
    Hattie != Theology.

-   The student majoring in English is either Tracy or the student who received the $25,000 scholarship:
    This is a constraint that states that the student majoring in English is either Tracy or the student who received the $25,000 scholarship, but not both. So:
    Xor([English == Tracy, English == $25,000]).

-   Hattie was awarded $10,000 more than the person majoring in Physics:
    For this, we will need to add a constraint for each possible assignment of scholarships to Hattie and the person majoring in Physics, such that Hattie's scholarship amount is $10,000 more than the person majoring in Physics. So, the constraints will be of the form:
    s1 == Hattie and s2 == Physics => s1_to_int == s2_to_int + 10, for all s1, s2 in scholarships.

-   The student who received the $40,000 scholarship will major in Theology:
    This is a constraint that states that the student who received the $40,000 scholarship will major in Theology. So:
    $40,000 == Theology.

-   Ora was awarded some amount less than the student majoring in Archaeology:
    For this, we will need to add a constraint for each possible assignment of scholarships to Ora and the student majoring in Archaeology, such that Ora's scholarship amount is less than the student majoring in Archaeology. So, the constraints will be of the form:
    s1 == Ora and s2 == Archaeology => s1_to_int < s2_to_int, for all s1, s2 in scholarships.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of student, scholarship, and major)
# e.g. if erma == 1 and scholarship25000 == 1 and archaeology == 1, then Erma received a $25,000 scholarship to major in Archaeology
erma, hattie, ora, tracy = students = intvar(1, 4, shape=4)
scholarship25000, scholarship30000, scholarship35000, scholarship40000 = scholarships = intvar(1, 4, shape=4)
archaeology, english, physics, theology = majors = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
student_to_int = None  # N/A
scholarship_to_int = {scholarship25000: 25000, scholarship30000: 30000, scholarship35000: 35000, scholarship40000: 40000}  # in dollars
major_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def scholarship_diff(var1, var2, diff):
    """
    Formulate the constraint that var1's scholarship amount is diff more than var2's scholarship amount.
    """
    return [((s1 == var1) & (s2 == var2)).implies(scholarship_to_int[s1] == scholarship_to_int[s2] + diff)
            for s1 in scholarships for s2 in scholarships]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(students)
m += AllDifferent(scholarships)
m += AllDifferent(majors)

# Clue 1: Hattie and the student majoring in Theology are different students:
m += hattie != theology

# Clue 2: The student majoring in English is either Tracy or the student who received the $25,000 scholarship:
m += Xor([
    english == tracy,
    english == scholarship25000
])

# Clue 3: Hattie was awarded $10,000 more than the person majoring in Physics:
m += scholarship_diff(hattie, physics, 10)

# Clue 4: The student who received the $40,000 scholarship will major in Theology:
m += scholarship40000 == theology

# Clue 5: Ora was awarded some amount less than the student majoring in Archaeology:
m += [((s1 == ora) & (s2 == archaeology)).implies(scholarship_to_int[s1] < scholarship_to_int[s2])
      for s1 in scholarships for s2 in scholarships]

```
None
False
False
False
Wrong: 1, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Hatcha started 6 years after the wing back.
Kawa began playing in 1982.
Banben was the center back.
The person who started in 1985 was either Kawa or the center forward.

Entities:
players: Banben, Hatcha, Kawa, Rothvum
years: 1976, 1979, 1982, 1985
positions: center back, center forward, goalie, wing back
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Banben == 1, and Year1976 == 1, and CenterBack == 1, then Banben started playing in 1976 as the center back.

### Decision variables:
-   Names of the players: Banben, Hatcha, Kawa, Rothvum (all different, 1 to 4)
-   Years of starting: 1976, 1979, 1982, 1985 (all different, 1 to 4)
-   Positions played: CenterBack, CenterForward, Goalie, WingBack (all different, 1 to 4)

### Constraints:
-   Hatcha started 6 years after the wing back:
    For this, we will need to add a constraint for each possible assignment of the years of starting for Hatcha and the wing back, such that Hatcha's starting year is 6 more than the wing back's starting year. So, the constraints will be of the form:
    y1 == Hatcha and y2 == WingBack => y1_to_int == y2_to_int + 6, for all y1, y2 in years of starting.

-   Kawa began playing in 1982:
    This is a simple constraint that states Kawa started playing in 1982:
    Kawa == Year1982.

-   Banben was the center back:
    This is a constraint that states Banben played as the center back:
    Banben == CenterBack.

-   The person who started in 1985 was either Kawa or the center forward:
    This is a constraint that states that the player who started in 1985 is either Kawa or the center forward, but not both. So:
    Xor([Year1985 == Kawa, Year1985 == CenterForward]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Banben == 1, and Year1976 == 1, and CenterBack == 1, then Banben started playing in 1976 as the center back.

### Decision variables:
-   Names of the players: Banben, Hatcha, Kawa, Rothvum (all different, 1 to 4)
-   Years of starting: 1976, 1979, 1982, 1985 (all different, 1 to 4)
-   Positions played: CenterBack, CenterForward, Goalie, WingBack (all different, 1 to 4)

### Constraints:
-   Hatcha started 6 years after the wing back:
    For this, we will need to add a constraint for each possible assignment of the years of starting for Hatcha and the wing back, such that Hatcha's starting year is 6 more than the wing back's starting year. So, the constraints will be of the form:
    y1 == Hatcha and y2 == WingBack => y1_to_int == y2_to_int + 6, for all y1, y2 in years of starting.

-   Kawa began playing in 1982:
    This is a simple constraint that states Kawa started playing in 1982:
    Kawa == Year1982.

-   Banben was the center back:
    This is a constraint that states Banben played as the center back:
    Banben == CenterBack.

-   The person who started in 1985 was either Kawa or the center forward:
    This is a constraint that states that the player who started in 1985 is either Kawa or the center forward, but not both. So:
    Xor([Year1985 == Kawa, Year1985 == CenterForward]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of player, year, and position)
# e.g. if banben == 1 and year1976 == 1 and centerback == 1, then Banben started playing in 1976 as the center back
banben, hatcha, kawa, rothvum = players = intvar(1, 4, shape=4)
year1976, year1979, year1982, year1985 = years = intvar(1, 4, shape=4)
centerback, centerforward, goalie, wingback = positions = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
player_to_int = None  # N/A
year_to_int = {year1976: 1976, year1979: 1979, year1982: 1982, year1985: 1985}  # in years
position_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def started_after(var1, var2, diff):
    """
    Formulate the constraint that var1 started diff years after var2.
    """
    return [((y1 == var1) & (y2 == var2)).implies(year_to_int[y1] == year_to_int[y2] + diff)
            for y1 in years for y2 in years]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(players)
m += AllDifferent(years)
m += AllDifferent(positions)

# Clue 1: Hatcha started 6 years after the wing back:
m += started_after(hatcha, wingback, 6)

# Clue 2: Kawa began playing in 1982:
m += kawa == year1982

# Clue 3: Banben was the center back:
m += banben == centerback

# Clue 4: The person who started in 1985 was either Kawa or the center forward:
m += Xor([
    year1985 == kawa,
    year1985 == centerforward
])

```
[['hatcha', 'year1985', 'centerforward'], ['banben', 'year1976', 'centerback'], ['kawa', 'year1982', 'goalie'], ['rothvum', 'year1979', 'wingback']]
True
True
True
Wrong: 0, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The puzzle with the postage stamp theme has somewhat fewer than the puzzle made by Astury.
The jigsaw puzzle with the outer space theme has 250 more pieces than the puzzle made by Garroda.
The jigsaw puzzle made by Garroda has somewhat fewer than the puzzle made by Vesem.
The jigsaw puzzle with the postage stamp theme has somewhat more than the puzzle with the city skyline theme.
The jigsaw puzzle made by Vesem has 500 pieces.

Entities:
companies: Astury, Denlend, Garroda, Vesem
pieces: 250, 500, 750, 1000
themes: autumn leaves, city skyline, outer space, postage stamp
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Astury == 1, and Pieces250 == 1, and AutumnLeaves == 1, then Astury made a 250-piece puzzle with an autumn leaves theme.

### Decision variables:
-   Companies: Astury, Denlend, Garroda, Vesem (all different, 1 to 4)
-   Number of pieces: Pieces250, Pieces500, Pieces750, Pieces1000 (all different, 1 to 4)
-   Themes: AutumnLeaves, CitySkyline, OuterSpace, PostageStamp (all different, 1 to 4)

### Constraints:
-   The puzzle with the postage stamp theme has somewhat fewer pieces than the puzzle made by Astury:
    For this, we will need to add a constraint for each possible assignment of themes and pieces for the postage stamp theme and Astury's puzzle, such that the postage stamp theme has somewhat fewer pieces than Astury's puzzle. So, the constraints will be of the form:
    t1 == PostageStamp and t2 == Astury => p1_to_int < p2_to_int, for all t1, t2 in pieces.

-   The jigsaw puzzle with the outer space theme has 250 more pieces than the puzzle made by Garroda:
    For this, we will need to add a constraint for each possible assignment of themes and pieces for the outer space theme and Garroda's puzzle, such that the outer space theme has 250 more pieces than Garroda's puzzle. So, the constraints will be of the form:
    t1 == OuterSpace and t2 == Garroda => p1_to_int == p2_to_int + 250, for all t1, t2 in pieces.

-   The jigsaw puzzle made by Garroda has somewhat fewer pieces than the puzzle made by Vesem:
    For this, we will need to add a constraint for each possible assignment of pieces for Garroda's and Vesem's puzzles, such that Garroda's puzzle has somewhat fewer pieces than Vesem's puzzle. So, the constraints will be of the form:
    p1 == Garroda and p2 == Vesem => p1_to_int < p2_to_int, for all p1, p2 in pieces.

-   The jigsaw puzzle with the postage stamp theme has somewhat more pieces than the puzzle with the city skyline theme:
    For this, we will need to add a constraint for each possible assignment of themes and pieces for the postage stamp and city skyline themes, such that the postage stamp theme has somewhat more pieces than the city skyline theme. So, the constraints will be of the form:
    t1 == PostageStamp and t2 == CitySkyline => p1_to_int > p2_to_int, for all t1, t2 in pieces.

-   The jigsaw puzzle made by Vesem has 500 pieces:
    This is a constraint that directly assigns the number of pieces to the puzzle made by Vesem:
    Vesem == Pieces500.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Astury == 1, and Pieces250 == 1, and AutumnLeaves == 1, then Astury made a 250-piece puzzle with an autumn leaves theme.

### Decision variables:
-   Companies: Astury, Denlend, Garroda, Vesem (all different, 1 to 4)
-   Number of pieces: Pieces250, Pieces500, Pieces750, Pieces1000 (all different, 1 to 4)
-   Themes: AutumnLeaves, CitySkyline, OuterSpace, PostageStamp (all different, 1 to 4)

### Constraints:
-   The puzzle with the postage stamp theme has somewhat fewer pieces than the puzzle made by Astury:
    For this, we will need to add a constraint for each possible assignment of themes and pieces for the postage stamp theme and Astury's puzzle, such that the postage stamp theme has somewhat fewer pieces than Astury's puzzle. So, the constraints will be of the form:
    t1 == PostageStamp and t2 == Astury => p1_to_int < p2_to_int, for all t1, t2 in pieces.

-   The jigsaw puzzle with the outer space theme has 250 more pieces than the puzzle made by Garroda:
    For this, we will need to add a constraint for each possible assignment of themes and pieces for the outer space theme and Garroda's puzzle, such that the outer space theme has 250 more pieces than Garroda's puzzle. So, the constraints will be of the form:
    t1 == OuterSpace and t2 == Garroda => p1_to_int == p2_to_int + 250, for all t1, t2 in pieces.

-   The jigsaw puzzle made by Garroda has somewhat fewer pieces than the puzzle made by Vesem:
    For this, we will need to add a constraint for each possible assignment of pieces for Garroda's and Vesem's puzzles, such that Garroda's puzzle has somewhat fewer pieces than Vesem's puzzle. So, the constraints will be of the form:
    p1 == Garroda and p2 == Vesem => p1_to_int < p2_to_int, for all p1, p2 in pieces.

-   The jigsaw puzzle with the postage stamp theme has somewhat more pieces than the puzzle with the city skyline theme:
    For this, we will need to add a constraint for each possible assignment of themes and pieces for the postage stamp and city skyline themes, such that the postage stamp theme has somewhat more pieces than the city skyline theme. So, the constraints will be of the form:
    t1 == PostageStamp and t2 == CitySkyline => p1_to_int > p2_to_int, for all t1, t2 in pieces.

-   The jigsaw puzzle made by Vesem has 500 pieces:
    This is a constraint that directly assigns the number of pieces to the puzzle made by Vesem:
    Vesem == Pieces500.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of company, pieces, and theme)
# e.g. if astury == 1 and pieces250 == 1 and autumnleaves == 1, then Astury made a 250-piece puzzle with an autumn leaves theme
astury, denlend, garroda, vesem = companies = intvar(1, 4, shape=4)
pieces250, pieces500, pieces750, pieces1000 = pieces = intvar(1, 4, shape=4)
autumnleaves, cityskyline, outerspace, postagestamp = themes = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
company_to_int = None  # N/A
pieces_to_int = {pieces250: 250, pieces500: 500, pieces750: 750, pieces1000: 1000}  # in pieces
theme_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def somewhat_fewer_than(var1, var2):
    """
    Formulate the constraint that var1 has somewhat fewer pieces than var2.
    """
    return [((t1 == var1) & (t2 == var2)).implies(pieces_to_int[p1] < pieces_to_int[p2])
            for t1 in themes for t2 in themes for p1 in pieces for p2 in pieces]


def somewhat_more_than(var1, var2):
    """
    Formulate the constraint that var1 has somewhat more pieces than var2.
    """
    return [((t1 == var1) & (t2 == var2)).implies(pieces_to_int[p1] > pieces_to_int[p2])
            for t1 in themes for t2 in themes for p1 in pieces for p2 in pieces]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(companies)
m += AllDifferent(pieces)
m += AllDifferent(themes)

# Clue 1: The puzzle with the postage stamp theme has somewhat fewer pieces than the puzzle made by Astury:
m += somewhat_fewer_than(postagestamp, astury)

# Clue 2: The jigsaw puzzle with the outer space theme has 250 more pieces than the puzzle made by Garroda:
m += [((t1 == outerspace) & (t2 == garroda)).implies(pieces_to_int[p1] == pieces_to_int[p2] + 250)
      for t1 in themes for t2 in themes for p1 in pieces for p2 in pieces]

# Clue 3: The jigsaw puzzle made by Garroda has somewhat fewer pieces than the puzzle made by Vesem:
m += [((c1 == garroda) & (c2 == vesem)).implies(pieces_to_int[p1] < pieces_to_int[p2])
      for c1 in companies for c2 in companies for p1 in pieces for p2 in pieces]

# Clue 4: The jigsaw puzzle with the postage stamp theme has somewhat more pieces than the puzzle with the city skyline theme:
m += somewhat_more_than(postagestamp, cityskyline)

# Clue 5: The jigsaw puzzle made by Vesem has 500 pieces:
m += vesem == pieces500

```
None
False
False
False
Wrong: 4, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The photo published by Nature Monthly was taken 2 months after the photo published by Earth Aware.
The shot of the white rhino was either the photo published by Earth Aware or the photo published by Animal Science.
The photo of the polar bear was taken sometime before the shot of the white rhino.
The photo taken in April was published by Animal Science.
The photo of the giant tortoise was taken in June.

Entities:
animals: giant tortoise, orangutan, polar bear, white rhino
months: March, April, May, June
magazines: Animal Science, Earth Aware, Nature Monthly, Wildzone
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if GiantTortoise == 1, and June == 1, and AnimalScience == 1, then the photo of the giant tortoise was taken in June and published by Animal Science.

### Decision variables:
-   Animals: GiantTortoise, Orangutan, PolarBear, WhiteRhino (all different, 1 to 4)
-   Months: March, April, May, June (all different, 1 to 4)
-   Magazines: AnimalScience, EarthAware, NatureMonthly, Wildzone (all different, 1 to 4)

### Constraints:
-   The photo published by Nature Monthly was taken 2 months after the photo published by Earth Aware:
    For this, we will need to add a constraint for each possible assignment of the months of the photos published by Nature Monthly and Earth Aware, such that the month of the Nature Monthly photo is 2 greater than the month of the Earth Aware photo. So, the constraints will be of the form:
    m1 == NatureMonthly and m2 == EarthAware => m1_to_int == m2_to_int + 2, for all m1, m2 in months.

-   The shot of the white rhino was either the photo published by Earth Aware or the photo published by Animal Science:
    This is a constraint that states that the white rhino photo was either published by Earth Aware or Animal Science, but not both. So:
    Xor([WhiteRhino == EarthAware, WhiteRhino == AnimalScience]).

-   The photo of the polar bear was taken sometime before the shot of the white rhino:
    For this, we will need to add a constraint for each possible assignment of the months of the photos of the polar bear and the white rhino, such that the month of the polar bear photo is less than the month of the white rhino photo. So, the constraints will be of the form:
    m1 == PolarBear and m2 == WhiteRhino => m1_to_int < m2_to_int, for all m1, m2 in months.

-   The photo taken in April was published by Animal Science:
    This is a constraint that states that the photo taken in April was published by Animal Science. So:
    April == AnimalScience.

-   The photo of the giant tortoise was taken in June:
    This is a constraint that states that the photo of the giant tortoise was taken in June. So:
    GiantTortoise == June.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if GiantTortoise == 1, and June == 1, and AnimalScience == 1, then the photo of the giant tortoise was taken in June and published by Animal Science.

### Decision variables:
-   Animals: GiantTortoise, Orangutan, PolarBear, WhiteRhino (all different, 1 to 4)
-   Months: March, April, May, June (all different, 1 to 4)
-   Magazines: AnimalScience, EarthAware, NatureMonthly, Wildzone (all different, 1 to 4)

### Constraints:
-   The photo published by Nature Monthly was taken 2 months after the photo published by Earth Aware:
    For this, we will need to add a constraint for each possible assignment of the months of the photos published by Nature Monthly and Earth Aware, such that the month of the Nature Monthly photo is 2 greater than the month of the Earth Aware photo. So, the constraints will be of the form:
    m1 == NatureMonthly and m2 == EarthAware => m1_to_int == m2_to_int + 2, for all m1, m2 in months.

-   The shot of the white rhino was either the photo published by Earth Aware or the photo published by Animal Science:
    This is a constraint that states that the white rhino photo was either published by Earth Aware or Animal Science, but not both. So:
    Xor([WhiteRhino == EarthAware, WhiteRhino == AnimalScience]).

-   The photo of the polar bear was taken sometime before the shot of the white rhino:
    For this, we will need to add a constraint for each possible assignment of the months of the photos of the polar bear and the white rhino, such that the month of the polar bear photo is less than the month of the white rhino photo. So, the constraints will be of the form:
    m1 == PolarBear and m2 == WhiteRhino => m1_to_int < m2_to_int, for all m1, m2 in months.

-   The photo taken in April was published by Animal Science:
    This is a constraint that states that the photo taken in April was published by Animal Science. So:
    April == AnimalScience.

-   The photo of the giant tortoise was taken in June:
    This is a constraint that states that the photo of the giant tortoise was taken in June. So:
    GiantTortoise == June.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of animal, month, and magazine)
# e.g. if giant_tortoise == 1 and june == 1 and animal_science == 1, then the photo of the giant tortoise was taken in June and published by Animal Science
giant_tortoise, orangutan, polar_bear, white_rhino = animals = intvar(1, 4, shape=4)
march, april, may, june = months = intvar(1, 4, shape=4)
animal_science, earth_aware, nature_monthly, wildzone = magazines = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
animal_to_int = None  # N/A
month_to_int = {march: 1, april: 2, may: 3, june: 4}  # in months
magazine_to_int = {animal_science: 1, earth_aware: 2, nature_monthly: 3, wildzone: 4}  # in magazines


# Helper functions (for formulating comparison constraints)
def taken_after(var1, var2, diff):
    """
    Formulate the constraint that var1 was taken diff months after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] == month_to_int[m2] + diff)
            for m1 in months for m2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(animals)
m += AllDifferent(months)
m += AllDifferent(magazines)

# Clue 1: The photo published by Nature Monthly was taken 2 months after the photo published by Earth Aware:
m += taken_after(nature_monthly, earth_aware, 2)

# Clue 2: The shot of the white rhino was either the photo published by Earth Aware or the photo published by Animal Science:
m += Xor([
    white_rhino == earth_aware,
    white_rhino == animal_science
])

# Clue 3: The photo of the polar bear was taken sometime before the shot of the white rhino:
m += taken_after(white_rhino, polar_bear, -1)

# Clue 4: The photo taken in April was published by Animal Science:
m += april == animal_science

# Clue 5: The photo of the giant tortoise was taken in June:
m += giant_tortoise == june

```
[['giant_tortoise', 'june', 'wildzone'], ['polar_bear', 'april', 'animal_science'], ['white_rhino', 'march', 'earth_aware'], ['orangutan', 'may', 'nature_monthly']]
False
False
False
Wrong: 1, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Oginao is either the 105 ft tall fall or the 115 ft tall waterfall.
Oginao is 5 ft shorter than Irskela.
The fall in Brazil is either Cerbel or Inawatai.
Inawatai is in New Zealand.
Cerbel is 10 ft shorter than the fall in Canada.

Entities:
names: Cerbel, Irskela, Inawatai, Oginao
heights: 100 ft, 105 ft, 110 ft, 115 ft
countries: Canada, Brazil, New Zealand, Switzerland
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Cerbel == 1, and Height100 == 1, and Canada == 1, then Cerbel is the 100 ft tall fall in Canada.

### Decision variables:
-   Names of the falls: Cerbel, Irskela, Inawatai, Oginao (all different, 1 to 4)
-   Heights of the falls: Height100, Height105, Height110, Height115 (all different, 1 to 4)
-   Countries of the falls: Canada, Brazil, New Zealand, Switzerland (all different, 1 to 4)

### Constraints:
-   Oginao is either the 105 ft tall fall or the 115 ft tall waterfall:
    This is a constraint that states that Oginao's height is either 105 ft or 115 ft, but not both. So:
    Xor([Oginao == Height105, Oginao == Height115]).

-   Oginao is 5 ft shorter than Irskela:
    For this, we will need to add a constraint for each possible assignment of heights to Oginao and Irskela, such that Oginao's height is 5 ft less than Irskela's height. So, the constraints will be of the form:
    h1 == Oginao and h2 == Irskela => h1_to_int == h2_to_int - 5, for all h1, h2 in heights.

-   The fall in Brazil is either Cerbel or Inawatai:
    This is a constraint that states that the fall in Brazil is either Cerbel or Inawatai, but not both. So:
    Xor([Cerbel == Brazil, Inawatai == Brazil]).

-   Inawatai is in New Zealand:
    This is a constraint that directly assigns Inawatai to New Zealand:
    Inawatai == New Zealand.

-   Cerbel is 10 ft shorter than the fall in Canada:
    For this, we will need to add a constraint for each possible assignment of heights to Cerbel and the fall in Canada, such that Cerbel's height is 10 ft less than the fall in Canada's height. So, the constraints will be of the form:
    h1 == Cerbel and h2 == Canada => h1_to_int == h2_to_int - 10, for all h1, h2 in heights.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Cerbel == 1, and Height100 == 1, and Canada == 1, then Cerbel is the 100 ft tall fall in Canada.

### Decision variables:
-   Names of the falls: Cerbel, Irskela, Inawatai, Oginao (all different, 1 to 4)
-   Heights of the falls: Height100, Height105, Height110, Height115 (all different, 1 to 4)
-   Countries of the falls: Canada, Brazil, New Zealand, Switzerland (all different, 1 to 4)

### Constraints:
-   Oginao is either the 105 ft tall fall or the 115 ft tall waterfall:
    This is a constraint that states that Oginao's height is either 105 ft or 115 ft, but not both. So:
    Xor([Oginao == Height105, Oginao == Height115]).

-   Oginao is 5 ft shorter than Irskela:
    For this, we will need to add a constraint for each possible assignment of heights to Oginao and Irskela, such that Oginao's height is 5 ft less than Irskela's height. So, the constraints will be of the form:
    h1 == Oginao and h2 == Irskela => h1_to_int == h2_to_int - 5, for all h1, h2 in heights.

-   The fall in Brazil is either Cerbel or Inawatai:
    This is a constraint that states that the fall in Brazil is either Cerbel or Inawatai, but not both. So:
    Xor([Cerbel == Brazil, Inawatai == Brazil]).

-   Inawatai is in New Zealand:
    This is a constraint that directly assigns Inawatai to New Zealand:
    Inawatai == New Zealand.

-   Cerbel is 10 ft shorter than the fall in Canada:
    For this, we will need to add a constraint for each possible assignment of heights to Cerbel and the fall in Canada, such that Cerbel's height is 10 ft less than the fall in Canada's height. So, the constraints will be of the form:
    h1 == Cerbel and h2 == Canada => h1_to_int == h2_to_int - 10, for all h1, h2 in heights.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of fall, height, and country)
# e.g. if cerbel == 1 and height100 == 1 and canada == 1, then Cerbel is the 100 ft tall fall in Canada
cerbel, irskela, inawatai, oginao = falls = intvar(1, 4, shape=4)
height100, height105, height110, height115 = heights = intvar(1, 4, shape=4)
canada, brazil, new_zealand, switzerland = countries = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
fall_to_int = None  # N/A
height_to_int = {height100: 100, height105: 105, height110: 110, height115: 115}  # in ft
country_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def shorter_than(var1, var2, diff):
    """
    Formulate the constraint that var1 is diff ft shorter than var2.
    """
    return [((h1 == var1) & (h2 == var2)).implies(height_to_int[h1] == height_to_int[h2] - diff)
            for h1 in heights for h2 in heights]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(falls)
m += AllDifferent(heights)
m += AllDifferent(countries)

# Clue 1: Oginao is either the 105 ft tall fall or the 115 ft tall waterfall:
m += Xor([
    oginao == height105,
    oginao == height115
])

# Clue 2: Oginao is 5 ft shorter than Irskela:
m += shorter_than(oginao, irskela, 5)

# Clue 3: The fall in Brazil is either Cerbel or Inawatai:
m += Xor([
    cerbel == brazil,
    inawatai == brazil
])

# Clue 4: Inawatai is in New Zealand:
m += inawatai == new_zealand

# Clue 5: Cerbel is 10 ft shorter than the fall in Canada:
m += shorter_than(cerbel, canada, 10)

```
[['oginao', 'height105', 'switzerland'], ['irskela', 'height110', 'canada'], ['cerbel', 'height100', 'brazil'], ['inawatai', 'height115', 'new_zealand']]
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The 90 million year old fossil costs 250 dollars more than the pilodontus.
The gigasaurus costs 500 dollars more than the 78 million year old fossil.
The gigasaurus costs 250 dollars less than the 75 million year old fossil.
The mirasaurus is 90 million years old.

Entities:
dinosaurs: gigasaurus, mirasaurus, pilodontus, rotosaurus
prices: $500, $750, $1000, $1250
ages: 72 million, 75 million, 78 million, 90 million
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Gigasaurus == 1, and Price500 == 1, and Age72 == 1, then Gigasaurus costs $500 and is 72 million years old.

### Decision variables:
-   Names of the dinosaurs: Gigasaurus, Mirasaurus, Pilodontus, Rotosaurus (all different, 1 to 4)
-   Prices of the dinosaurs: Price500, Price750, Price1000, Price1250 (all different, 1 to 4)
-   Ages of the dinosaurs: Age72, Age75, Age78, Age90 (all different, 1 to 4)

### Constraints:
-   The 90 million year old fossil costs 250 dollars more than the Pilodontus:
    For this, we will need to add a constraint for each possible assignment of prices to the 90 million year old fossil and the Pilodontus, such that the 90 million year old fossil's price is 250 dollars more than the Pilodontus' price. So, the constraints will be of the form:
    p1 == Age90 and p2 == Pilodontus => p1_to_int == p2_to_int + 250, for all p1, p2 in prices.

-   The Gigasaurus costs 500 dollars more than the 78 million year old fossil:
    For this, we will need to add a constraint for each possible assignment of prices to the Gigasaurus and the 78 million year old fossil, such that the Gigasaurus' price is 500 dollars more than the 78 million year old fossil's price. So, the constraints will be of the form:
    p1 == Gigasaurus and p2 == Age78 => p1_to_int == p2_to_int + 500, for all p1, p2 in prices.

-   The Gigasaurus costs 250 dollars less than the 75 million year old fossil:
    For this, we will need to add a constraint for each possible assignment of prices to the Gigasaurus and the 75 million year old fossil, such that the Gigasaurus' price is 250 dollars less than the 75 million year old fossil's price. So, the constraints will be of the form:
    p1 == Gigasaurus and p2 == Age75 => p1_to_int == p2_to_int - 250, for all p1, p2 in prices.

-   The Mirasaurus is 90 million years old:
    This is a constraint that directly assigns the Mirasaurus to be 90 million years old:
    Mirasaurus == Age90.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Gigasaurus == 1, and Price500 == 1, and Age72 == 1, then Gigasaurus costs $500 and is 72 million years old.

### Decision variables:
-   Names of the dinosaurs: Gigasaurus, Mirasaurus, Pilodontus, Rotosaurus (all different, 1 to 4)
-   Prices of the dinosaurs: Price500, Price750, Price1000, Price1250 (all different, 1 to 4)
-   Ages of the dinosaurs: Age72, Age75, Age78, Age90 (all different, 1 to 4)

### Constraints:
-   The 90 million year old fossil costs 250 dollars more than the Pilodontus:
    For this, we will need to add a constraint for each possible assignment of prices to the 90 million year old fossil and the Pilodontus, such that the 90 million year old fossil's price is 250 dollars more than the Pilodontus' price. So, the constraints will be of the form:
    p1 == Age90 and p2 == Pilodontus => p1_to_int == p2_to_int + 250, for all p1, p2 in prices.

-   The Gigasaurus costs 500 dollars more than the 78 million year old fossil:
    For this, we will need to add a constraint for each possible assignment of prices to the Gigasaurus and the 78 million year old fossil, such that the Gigasaurus' price is 500 dollars more than the 78 million year old fossil's price. So, the constraints will be of the form:
    p1 == Gigasaurus and p2 == Age78 => p1_to_int == p2_to_int + 500, for all p1, p2 in prices.

-   The Gigasaurus costs 250 dollars less than the 75 million year old fossil:
    For this, we will need to add a constraint for each possible assignment of prices to the Gigasaurus and the 75 million year old fossil, such that the Gigasaurus' price is 250 dollars less than the 75 million year old fossil's price. So, the constraints will be of the form:
    p1 == Gigasaurus and p2 == Age75 => p1_to_int == p2_to_int - 250, for all p1, p2 in prices.

-   The Mirasaurus is 90 million years old:
    This is a constraint that directly assigns the Mirasaurus to be 90 million years old:
    Mirasaurus == Age90.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of dinosaur, price, and age)
# e.g. if gigasaurus == 1 and price500 == 1 and age72 == 1, then Gigasaurus costs $500 and is 72 million years old
gigasaurus, mirasaurus, pilodontus, rotosaurus = dinosaurs = intvar(1, 4, shape=4)
price500, price750, price1000, price1250 = prices = intvar(1, 4, shape=4)
age72, age75, age78, age90 = ages = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
dinosaur_to_int = None  # N/A
price_to_int = {price500: 500, price750: 750, price1000: 1000, price1250: 1250}  # in dollars
age_to_int = {age72: 72, age75: 75, age78: 78, age90: 90}  # in million years


# Helper functions (for formulating comparison constraints)
def cost_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 costs diff dollars more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] + diff)
            for p1 in prices for p2 in prices]


def cost_less_than(var1, var2, diff):
    """
    Formulate the constraint that var1 costs diff dollars less than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] - diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(dinosaurs)
m += AllDifferent(prices)
m += AllDifferent(ages)

# Clue 1: The 90 million year old fossil costs 250 dollars more than the Pilodontus:
m += cost_more_than(age90, pilodontus, 250)

# Clue 2: The Gigasaurus costs 500 dollars more than the 78 million year old fossil:
m += cost_more_than(gigasaurus, age78, 500)

# Clue 3: The Gigasaurus costs 250 dollars less than the 75 million year old fossil:
m += cost_less_than(gigasaurus, age75, 250)

# Clue 4: The Mirasaurus is 90 million years old:
m += mirasaurus == age90

```
[['mirasaurus', 'price750', 'age90'], ['gigasaurus', 'price1000', 'age72'], ['pilodontus', 'price500', 'age78'], ['rotosaurus', 'price1250', 'age75']]
True
True
True
Wrong: 0, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The four conductors are Roderick, the conductor working on June 10, the person departing from Leland and the person departing from Indio.
The person working on June 13 will depart from Hardwick.
The conductor working on June 12 is either the conductor departing from Indio or Roderick.
Vernon is either the person working on June 11 or the conductor working on June 13.
Francis will leave sometime before the conductor departing from Leland.

Entities:
names: Francis, Luke, Roderick, Vernon
days: June 10, June 11, June 12, June 13
departures: Hardwick, Indio, Kent, Leland
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Francis == 1, and June10 == 1, and Leland == 1, then Francis is the person working on June 10 departing from Leland.

### Decision variables:
-   Names of the conductors: Francis, Luke, Roderick, Vernon (all different, 1 to 4)
-   Days of work: June 10, June 11, June 12, June 13 (all different, 1 to 4)
-   Departure locations: Hardwick, Indio, Kent, Leland (all different, 1 to 4)

### Constraints:
-   The four conductors are Roderick, the conductor working on June 10, the person departing from Leland, and the person departing from Indio:
    This constraint ensures that each of the mentioned entities corresponds to a different conductor. So, we have:
    AllDifferent([Roderick, June10, Leland, Indio]).

-   The person working on June 13 will depart from Hardwick:
    This constraint states that the person working on June 13 will depart from Hardwick. So, we have:
    June13 == Hardwick.

-   The conductor working on June 12 is either the conductor departing from Indio or Roderick:
    This constraint states that the conductor working on June 12 is either the conductor departing from Indio or Roderick, but not both. So, we have:
    Xor([June12 == Indio, June12 == Roderick]).

-   Vernon is either the person working on June 11 or the conductor working on June 13:
    This constraint states that Vernon is either the person working on June 11 or the conductor working on June 13, but not both. So, we have:
    Xor([Vernon == June11, Vernon == June13]).

-   Francis will leave sometime before the conductor departing from Leland:
    This constraint ensures that Francis will leave before the conductor departing from Leland. So, we have:
    Francis_to_int < Leland_to_int.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Francis == 1, and June10 == 1, and Leland == 1, then Francis is the person working on June 10 departing from Leland.

### Decision variables:
-   Names of the conductors: Francis, Luke, Roderick, Vernon (all different, 1 to 4)
-   Days of work: June 10, June 11, June 12, June 13 (all different, 1 to 4)
-   Departure locations: Hardwick, Indio, Kent, Leland (all different, 1 to 4)

### Constraints:
-   The four conductors are Roderick, the conductor working on June 10, the person departing from Leland, and the person departing from Indio:
    This constraint ensures that each of the mentioned entities corresponds to a different conductor. So, we have:
    AllDifferent([Roderick, June10, Leland, Indio]).

-   The person working on June 13 will depart from Hardwick:
    This constraint states that the person working on June 13 will depart from Hardwick. So, we have:
    June13 == Hardwick.

-   The conductor working on June 12 is either the conductor departing from Indio or Roderick:
    This constraint states that the conductor working on June 12 is either the conductor departing from Indio or Roderick, but not both. So, we have:
    Xor([June12 == Indio, June12 == Roderick]).

-   Vernon is either the person working on June 11 or the conductor working on June 13:
    This constraint states that Vernon is either the person working on June 11 or the conductor working on June 13, but not both. So, we have:
    Xor([Vernon == June11, Vernon == June13]).

-   Francis will leave sometime before the conductor departing from Leland:
    This constraint ensures that Francis will leave before the conductor departing from Leland. So, we have:
    Francis_to_int < Leland_to_int.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of conductor, day, and departure)
# e.g. if francis == 1 and june10 == 1 and leland == 1, then Francis will work on June 10 departing from Leland
francis, luke, roderick, vernon = conductors = intvar(1, 4, shape=4)
june10, june11, june12, june13 = days = intvar(1, 4, shape=4)
hardwick, indio, kent, leland = departures = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
conductor_to_int = None  # N/A
day_to_int = {june10: 10, june11: 11, june12: 12, june13: 13}  # in days
departure_to_int = {hardwick: 1, indio: 2, kent: 3, leland: 4}  # in order


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(conductors)
m += AllDifferent(days)
m += AllDifferent(departures)

# Clue 1: The four conductors are Roderick, the conductor working on June 10, the person departing from Leland, and the person departing from Indio:
m += AllDifferent([roderick, june10, leland, indio])

# Clue 2: The person working on June 13 will depart from Hardwick:
m += june13 == hardwick

# Clue 3: The conductor working on June 12 is either the conductor departing from Indio or Roderick:
m += Xor([
    june12 == indio,
    june12 == roderick
])

# Clue 4: Vernon is either the person working on June 11 or the conductor working on June 13:
m += Xor([
    vernon == june11,
    vernon == june13
])

# Clue 5: Francis will leave sometime before the conductor departing from Leland:
m += francis < leland

```
[['francis', 'june12', 'indio'], ['vernon', 'june11', 'leland'], ['roderick', 'june13', 'hardwick'], ['luke', 'june10', 'kent']]
False
True
False
Wrong: 1, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The Kia rental is for a period 1 day shorter than the Toyota rental.
The 4 day rental is for the Fiat.
Kathy Koch's reservation is either the 5 day reservation or the Fiat rental.
The 3 day rental, Irene Ingram's reservation and Kathy Koch's reservation are all different rentals.
Ann Alexander's rental is for 4 days.

Entities:
customers: Ann Alexander, Edna Erickson, Irene Ingram, Kathy Koch
contract length: 2 days, 3 days, 4 days, 5 days
cars: Fiat, Kia, Nissan, Toyota
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ann Alexander == 1, and Day4 == 1, and Fiat == 1, then Ann Alexander rented a Fiat for 4 days.

### Decision variables:
-   Names of the customers: Ann Alexander, Edna Erickson, Irene Ingram, Kathy Koch (all different, 1 to 4)
-   Rental durations: Day2, Day3, Day4, Day5 (all different, 1 to 4)
-   Car rentals: Fiat, Kia, Nissan, Toyota (all different, 1 to 4)

### Constraints:
-   The Kia rental is for a period 1 day shorter than the Toyota rental:
    For this, we will need to add a constraint for each possible assignment of rental durations for Kia and Toyota, such that Kia's rental duration is 1 less than Toyota's rental duration. So, the constraints will be of the form:
    d1 == Kia and d2 == Toyota => d1_to_int == d2_to_int - 1, for all d1, d2 in rental durations.

-   The 4-day rental is for the Fiat:
    This is a constraint that states that the Fiat rental is for 4 days. So:
    Fiat == Day4.

-   Kathy Koch's reservation is either the 5-day reservation or the Fiat rental:
    This is a constraint that states that Kathy Koch's reservation is either for 5 days or a Fiat rental, but not both. So:
    Xor([Kathy Koch == Day5, Kathy Koch == Fiat]).

-   The 3-day rental, Irene Ingram's reservation, and Kathy Koch's reservation are all different rentals:
    This is a constraint that states that all these entities are different, thus:
    AllDifferent([Day3, Irene Ingram, Kathy Koch]).

-   Ann Alexander's rental is for 4 days:
    This is a constraint that states that Ann Alexander's rental is for 4 days. So:
    Ann Alexander == Day4.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ann Alexander == 1, and Day4 == 1, and Fiat == 1, then Ann Alexander rented a Fiat for 4 days.

### Decision variables:
-   Names of the customers: Ann Alexander, Edna Erickson, Irene Ingram, Kathy Koch (all different, 1 to 4)
-   Rental durations: Day2, Day3, Day4, Day5 (all different, 1 to 4)
-   Car rentals: Fiat, Kia, Nissan, Toyota (all different, 1 to 4)

### Constraints:
-   The Kia rental is for a period 1 day shorter than the Toyota rental:
    For this, we will need to add a constraint for each possible assignment of rental durations for Kia and Toyota, such that Kia's rental duration is 1 less than Toyota's rental duration. So, the constraints will be of the form:
    d1 == Kia and d2 == Toyota => d1_to_int == d2_to_int - 1, for all d1, d2 in rental durations.

-   The 4-day rental is for the Fiat:
    This is a constraint that states that the Fiat rental is for 4 days. So:
    Fiat == Day4.

-   Kathy Koch's reservation is either the 5-day reservation or the Fiat rental:
    This is a constraint that states that Kathy Koch's reservation is either for 5 days or a Fiat rental, but not both. So:
    Xor([Kathy Koch == Day5, Kathy Koch == Fiat]).

-   The 3-day rental, Irene Ingram's reservation, and Kathy Koch's reservation are all different rentals:
    This is a constraint that states that all these entities are different, thus:
    AllDifferent([Day3, Irene Ingram, Kathy Koch]).

-   Ann Alexander's rental is for 4 days:
    This is a constraint that states that Ann Alexander's rental is for 4 days. So:
    Ann Alexander == Day4.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of customer, duration, and car)
# e.g. if ann == 1 and day4 == 1 and fiat == 1, then Ann Alexander rented a Fiat for 4 days
ann, edna, irene, kathy = customers = intvar(1, 4, shape=4)
day2, day3, day4, day5 = durations = intvar(1, 4, shape=4)
fiat, kia, nissan, toyota = cars = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
customer_to_int = None  # N/A
duration_to_int = {day2: 2, day3: 3, day4: 4, day5: 5}  # in days
car_to_int = {fiat: 1, kia: 2, nissan: 3, toyota: 4}  # in order


# Helper functions (for formulating comparison constraints)
def shorter_by_one_day(var1, var2):
    """
    Formulate the constraint that var1 is shorter by one day than var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(duration_to_int[d1] == duration_to_int[d2] - 1)
            for d1 in durations for d2 in durations]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(customers)
m += AllDifferent(durations)
m += AllDifferent(cars)

# Clue 1: The Kia rental is for a period 1 day shorter than the Toyota rental:
m += shorter_by_one_day(kia, toyota)

# Clue 2: The 4-day rental is for the Fiat:
m += fiat == day4

# Clue 3: Kathy Koch's reservation is either the 5-day reservation or the Fiat rental:
m += Xor([
    kathy == day5,
    kathy == fiat
])

# Clue 4: The 3-day rental, Irene Ingram's reservation, and Kathy Koch's reservation are all different rentals:
m += AllDifferent([day3, irene, kathy])

# Clue 5: Ann Alexander's rental is for 4 days:
m += ann == day4

```
[['kathy', 'day5', 'nissan'], ['irene', 'day2', 'kia'], ['ann', 'day4', 'fiat'], ['edna', 'day3', 'toyota']]
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The person with 72 LinkedIn connections has 10 fewer Facebook friends than the person with 84 LinkedIn connections.
Yvonne has 20 fewer Facebook friends than Margie.
The four people are the one with 68 LinkedIn connections, Jonathan, Rosie and the person with 120 Facebook friends.
Rosie has 150 Facebook friends.

Entities:
Facebook: 120, 130, 140, 150
LinkedIn: 57, 68, 72, 84
names: Jonathan, Margie, Rosie, Yvonne
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Jonathan == 1, and LinkedIn68 == 1, and Facebook120 == 1, then Jonathan has 68 LinkedIn connections and 120 Facebook friends.

### Decision variables:
-   Names of the people: Jonathan, Margie, Rosie, Yvonne (all different, 1 to 4)
-   Number of LinkedIn connections: LinkedIn57, LinkedIn68, LinkedIn72, LinkedIn84 (all different, 1 to 4)
-   Number of Facebook friends: Facebook120, Facebook130, Facebook140, Facebook150 (all different, 1 to 4)

### Constraints:
-   The person with 72 LinkedIn connections has 10 fewer Facebook friends than the person with 84 LinkedIn connections:
    For this, we will need to add a constraint for each possible assignment of LinkedIn connections to 72 and 84, such that the person with 72 LinkedIn connections has 10 fewer Facebook friends than the person with 84 LinkedIn connections. So, the constraints will be of the form:
    l1 == LinkedIn72 and l2 == LinkedIn84 => f1_to_int == f2_to_int - 10, for all l1, l2 in LinkedIn connections.

-   Yvonne has 20 fewer Facebook friends than Margie:
    For this, we will need to add a constraint for each possible assignment of Facebook friends to Yvonne and Margie, such that Yvonne has 20 fewer Facebook friends than Margie. So, the constraints will be of the form:
    f1 == Yvonne and f2 == Margie => f1_to_int == f2_to_int - 20, for all f1, f2 in Facebook friends.

-   The four people are the one with 68 LinkedIn connections, Jonathan, Rosie, and the person with 120 Facebook friends:
    This is a constraint that states that the four people are the one with 68 LinkedIn connections, Jonathan, Rosie, and the person with 120 Facebook friends. So, we will have:
    AllDifferent([LinkedIn68, Jonathan, Rosie, Facebook120]).

-   Rosie has 150 Facebook friends:
    This is a constraint that states Rosie has 150 Facebook friends. So, we will have:
    Rosie == Facebook150.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Jonathan == 1, and LinkedIn68 == 1, and Facebook120 == 1, then Jonathan has 68 LinkedIn connections and 120 Facebook friends.

### Decision variables:
-   Names of the people: Jonathan, Margie, Rosie, Yvonne (all different, 1 to 4)
-   Number of LinkedIn connections: LinkedIn57, LinkedIn68, LinkedIn72, LinkedIn84 (all different, 1 to 4)
-   Number of Facebook friends: Facebook120, Facebook130, Facebook140, Facebook150 (all different, 1 to 4)

### Constraints:
-   The person with 72 LinkedIn connections has 10 fewer Facebook friends than the person with 84 LinkedIn connections:
    For this, we will need to add a constraint for each possible assignment of LinkedIn connections to 72 and 84, such that the person with 72 LinkedIn connections has 10 fewer Facebook friends than the person with 84 LinkedIn connections. So, the constraints will be of the form:
    l1 == LinkedIn72 and l2 == LinkedIn84 => f1_to_int == f2_to_int - 10, for all l1, l2 in LinkedIn connections.

-   Yvonne has 20 fewer Facebook friends than Margie:
    For this, we will need to add a constraint for each possible assignment of Facebook friends to Yvonne and Margie, such that Yvonne has 20 fewer Facebook friends than Margie. So, the constraints will be of the form:
    f1 == Yvonne and f2 == Margie => f1_to_int == f2_to_int - 20, for all f1, f2 in Facebook friends.

-   The four people are the one with 68 LinkedIn connections, Jonathan, Rosie, and the person with 120 Facebook friends:
    This is a constraint that states that the four people are the one with 68 LinkedIn connections, Jonathan, Rosie, and the person with 120 Facebook friends. So, we will have:
    AllDifferent([LinkedIn68, Jonathan, Rosie, Facebook120]).

-   Rosie has 150 Facebook friends:
    This is a constraint that states Rosie has 150 Facebook friends. So, we will have:
    Rosie == Facebook150.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of person, LinkedIn connections, and Facebook friends)
# e.g. if jonathan == 1 and linkedin68 == 1 and facebook120 == 1, then Jonathan has 68 LinkedIn connections and 120 Facebook friends
jonathan, margie, rosie, yvonne = people = intvar(1, 4, shape=4)
linkedin57, linkedin68, linkedin72, linkedin84 = linkedin = intvar(1, 4, shape=4)
facebook120, facebook130, facebook140, facebook150 = facebook = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
person_to_int = None  # N/A
linkedin_to_int = {linkedin57: 57, linkedin68: 68, linkedin72: 72, linkedin84: 84}  # in connections
facebook_to_int = {facebook120: 120, facebook130: 130, facebook140: 140, facebook150: 150}  # in friends


# Helper functions (for formulating comparison constraints)
def fewer_friends(var1, var2, diff):
    """
    Formulate the constraint that var1 has diff fewer friends than var2.
    """
    return [((f1 == var1) & (f2 == var2)).implies(facebook_to_int[f1] == facebook_to_int[f2] - diff)
            for f1 in facebook for f2 in facebook]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(people)
m += AllDifferent(linkedin)
m += AllDifferent(facebook)

# Clue 1: The person with 72 LinkedIn connections has 10 fewer Facebook friends than the person with 84 LinkedIn connections:
m += fewer_friends(linkedin72, linkedin84, 10)

# Clue 2: Yvonne has 20 fewer Facebook friends than Margie:
m += fewer_friends(yvonne, margie, 20)

# Clue 3: The four people are the one with 68 LinkedIn connections, Jonathan, Rosie, and the person with 120 Facebook friends:
m += AllDifferent([linkedin68, jonathan, rosie, facebook120])

# Clue 4: Rosie has 150 Facebook friends:
m += rosie == facebook150

```
[['margie', 'linkedin68', 'facebook140'], ['jonathan', 'linkedin84', 'facebook130'], ['rosie', 'linkedin57', 'facebook150'], ['yvonne', 'linkedin72', 'facebook120']]
True
True
True
Wrong: 0, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The photo taken in April was published by Wildzone.
The shot of the giant tortoise was taken 1 month before the photo published by Science World.
The photo of the orangutan was published by The Geographer.
The photo of the snow leopard was taken 2 months after the photo published by The Geographer.

Entities:
animals: giant tortoise, orangutan, snow leopard, tree kangaroo
months: March, April, May, June
magazines: Earth Aware, Science World, The Geographer, Wildzone
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if GiantTortoise == 1, and March == 1, and EarthAware == 1, then the photo of the giant tortoise was taken in March and published by Earth Aware.

### Decision variables:
-   Animals: Giant Tortoise, Orangutan, Snow Leopard, Tree Kangaroo (all different, 1 to 4)
-   Months: March, April, May, June (all different, 1 to 4)
-   Magazines: Earth Aware, Science World, The Geographer, Wildzone (all different, 1 to 4)

### Constraints:
-   The photo taken in April was published by Wildzone:
    For this, we will need to add a constraint for the assignment of the month and magazine, such that the photo taken in April is published by Wildzone. So, the constraint will be:
    April == Wildzone.

-   The shot of the giant tortoise was taken 1 month before the photo published by Science World:
    For this, we will need to add a constraint for each possible assignment of the month of the giant tortoise photo and the magazine of the Science World photo, such that the giant tortoise photo is taken 1 month before the Science World photo. So, the constraints will be of the form:
    m1 == GiantTortoise and m2 == ScienceWorld => m1_to_int == m2_to_int - 1, for all m1, m2 in months.

-   The photo of the orangutan was published by The Geographer:
    This is a constraint that states that the photo of the orangutan is published by The Geographer. So:
    Orangutan == TheGeographer.

-   The photo of the snow leopard was taken 2 months after the photo published by The Geographer:
    For this, we will need to add a constraint for each possible assignment of the month of the snow leopard photo and the magazine of The Geographer photo, such that the snow leopard photo is taken 2 months after The Geographer photo. So, the constraints will be of the form:
    m1 == SnowLeopard and m2 == TheGeographer => m1_to_int == m2_to_int + 2, for all m1, m2 in months.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if GiantTortoise == 1, and March == 1, and EarthAware == 1, then the photo of the giant tortoise was taken in March and published by Earth Aware.

### Decision variables:
-   Animals: Giant Tortoise, Orangutan, Snow Leopard, Tree Kangaroo (all different, 1 to 4)
-   Months: March, April, May, June (all different, 1 to 4)
-   Magazines: Earth Aware, Science World, The Geographer, Wildzone (all different, 1 to 4)

### Constraints:
-   The photo taken in April was published by Wildzone:
    For this, we will need to add a constraint for the assignment of the month and magazine, such that the photo taken in April is published by Wildzone. So, the constraint will be:
    April == Wildzone.

-   The shot of the giant tortoise was taken 1 month before the photo published by Science World:
    For this, we will need to add a constraint for each possible assignment of the month of the giant tortoise photo and the magazine of the Science World photo, such that the giant tortoise photo is taken 1 month before the Science World photo. So, the constraints will be of the form:
    m1 == GiantTortoise and m2 == ScienceWorld => m1_to_int == m2_to_int - 1, for all m1, m2 in months.

-   The photo of the orangutan was published by The Geographer:
    This is a constraint that states that the photo of the orangutan is published by The Geographer. So:
    Orangutan == TheGeographer.

-   The photo of the snow leopard was taken 2 months after the photo published by The Geographer:
    For this, we will need to add a constraint for each possible assignment of the month of the snow leopard photo and the magazine of The Geographer photo, such that the snow leopard photo is taken 2 months after The Geographer photo. So, the constraints will be of the form:
    m1 == SnowLeopard and m2 == TheGeographer => m1_to_int == m2_to_int + 2, for all m1, m2 in months.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of animal, month, and magazine)
# e.g. if giant_tortoise == 1 and march == 1 and earth_aware == 1, then the photo of the giant tortoise was taken in March and published by Earth Aware
giant_tortoise, orangutan, snow_leopard, tree_kangaroo = animals = intvar(1, 4, shape=4)
march, april, may, june = months = intvar(1, 4, shape=4)
earth_aware, science_world, the_geographer, wildzone = magazines = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
animal_to_int = None  # N/A
month_to_int = {march: 1, april: 2, may: 3, june: 4}  # in months
magazine_to_int = {earth_aware: 1, science_world: 2, the_geographer: 3, wildzone: 4}  # in magazines


# Helper functions (for formulating comparison constraints)
def taken_before_than(var1, var2):
    """
    Formulate the constraint that var1 was taken before var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] < month_to_int[m2])
            for m1 in months for m2 in months]


def taken_exactly_before_than(var1, var2, diff):
    """
    Formulate the constraint that var1 was taken exactly diff months before var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] == month_to_int[m2] - diff)
            for m1 in months for m2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(animals)
m += AllDifferent(months)
m += AllDifferent(magazines)

# Clue 1: The photo taken in April was published by Wildzone:
m += april == wildzone

# Clue 2: The shot of the giant tortoise was taken 1 month before the photo published by Science World:
m += taken_exactly_before_than(giant_tortoise, science_world, 1)

# Clue 3: The photo of the orangutan was published by The Geographer:
m += orangutan == the_geographer

# Clue 4: The photo of the snow leopard was taken 2 months after the photo published by The Geographer:
m += taken_exactly_before_than(snow_leopard, the_geographer, -2)

```
[['snow_leopard', 'may', 'science_world'], ['orangutan', 'march', 'the_geographer'], ['giant_tortoise', 'april', 'wildzone'], ['tree_kangaroo', 'june', 'earth_aware']]
True
True
True
Wrong: 0, Total: 7
---------------------------------------------------------------------------------------------

Clues:
Henrietta's job is either the chore that starts at 9:00am or the chore that starts at 8:00am.
Jack's task is either the job that starts at 8:00am or the living room assignment.
Jack's job starts at 10:00am.
Kay's chore starts at 8:00am.
Jack's assignment starts 2 hours after the mud room assignment.
The laundry room assignment, the chore that starts at 8:00am and the chore that starts at 11:00am are all different jobs.

Entities:
children: Henrietta, Jack, Kay, Zachary
times: 8:00am, 9:00am, 10:00am, 11:00am
rooms: dining room, laundry room, living room, mud room
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Henrietta == 1, and Time9am == 1, and DiningRoom == 1, then Henrietta's chore starts at 9:00am in the dining room.

### Decision variables:
-   Names of the children: Henrietta, Jack, Kay, Zachary (all different, 1 to 4)
-   Start times of chores: Time8am, Time9am, Time10am, Time11am (all different, 1 to 4)
-   Rooms for assignments: DiningRoom, LaundryRoom, LivingRoom, MudRoom (all different, 1 to 4)

### Constraints:
-   Henrietta's job is either the chore that starts at 9:00am or the chore that starts at 8:00am:
    This is a constraint that states that Henrietta's chore starts at either 9:00am or 8:00am, but not both. So:
    Xor([Henrietta == Time9am, Henrietta == Time8am]).

-   Jack's task is either the job that starts at 8:00am or the living room assignment:
    This is a constraint that states that Jack's chore starts at either 8:00am or in the living room, but not both. So:
    Xor([Jack == Time8am, Jack == LivingRoom]).

-   Jack's job starts at 10:00am:
    This is a constraint that directly assigns Jack's chore to start at 10:00am:
    Jack == Time10am.

-   Kay's chore starts at 8:00am:
    This is a constraint that directly assigns Kay's chore to start at 8:00am:
    Kay == Time8am.

-   Jack's assignment starts 2 hours after the mud room assignment:
    For this, we will need to add a constraint for each possible assignment of the start times for Jack's assignment and the mud room assignment, such that Jack's start time is 2 hours after the mud room start time. So, the constraints will be of the form:
    t1 == Jack and t2 == MudRoom => t1_to_int == t2_to_int + 2, for all t1, t2 in start times.

-   The laundry room assignment, the chore that starts at 8:00am, and the chore that starts at 11:00am are all different jobs:
    This is a constraint that states that the laundry room assignment, the chore starting at 8:00am, and the chore starting at 11:00am are all different. So:
    AllDifferent([LaundryRoom, Time8am, Time11am]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Henrietta == 1, and Time9am == 1, and DiningRoom == 1, then Henrietta's chore starts at 9:00am in the dining room.

### Decision variables:
-   Names of the children: Henrietta, Jack, Kay, Zachary (all different, 1 to 4)
-   Start times of chores: Time8am, Time9am, Time10am, Time11am (all different, 1 to 4)
-   Rooms for assignments: DiningRoom, LaundryRoom, LivingRoom, MudRoom (all different, 1 to 4)

### Constraints:
-   Henrietta's job is either the chore that starts at 9:00am or the chore that starts at 8:00am:
    This is a constraint that states that Henrietta's chore starts at either 9:00am or 8:00am, but not both. So:
    Xor([Henrietta == Time9am, Henrietta == Time8am]).

-   Jack's task is either the job that starts at 8:00am or the living room assignment:
    This is a constraint that states that Jack's chore starts at either 8:00am or in the living room, but not both. So:
    Xor([Jack == Time8am, Jack == LivingRoom]).

-   Jack's job starts at 10:00am:
    This is a constraint that directly assigns Jack's chore to start at 10:00am:
    Jack == Time10am.

-   Kay's chore starts at 8:00am:
    This is a constraint that directly assigns Kay's chore to start at 8:00am:
    Kay == Time8am.

-   Jack's assignment starts 2 hours after the mud room assignment:
    For this, we will need to add a constraint for each possible assignment of the start times for Jack's assignment and the mud room assignment, such that Jack's start time is 2 hours after the mud room start time. So, the constraints will be of the form:
    t1 == Jack and t2 == MudRoom => t1_to_int == t2_to_int + 2, for all t1, t2 in start times.

-   The laundry room assignment, the chore that starts at 8:00am, and the chore that starts at 11:00am are all different jobs:
    This is a constraint that states that the laundry room assignment, the chore starting at 8:00am, and the chore starting at 11:00am are all different. So:
    AllDifferent([LaundryRoom, Time8am, Time11am]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of child, time, and room)
# e.g. if henrietta == 1 and time9am == 1 and diningroom == 1, then Henrietta's chore starts at 9:00am in the dining room
henrietta, jack, kay, zachary = children = intvar(1, 4, shape=4)
time8am, time9am, time10am, time11am = times = intvar(1, 4, shape=4)
diningroom, laundryroom, livingroom, mudroom = rooms = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
child_to_int = None  # N/A
time_to_int = {time8am: 8, time9am: 9, time10am: 10, time11am: 11}  # in hours
room_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def starts_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 starts exactly diff hours after var2.
    """
    return [((t1 == var1) & (t2 == var2)).implies(time_to_int[t1] == time_to_int[t2] + diff)
            for t1 in times for t2 in times]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(children)
m += AllDifferent(times)
m += AllDifferent(rooms)

# Clue 1: Henrietta's job is either the chore that starts at 9:00am or the chore that starts at 8:00am:
m += Xor([
    henrietta == time9am,
    henrietta == time8am
])

# Clue 2: Jack's task is either the job that starts at 8:00am or the living room assignment:
m += Xor([
    jack == time8am,
    jack == livingroom
])

# Clue 3: Jack's job starts at 10:00am:
m += jack == time10am

# Clue 4: Kay's chore starts at 8:00am:
m += kay == time8am

# Clue 5: Jack's assignment starts 2 hours after the mud room assignment:
m += starts_after_than(jack, mudroom, 2)

# Clue 6: The laundry room assignment, the chore that starts at 8:00am, and the chore that starts at 11:00am are all different jobs:
m += AllDifferent([laundryroom, time8am, time11am])

```
[['kay', 'time8am', 'mudroom'], ['jack', 'time10am', 'livingroom'], ['zachary', 'time11am', 'diningroom'], ['henrietta', 'time9am', 'laundryroom']]
True
True
True
Wrong: 0, Total: 9
---------------------------------------------------------------------------------------------

Clues:
Charlie is 9 years old.
Gracie has a wingspan of 114 inches.
The 11-year-old bird has a wingspan 8 inches shorter than Charlie.
Angel is either the 8-year-old bird or the bird with a wingspan of 114 inches.

Entities:
names: Angel, Charlie, Gracie, Merlin
wingspans: 102 inches, 106 inches, 110 inches, 114 inches
ages: 8, 9, 10, 11
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Angel == 1, and Wingspan114 == 1, and Age8 == 1, then Angel is the 8-year-old bird with a wingspan of 114 inches.

### Decision variables:
-   Names of the birds: Angel, Charlie, Gracie, Merlin (all different, 1 to 4)
-   Wingspans: Wingspan102, Wingspan106, Wingspan110, Wingspan114 (all different, 1 to 4)
-   Ages: Age8, Age9, Age10, Age11 (all different, 1 to 4)

### Constraints:
-   Charlie is 9 years old:
    This constraint directly assigns the age 9 to Charlie:
    Charlie == Age9.

-   Gracie has a wingspan of 114 inches:
    This constraint directly assigns the wingspan 114 inches to Gracie:
    Gracie == Wingspan114.

-   The 11-year-old bird has a wingspan 8 inches shorter than Charlie:
    For this, we will need to add a constraint for each possible assignment of ages to the birds, such that the 11-year-old bird's wingspan is 8 inches shorter than Charlie's wingspan. So, the constraints will be of the form:
    a1 == Age11 and a2 == Charlie => a1_to_int == a2_to_int - 8, for all a1, a2 in ages.

-   Angel is either the 8-year-old bird or the bird with a wingspan of 114 inches:
    This is a constraint that states that Angel is either the 8-year-old bird or the bird with a wingspan of 114 inches, but not both. So:
    Xor([Angel == Age8, Angel == Wingspan114]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Angel == 1, and Wingspan114 == 1, and Age8 == 1, then Angel is the 8-year-old bird with a wingspan of 114 inches.

### Decision variables:
-   Names of the birds: Angel, Charlie, Gracie, Merlin (all different, 1 to 4)
-   Wingspans: Wingspan102, Wingspan106, Wingspan110, Wingspan114 (all different, 1 to 4)
-   Ages: Age8, Age9, Age10, Age11 (all different, 1 to 4)

### Constraints:
-   Charlie is 9 years old:
    This constraint directly assigns the age 9 to Charlie:
    Charlie == Age9.

-   Gracie has a wingspan of 114 inches:
    This constraint directly assigns the wingspan 114 inches to Gracie:
    Gracie == Wingspan114.

-   The 11-year-old bird has a wingspan 8 inches shorter than Charlie:
    For this, we will need to add a constraint for each possible assignment of ages to the birds, such that the 11-year-old bird's wingspan is 8 inches shorter than Charlie's wingspan. So, the constraints will be of the form:
    a1 == Age11 and a2 == Charlie => a1_to_int == a2_to_int - 8, for all a1, a2 in ages.

-   Angel is either the 8-year-old bird or the bird with a wingspan of 114 inches:
    This is a constraint that states that Angel is either the 8-year-old bird or the bird with a wingspan of 114 inches, but not both. So:
    Xor([Angel == Age8, Angel == Wingspan114]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of bird, wingspan, and age)
# e.g. if angel == 1 and wingspan114 == 1 and age8 == 1, then Angel is the 8-year-old bird with a wingspan of 114 inches
angel, charlie, gracie, merlin = birds = intvar(1, 4, shape=4)
wingspan102, wingspan106, wingspan110, wingspan114 = wingspans = intvar(1, 4, shape=4)
age8, age9, age10, age11 = ages = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
bird_to_int = None  # N/A
wingspan_to_int = {wingspan102: 102, wingspan106: 106, wingspan110: 110, wingspan114: 114}  # in inches
age_to_int = {age8: 8, age9: 9, age10: 10, age11: 11}  # in years


# Helper functions (for formulating comparison constraints)
def wingspan_shorter_than(var1, var2, diff):
    """
    Formulate the constraint that var1's wingspan is diff inches shorter than var2's wingspan.
    """
    return [((w1 == var1) & (w2 == var2)).implies(wingspan_to_int[w1] == wingspan_to_int[w2] - diff)
            for w1 in wingspans for w2 in wingspans]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(birds)
m += AllDifferent(wingspans)
m += AllDifferent(ages)

# Clue 1: Charlie is 9 years old
m += charlie == age9

# Clue 2: Gracie has a wingspan of 114 inches
m += gracie == wingspan114

# Clue 3: The 11-year-old bird has a wingspan 8 inches shorter than Charlie
m += wingspan_shorter_than(age11, charlie, 8)

# Clue 4: Angel is either the 8-year-old bird or the bird with a wingspan of 114 inches
m += Xor([
    angel == age8,
    angel == wingspan114
])

```
[['charlie', 'wingspan110', 'age9'], ['gracie', 'wingspan114', 'age10'], ['angel', 'wingspan106', 'age8'], ['merlin', 'wingspan102', 'age11']]
True
True
True
Wrong: 0, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The TrustCo card has an APR of 11%.
The Southwest Inc card has a limit of $2,000.
The card with an APR of 11% is either the card with the $4,000 credit limit or the one with the $20,000 credit limit.
The card with an APR of 10% is either the card with the $4,000 credit limit or the TrustCo card.
The Credit Korp card has an APR 1 percent lower than the one with the $2,000 credit limit.

Entities:
credit cards: Credit Korp, Mid Atlantic, Southwest Inc, TrustCo
APR: 8%, 9%, 10%, 11%
credit limits: $2,000, $4,000, $5,000, $20,000
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Credit Korp == 1, and APR8 == 1, and Limit2000 == 1, then Credit Korp has an APR of 8% and a credit limit of $2,000.

### Decision variables:
-   Names of the credit cards: Credit Korp, Mid Atlantic, Southwest Inc, TrustCo (all different, 1 to 4)
-   APRs: APR8, APR9, APR10, APR11 (all different, 1 to 4)
-   Credit limits: Limit2000, Limit4000, Limit5000, Limit20000 (all different, 1 to 4)

### Constraints:
-   The TrustCo card has an APR of 11%:
    This constraint directly assigns TrustCo to APR11.

-   The Southwest Inc card has a limit of $2,000:
    This constraint directly assigns Southwest Inc to Limit2000.

-   The card with an APR of 11% is either the card with the $4,000 credit limit or the one with the $20,000 credit limit:
    This constraint states that the card with APR11 is either Limit4000 or Limit20000, but not both. So:
    Xor([APR11 == Limit4000, APR11 == Limit20000]).

-   The card with an APR of 10% is either the card with the $4,000 credit limit or the TrustCo card:
    This constraint states that the card with APR10 is either Limit4000 or TrustCo, but not both. So:
    Xor([APR10 == Limit4000, APR10 == TrustCo]).

-   The Credit Korp card has an APR 1 percent lower than the one with the $2,000 credit limit:
    This constraint states that Credit Korp's APR is 1% lower than Limit2000. So, for all possible assignments of APRs and credit limits:
    c1 == Credit Korp and c2 == Limit2000 => c1_to_int == c2_to_int - 1, for all c1, c2 in APRs and credit limits.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Credit Korp == 1, and APR8 == 1, and Limit2000 == 1, then Credit Korp has an APR of 8% and a credit limit of $2,000.

### Decision variables:
-   Names of the credit cards: Credit Korp, Mid Atlantic, Southwest Inc, TrustCo (all different, 1 to 4)
-   APRs: APR8, APR9, APR10, APR11 (all different, 1 to 4)
-   Credit limits: Limit2000, Limit4000, Limit5000, Limit20000 (all different, 1 to 4)

### Constraints:
-   The TrustCo card has an APR of 11%:
    This constraint directly assigns TrustCo to APR11.

-   The Southwest Inc card has a limit of $2,000:
    This constraint directly assigns Southwest Inc to Limit2000.

-   The card with an APR of 11% is either the card with the $4,000 credit limit or the one with the $20,000 credit limit:
    This constraint states that the card with APR11 is either Limit4000 or Limit20000, but not both. So:
    Xor([APR11 == Limit4000, APR11 == Limit20000]).

-   The card with an APR of 10% is either the card with the $4,000 credit limit or the TrustCo card:
    This constraint states that the card with APR10 is either Limit4000 or TrustCo, but not both. So:
    Xor([APR10 == Limit4000, APR10 == TrustCo]).

-   The Credit Korp card has an APR 1 percent lower than the one with the $2,000 credit limit:
    This constraint states that Credit Korp's APR is 1% lower than Limit2000. So, for all possible assignments of APRs and credit limits:
    c1 == Credit Korp and c2 == Limit2000 => c1_to_int == c2_to_int - 1, for all c1, c2 in APRs and credit limits.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of credit card, APR, and credit limit)
# e.g. if credit_korp == 1 and apr8 == 1 and limit2000 == 1, then Credit Korp has an APR of 8% and a credit limit of $2,000
credit_korp, mid_atlantic, southwest_inc, trustco = credit_cards = intvar(1, 4, shape=4)
apr8, apr9, apr10, apr11 = aprs = intvar(1, 4, shape=4)
limit2000, limit4000, limit5000, limit20000 = credit_limits = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
card_to_int = None  # N/A
apr_to_int = {apr8: 8, apr9: 9, apr10: 10, apr11: 11}  # in percentage
limit_to_int = {limit2000: 2000, limit4000: 4000, limit5000: 5000, limit20000: 20000}  # in dollars


# Helper functions (for formulating comparison constraints)
def apr_1_percent_lower(var1, var2):
    """
    Formulate the constraint that var1's APR is 1% lower than var2's.
    """
    return [((c1 == var1) & (c2 == var2)).implies(apr_to_int[c1] == apr_to_int[c2] - 1)
            for c1 in aprs for c2 in aprs]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(credit_cards)
m += AllDifferent(aprs)
m += AllDifferent(credit_limits)

# Clue 1: The TrustCo card has an APR of 11%
m += trustco == apr11

# Clue 2: The Southwest Inc card has a limit of $2,000
m += southwest_inc == limit2000

# Clue 3: The card with an APR of 11% is either the card with the $4,000 credit limit or the one with the $20,000 credit limit
m += Xor([
    apr11 == limit4000,
    apr11 == limit20000
])

# Clue 4: The card with an APR of 10% is either the card with the $4,000 credit limit or the TrustCo card
m += Xor([
    apr10 == limit4000,
    apr10 == trustco
])

# Clue 5: The Credit Korp card has an APR 1 percent lower than the one with the $2,000 credit limit
m += apr_1_percent_lower(credit_korp, limit2000)

```
[['mid_atlantic', 'apr10', 'limit4000'], ['southwest_inc', 'apr9', 'limit2000'], ['credit_korp', 'apr8', 'limit5000'], ['trustco', 'apr11', 'limit20000']]
True
True
False
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The title due on September 22 is either Rosa's book or "Dancing Well".
Ebony's book was due 1 week after Rosa's book.
Aimee's book was due on September 15.
Ebony's book was "Heaven's Seal".
"Heaven's Seal" was due 1 week after "Frogs of Iowa".

Entities:
borrowers: Aimee, Ebony, Jimmy, Rosa
due dates: September 1, September 8, September 15, September 22
titles: Dancing Well, Frogs of Iowa, Heaven's Seal, Time to Burn
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Aimee == 1, and September15 == 1, and HeavenSeal == 1, then Aimee borrowed "Heaven's Seal" due on September 15.

### Decision variables:
-   Names of the borrowers: Aimee, Ebony, Jimmy, Rosa (all different, 1 to 4)
-   Due dates: September 1, September 8, September 15, September 22 (all different, 1 to 4)
-   Titles of the books: Dancing Well, Frogs of Iowa, Heaven's Seal, Time to Burn (all different, 1 to 4)

### Constraints:
-   The title due on September 22 is either Rosa's book or "Dancing Well":
    This is a constraint that states that the book due on September 22 is either Rosa's book or "Dancing Well", but not both. So:
    Xor([September22 == Rosa, September22 == DancingWell]).

-   Ebony's book was due 1 week after Rosa's book:
    For this, we will need to add a constraint for each possible assignment of due dates for Ebony's book and Rosa's book, such that Ebony's due date is 1 more than Rosa's due date. So, the constraints will be of the form:
    d1 == Ebony and d2 == Rosa => d1_to_int == d2_to_int + 1, for all d1, d2 in due dates.

-   Aimee's book was due on September 15:
    This is a constraint that states that Aimee's book was due on September 15. So:
    Aimee == September15.

-   Ebony's book was "Heaven's Seal":
    This is a constraint that states that Ebony's book was "Heaven's Seal". So:
    Ebony == HeavenSeal.

-   "Heaven's Seal" was due 1 week after "Frogs of Iowa":
    For this, we will need to add a constraint for each possible assignment of due dates for "Heaven's Seal" and "Frogs of Iowa", such that "Heaven's Seal" due date is 1 more than "Frogs of Iowa" due date. So, the constraints will be of the form:
    d1 == HeavenSeal and d2 == FrogsOfIowa => d1_to_int == d2_to_int + 1, for all d1, d2 in due dates.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Aimee == 1, and September15 == 1, and HeavenSeal == 1, then Aimee borrowed "Heaven's Seal" due on September 15.

### Decision variables:
-   Names of the borrowers: Aimee, Ebony, Jimmy, Rosa (all different, 1 to 4)
-   Due dates: September 1, September 8, September 15, September 22 (all different, 1 to 4)
-   Titles of the books: Dancing Well, Frogs of Iowa, Heaven's Seal, Time to Burn (all different, 1 to 4)

### Constraints:
-   The title due on September 22 is either Rosa's book or "Dancing Well":
    This is a constraint that states that the book due on September 22 is either Rosa's book or "Dancing Well", but not both. So:
    Xor([September22 == Rosa, September22 == DancingWell]).

-   Ebony's book was due 1 week after Rosa's book:
    For this, we will need to add a constraint for each possible assignment of due dates for Ebony's book and Rosa's book, such that Ebony's due date is 1 more than Rosa's due date. So, the constraints will be of the form:
    d1 == Ebony and d2 == Rosa => d1_to_int == d2_to_int + 1, for all d1, d2 in due dates.

-   Aimee's book was due on September 15:
    This is a constraint that states that Aimee's book was due on September 15. So:
    Aimee == September15.

-   Ebony's book was "Heaven's Seal":
    This is a constraint that states that Ebony's book was "Heaven's Seal". So:
    Ebony == HeavenSeal.

-   "Heaven's Seal" was due 1 week after "Frogs of Iowa":
    For this, we will need to add a constraint for each possible assignment of due dates for "Heaven's Seal" and "Frogs of Iowa", such that "Heaven's Seal" due date is 1 more than "Frogs of Iowa" due date. So, the constraints will be of the form:
    d1 == HeavenSeal and d2 == FrogsOfIowa => d1_to_int == d2_to_int + 1, for all d1, d2 in due dates.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of borrower, due date, and title)
# e.g. if aimee == 1 and september15 == 1 and heavensseal == 1, then Aimee borrowed "Heaven's Seal" due on September 15
aimee, ebony, jimmy, rosa = borrowers = intvar(1, 4, shape=4)
september1, september8, september15, september22 = due_dates = intvar(1, 4, shape=4)
dancingwell, frogsofiowa, heavensseal, timetoburn = titles = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
borrower_to_int = None  # N/A
due_date_to_int = {september1: 1, september8: 2, september15: 3, september22: 4}  # in days
title_to_int = {dancingwell: 1, frogsofiowa: 2, heavensseal: 3, timetoburn: 4}  # in days


# Helper functions (for formulating comparison constraints)
def due_after_than(var1, var2):
    """
    Formulate the constraint that var1 is due after var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(due_date_to_int[d1] > due_date_to_int[d2])
            for d1 in due_dates for d2 in due_dates]


def due_exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 is due exactly diff days after var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(due_date_to_int[d1] == due_date_to_int[d2] + diff)
            for d1 in due_dates for d2 in due_dates]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(borrowers)
m += AllDifferent(due_dates)
m += AllDifferent(titles)

# Clue 1: The title due on September 22 is either Rosa's book or "Dancing Well":
m += Xor([
    september22 == rosa,
    september22 == dancingwell
])

# Clue 2: Ebony's book was due 1 week after Rosa's book:
m += due_exactly_after_than(ebony, rosa, 1)

# Clue 3: Aimee's book was due on September 15:
m += aimee == september15

# Clue 4: Ebony's book was "Heaven's Seal":
m += ebony == heavensseal

# Clue 5: "Heaven's Seal" was due 1 week after "Frogs of Iowa":
m += due_exactly_after_than(heavensseal, frogsofiowa, 1)

```
[['ebony', 'september8', 'heavensseal'], ['aimee', 'september15', 'timetoburn'], ['jimmy', 'september22', 'dancingwell'], ['rosa', 'september1', 'frogsofiowa']]
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The siren released in 1997 is 10 decibels louder than the siren released in 1996.
The siren released in 2009 is either the Armor-Stop or the Viking 5.
The siren released in 1997 is either the Soundarm or the Viking 5.
The Armor-Stop is louder than the siren released in 2009.
The Soundarm is 110 decibels loud.

Entities:
sirens: Armor-Stop, Rip Tide, Soundarm, Viking 5
decibels: 100 decibels, 105 decibels, 110 decibels, 115 decibels
years: 1996, 1997, 2000, 2009
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if ArmorStop == 1, and Decibels100 == 1, and Year1996 == 1, then Armor-Stop was released in 1996 with 100 decibels.

### Decision variables:
-   Names of the sirens: Armor-Stop, Rip Tide, Soundarm, Viking 5 (all different, 1 to 4)
-   Decibel levels: 100 decibels, 105 decibels, 110 decibels, 115 decibels (all different, 1 to 4)
-   Years of release: 1996, 1997, 2000, 2009 (all different, 1 to 4)

### Constraints:
-   The siren released in 1997 is 10 decibels louder than the siren released in 1996:
    For this, we will need to add a constraint for each possible assignment of the decibel levels for the sirens released in 1996 and 1997, such that the decibel level of the siren released in 1997 is 10 more than the decibel level of the siren released in 1996. So, the constraints will be of the form:
    d1 == Year1996 and d2 == Year1997 => d2_to_int == d1_to_int + 10, for all d1, d2 in decibel levels.

-   The siren released in 2009 is either the Armor-Stop or the Viking 5:
    This is a constraint that states that the siren released in 2009 is either the Armor-Stop or the Viking 5. So:
    Or([Year2009 == ArmorStop, Year2009 == Viking5]).

-   The siren released in 1997 is either the Soundarm or the Viking 5:
    This is a constraint that states that the siren released in 1997 is either the Soundarm or the Viking 5. So:
    Or([Year1997 == Soundarm, Year1997 == Viking5]).

-   The Armor-Stop is louder than the siren released in 2009:
    For this, we will need to add a constraint for each possible assignment of the decibel levels for the Armor-Stop and the siren released in 2009, such that the decibel level of the Armor-Stop is greater than the decibel level of the siren released in 2009. So, the constraints will be of the form:
    d1 == ArmorStop and d2 == Year2009 => d1_to_int > d2_to_int, for all d1, d2 in decibel levels.

-   The Soundarm is 110 decibels loud:
    This is a constraint that states that the Soundarm has a decibel level of 110. So:
    Soundarm == Decibels110.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if ArmorStop == 1, and Decibels100 == 1, and Year1996 == 1, then Armor-Stop was released in 1996 with 100 decibels.

### Decision variables:
-   Names of the sirens: Armor-Stop, Rip Tide, Soundarm, Viking 5 (all different, 1 to 4)
-   Decibel levels: 100 decibels, 105 decibels, 110 decibels, 115 decibels (all different, 1 to 4)
-   Years of release: 1996, 1997, 2000, 2009 (all different, 1 to 4)

### Constraints:
-   The siren released in 1997 is 10 decibels louder than the siren released in 1996:
    For this, we will need to add a constraint for each possible assignment of the decibel levels for the sirens released in 1996 and 1997, such that the decibel level of the siren released in 1997 is 10 more than the decibel level of the siren released in 1996. So, the constraints will be of the form:
    d1 == Year1996 and d2 == Year1997 => d2_to_int == d1_to_int + 10, for all d1, d2 in decibel levels.

-   The siren released in 2009 is either the Armor-Stop or the Viking 5:
    This is a constraint that states that the siren released in 2009 is either the Armor-Stop or the Viking 5. So:
    Or([Year2009 == ArmorStop, Year2009 == Viking5]).

-   The siren released in 1997 is either the Soundarm or the Viking 5:
    This is a constraint that states that the siren released in 1997 is either the Soundarm or the Viking 5. So:
    Or([Year1997 == Soundarm, Year1997 == Viking5]).

-   The Armor-Stop is louder than the siren released in 2009:
    For this, we will need to add a constraint for each possible assignment of the decibel levels for the Armor-Stop and the siren released in 2009, such that the decibel level of the Armor-Stop is greater than the decibel level of the siren released in 2009. So, the constraints will be of the form:
    d1 == ArmorStop and d2 == Year2009 => d1_to_int > d2_to_int, for all d1, d2 in decibel levels.

-   The Soundarm is 110 decibels loud:
    This is a constraint that states that the Soundarm has a decibel level of 110. So:
    Soundarm == Decibels110.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of siren, decibel level, and year)
# e.g. if armor_stop == 1 and decibels100 == 1 and year1996 == 1, then Armor-Stop was released in 1996 with 100 decibels
armor_stop, rip_tide, soundarm, viking_5 = sirens = intvar(1, 4, shape=4)
decibels100, decibels105, decibels110, decibels115 = decibels = intvar(1, 4, shape=4)
year1996, year1997, year2000, year2009 = years = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
siren_to_int = None  # N/A
decibel_to_int = {decibels100: 100, decibels105: 105, decibels110: 110, decibels115: 115}  # in decibels
year_to_int = {year1996: 1996, year1997: 1997, year2000: 2000, year2009: 2009}  # in years


# Helper functions (for formulating comparison constraints)
def louder_than(var1, var2):
    """
    Formulate the constraint that var1 is louder than var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(decibel_to_int[d1] > decibel_to_int[d2])
            for d1 in decibels for d2 in decibels]


def louder_exactly_than(var1, var2, diff):
    """
    Formulate the constraint that var1 is exactly diff decibels louder than var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(decibel_to_int[d1] == decibel_to_int[d2] + diff)
            for d1 in decibels for d2 in decibels]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(sirens)
m += AllDifferent(decibels)
m += AllDifferent(years)

# Clue 1: The siren released in 1997 is 10 decibels louder than the siren released in 1996:
m += louder_exactly_than(year1997, year1996, 10)

# Clue 2: The siren released in 2009 is either the Armor-Stop or the Viking 5:
m += Or([
    year2009 == armor_stop,
    year2009 == viking_5
])

# Clue 3: The siren released in 1997 is either the Soundarm or the Viking 5:
m += Or([
    year1997 == soundarm,
    year1997 == viking_5
])

# Clue 4: The Armor-Stop is louder than the siren released in 2009:
m += louder_than(armor_stop, year2009)

# Clue 5: The Soundarm is 110 decibels loud:
m += soundarm == decibels110

```
None
Error when trying to check solution from predicted model: invalid syntax (<string>, line 1)
False
False
Error in constraint evaluation: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
The one who had the cafe americano paid 1 dollar more than the one who had the cafe latte.
Hope paid $8.
Norman paid less than Opal.
The one who had the cafe americano paid less than Linda.
The one who had the cafe mocha paid 2 dollars more than Norman.

Entities:
names: Hope, Linda, Norman, Opal
prices: $5, $6, $7, $8
drinks: cafe americano, cafe latte, cafe mocha, espresso
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Hope == 1, and Price5 == 1, and Americano == 1, then Hope had the cafe americano and paid $5.

### Decision variables:
-   Names of the individuals: Hope, Linda, Norman, Opal (all different, 1 to 4)
-   Prices paid: Price5, Price6, Price7, Price8 (all different, 1 to 4)
-   Drinks ordered: Americano, Latte, Mocha, Espresso (all different, 1 to 4)

### Constraints:
-   The one who had the cafe americano paid 1 dollar more than the one who had the cafe latte:
    For this, we will need to add a constraint for each possible assignment of prices to the cafe americano and cafe latte, such that the price of the cafe americano is 1 dollar more than the price of the cafe latte. So, the constraints will be of the form:
    p1 == Americano and p2 == Latte => p1_to_int == p2_to_int + 1, for all p1, p2 in prices.

-   Hope paid $8:
    This is a simple constraint that states that Hope paid $8:
    Hope == Price8.

-   Norman paid less than Opal:
    For this, we will need to add a constraint for each possible assignment of prices to Norman and Opal, such that Norman's price is less than Opal's price. So, the constraints will be of the form:
    p1 == Norman and p2 == Opal => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   The one who had the cafe americano paid less than Linda:
    For this, we will need to add a constraint for each possible assignment of prices to the cafe americano and Linda, such that the price of the cafe americano is less than Linda's price. So, the constraints will be of the form:
    p1 == Americano and p2 == Linda => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   The one who had the cafe mocha paid 2 dollars more than Norman:
    For this, we will need to add a constraint for each possible assignment of prices to the cafe mocha and Norman, such that the price of the cafe mocha is 2 dollars more than Norman's price. So, the constraints will be of the form:
    p1 == Mocha and p2 == Norman => p1_to_int == p2_to_int + 2, for all p1, p2 in prices.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Hope == 1, and Price5 == 1, and Americano == 1, then Hope had the cafe americano and paid $5.

### Decision variables:
-   Names of the individuals: Hope, Linda, Norman, Opal (all different, 1 to 4)
-   Prices paid: Price5, Price6, Price7, Price8 (all different, 1 to 4)
-   Drinks ordered: Americano, Latte, Mocha, Espresso (all different, 1 to 4)

### Constraints:
-   The one who had the cafe americano paid 1 dollar more than the one who had the cafe latte:
    For this, we will need to add a constraint for each possible assignment of prices to the cafe americano and cafe latte, such that the price of the cafe americano is 1 dollar more than the price of the cafe latte. So, the constraints will be of the form:
    p1 == Americano and p2 == Latte => p1_to_int == p2_to_int + 1, for all p1, p2 in prices.

-   Hope paid $8:
    This is a simple constraint that states that Hope paid $8:
    Hope == Price8.

-   Norman paid less than Opal:
    For this, we will need to add a constraint for each possible assignment of prices to Norman and Opal, such that Norman's price is less than Opal's price. So, the constraints will be of the form:
    p1 == Norman and p2 == Opal => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   The one who had the cafe americano paid less than Linda:
    For this, we will need to add a constraint for each possible assignment of prices to the cafe americano and Linda, such that the price of the cafe americano is less than Linda's price. So, the constraints will be of the form:
    p1 == Americano and p2 == Linda => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   The one who had the cafe mocha paid 2 dollars more than Norman:
    For this, we will need to add a constraint for each possible assignment of prices to the cafe mocha and Norman, such that the price of the cafe mocha is 2 dollars more than Norman's price. So, the constraints will be of the form:
    p1 == Mocha and p2 == Norman => p1_to_int == p2_to_int + 2, for all p1, p2 in prices.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of individual, price, and drink)
# e.g. if hope == 1 and price5 == 1 and americano == 1, then Hope had the cafe americano and paid $5
hope, linda, norman, opal = names = intvar(1, 4, shape=4)
price5, price6, price7, price8 = prices = intvar(1, 4, shape=4)
americano, latte, mocha, espresso = drinks = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
name_to_int = None  # N/A
price_to_int = {price5: 5, price6: 6, price7: 7, price8: 8}  # in dollars
drink_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def paid_more_than(var1, var2):
    """
    Formulate the constraint that var1 paid more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] > price_to_int[p2])
            for p1 in prices for p2 in prices]


def paid_exactly_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 paid exactly $diff more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] + diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(names)
m += AllDifferent(prices)
m += AllDifferent(drinks)

# Clue 1: The one who had the cafe americano paid 1 dollar more than the one who had the cafe latte:
m += paid_exactly_more_than(americano, latte, 1)

# Clue 2: Hope paid $8:
m += hope == price8

# Clue 3: Norman paid less than Opal:
m += paid_more_than(norman, opal)

# Clue 4: The one who had the cafe americano paid less than Linda:
m += paid_more_than(americano, linda)

# Clue 5: The one who had the cafe mocha paid 2 dollars more than Norman:
m += paid_exactly_more_than(mocha, norman, 2)

```
None
False
False
False
Wrong: 2, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The ring with the aquamarine cost less than the piece with the diamond.
Opal's ring is either the piece that cost $1300 or the piece with the diamond.
The piece that cost $1400 is either the ring with the ruby or Hazel's ring.
Hazel's ring has the diamond.
Becky's piece cost more than the ring with the diamond.

Entities:
customers: Becky, Hazel, Opal, Yolanda
prices: $1100, $1200, $1300, $1400
stones: aquamarine, diamond, ruby, topaz
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Becky == 1, and Price1100 == 1, and Aquamarine == 1, then Becky bought the aquamarine piece for $1100.

### Decision variables:
-   Names of the customers: Becky, Hazel, Opal, Yolanda (all different, 1 to 4)
-   Prices of the pieces: Price1100, Price1200, Price1300, Price1400 (all different, 1 to 4)
-   Stones in the pieces: Aquamarine, Diamond, Ruby, Topaz (all different, 1 to 4)

### Constraints:
-   The ring with the aquamarine cost less than the piece with the diamond:
    For this, we will need to add a constraint for each possible assignment of prices to the ring with aquamarine and the piece with diamond, such that the price of the aquamarine ring is less than the price of the diamond piece. So, the constraints will be of the form:
    p1 == Aquamarine and p2 == Diamond => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   Opal's ring is either the piece that cost $1300 or the piece with the diamond:
    This is a constraint that states that Opal's piece is either the $1300 piece or the diamond piece, but not both. So:
    Xor([Opal == Price1300, Opal == Diamond]).

-   The piece that cost $1400 is either the ring with the ruby or Hazel's ring:
    This is a constraint that states that the $1400 piece is either the ruby ring or Hazel's ring, but not both. So:
    Xor([Price1400 == Ruby, Price1400 == Hazel]).

-   Hazel's ring has the diamond:
    This is a constraint that states that Hazel's piece is the diamond piece. So:
    Hazel == Diamond.

-   Becky's piece cost more than the ring with the diamond:
    For this, we will need to add a constraint for each possible assignment of prices to Becky's piece and the ring with the diamond, such that Becky's piece costs more than the diamond ring. So, the constraints will be of the form:
    p1 == Becky and p2 == Diamond => p1_to_int > p2_to_int, for all p1, p2 in prices.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Becky == 1, and Price1100 == 1, and Aquamarine == 1, then Becky bought the aquamarine piece for $1100.

### Decision variables:
-   Names of the customers: Becky, Hazel, Opal, Yolanda (all different, 1 to 4)
-   Prices of the pieces: Price1100, Price1200, Price1300, Price1400 (all different, 1 to 4)
-   Stones in the pieces: Aquamarine, Diamond, Ruby, Topaz (all different, 1 to 4)

### Constraints:
-   The ring with the aquamarine cost less than the piece with the diamond:
    For this, we will need to add a constraint for each possible assignment of prices to the ring with aquamarine and the piece with diamond, such that the price of the aquamarine ring is less than the price of the diamond piece. So, the constraints will be of the form:
    p1 == Aquamarine and p2 == Diamond => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   Opal's ring is either the piece that cost $1300 or the piece with the diamond:
    This is a constraint that states that Opal's piece is either the $1300 piece or the diamond piece, but not both. So:
    Xor([Opal == Price1300, Opal == Diamond]).

-   The piece that cost $1400 is either the ring with the ruby or Hazel's ring:
    This is a constraint that states that the $1400 piece is either the ruby ring or Hazel's ring, but not both. So:
    Xor([Price1400 == Ruby, Price1400 == Hazel]).

-   Hazel's ring has the diamond:
    This is a constraint that states that Hazel's piece is the diamond piece. So:
    Hazel == Diamond.

-   Becky's piece cost more than the ring with the diamond:
    For this, we will need to add a constraint for each possible assignment of prices to Becky's piece and the ring with the diamond, such that Becky's piece costs more than the diamond ring. So, the constraints will be of the form:
    p1 == Becky and p2 == Diamond => p1_to_int > p2_to_int, for all p1, p2 in prices.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of customer, price, and stone)
# e.g. if becky == 1 and price1100 == 1 and aquamarine == 1, then Becky bought the aquamarine piece for $1100
becky, hazel, opal, yolanda = customers = intvar(1, 4, shape=4)
price1100, price1200, price1300, price1400 = prices = intvar(1, 4, shape=4)
aquamarine, diamond, ruby, topaz = stones = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
customer_to_int = None  # N/A
price_to_int = {price1100: 1100, price1200: 1200, price1300: 1300, price1400: 1400}  # in dollars
stone_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def cost_less_than(var1, var2):
    """
    Formulate the constraint that var1 cost less than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] < price_to_int[p2])
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(customers)
m += AllDifferent(prices)
m += AllDifferent(stones)

# Clue 1: The ring with the aquamarine cost less than the piece with the diamond:
m += cost_less_than(aquamarine, diamond)

# Clue 2: Opal's ring is either the piece that cost $1300 or the piece with the diamond:
m += Xor([
    opal == price1300,
    opal == diamond
])

# Clue 3: The piece that cost $1400 is either the ring with the ruby or Hazel's ring:
m += Xor([
    price1400 == ruby,
    price1400 == hazel
])

# Clue 4: Hazel's ring has the diamond:
m += hazel == diamond

# Clue 5: Becky's piece cost more than the ring with the diamond:
m += cost_less_than(becky, diamond)

```
[['becky', 'price1100', 'topaz'], ['opal', 'price1300', 'aquamarine'], ['hazel', 'price1400', 'diamond'], ['yolanda', 'price1200', 'ruby']]
False
False
False
Wrong: 1, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The wood frog was bought 1 month after Nettie's pet.
Ollie's pet is the wood frog.
The tree frog was bought 2 months after Ollie's pet.
Joann's pet is either the wood frog or the tree frog.
Ida's pet is either the animal bought in April or the bullfrog.

Entities:
names: Ida, Joann, Nettie, Ollie
months: January, February, March, April
amphibians: bullfrog, horned toad, tree frog, wood frog
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ida == 1, and January == 1, and Bullfrog == 1, then Ida bought a bullfrog in January.

### Decision variables:
-   Names of the owners: Ida, Joann, Nettie, Ollie (all different, 1 to 4)
-   Months of purchase: January, February, March, April (all different, 1 to 4)
-   Types of amphibians: Bullfrog, HornedToad, TreeFrog, WoodFrog (all different, 1 to 4)

### Constraints:
-   The wood frog was bought 1 month after Nettie's pet:
    For this, we will need to add a constraint for each possible assignment of the months of purchase for the wood frog and Nettie's pet, such that the wood frog's month of purchase is 1 greater than Nettie's pet's month of purchase. So, the constraints will be of the form:
    m1 == WoodFrog and m2 == Nettie => m1_to_int == m2_to_int + 1, for all m1, m2 in months of purchase.

-   Ollie's pet is the wood frog:
    This is a constraint that states Ollie's pet is the wood frog. So:
    Ollie == WoodFrog.

-   The tree frog was bought 2 months after Ollie's pet:
    For this, we will need to add a constraint for each possible assignment of the months of purchase for the tree frog and Ollie's pet, such that the tree frog's month of purchase is 2 greater than Ollie's pet's month of purchase. So, the constraints will be of the form:
    m1 == TreeFrog and m2 == Ollie => m1_to_int == m2_to_int + 2, for all m1, m2 in months of purchase.

-   Joann's pet is either the wood frog or the tree frog:
    This is a constraint that states Joann's pet is either the wood frog or the tree frog. So:
    Or(Joann == WoodFrog, Joann == TreeFrog).

-   Ida's pet is either the animal bought in April or the bullfrog:
    This is a constraint that states Ida's pet is either the animal bought in April or the bullfrog. So:
    Or(Ida == April, Ida == Bullfrog).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ida == 1, and January == 1, and Bullfrog == 1, then Ida bought a bullfrog in January.

### Decision variables:
-   Names of the owners: Ida, Joann, Nettie, Ollie (all different, 1 to 4)
-   Months of purchase: January, February, March, April (all different, 1 to 4)
-   Types of amphibians: Bullfrog, HornedToad, TreeFrog, WoodFrog (all different, 1 to 4)

### Constraints:
-   The wood frog was bought 1 month after Nettie's pet:
    For this, we will need to add a constraint for each possible assignment of the months of purchase for the wood frog and Nettie's pet, such that the wood frog's month of purchase is 1 greater than Nettie's pet's month of purchase. So, the constraints will be of the form:
    m1 == WoodFrog and m2 == Nettie => m1_to_int == m2_to_int + 1, for all m1, m2 in months of purchase.

-   Ollie's pet is the wood frog:
    This is a constraint that states Ollie's pet is the wood frog. So:
    Ollie == WoodFrog.

-   The tree frog was bought 2 months after Ollie's pet:
    For this, we will need to add a constraint for each possible assignment of the months of purchase for the tree frog and Ollie's pet, such that the tree frog's month of purchase is 2 greater than Ollie's pet's month of purchase. So, the constraints will be of the form:
    m1 == TreeFrog and m2 == Ollie => m1_to_int == m2_to_int + 2, for all m1, m2 in months of purchase.

-   Joann's pet is either the wood frog or the tree frog:
    This is a constraint that states Joann's pet is either the wood frog or the tree frog. So:
    Or(Joann == WoodFrog, Joann == TreeFrog).

-   Ida's pet is either the animal bought in April or the bullfrog:
    This is a constraint that states Ida's pet is either the animal bought in April or the bullfrog. So:
    Or(Ida == April, Ida == Bullfrog).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of owner, month, and amphibian)
# e.g. if ida == 1 and january == 1 and bullfrog == 1, then Ida bought a bullfrog in January
ida, joann, nettie, ollie = owners = intvar(1, 4, shape=4)
january, february, march, april = months = intvar(1, 4, shape=4)
bullfrog, horned_toad, tree_frog, wood_frog = amphibians = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
owner_to_int = None  # N/A
month_to_int = {january: 1, february: 2, march: 3, april: 4}  # in months
amphibian_to_int = {bullfrog: 1, horned_toad: 2, tree_frog: 3, wood_frog: 4}  # in amphibians


# Helper functions (for formulating comparison constraints)
def bought_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 was bought diff months after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] == month_to_int[m2] + diff)
            for m1 in months for m2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(owners)
m += AllDifferent(months)
m += AllDifferent(amphibians)

# Clue 1: The wood frog was bought 1 month after Nettie's pet:
m += bought_after_than(wood_frog, nettie, 1)

# Clue 2: Ollie's pet is the wood frog:
m += ollie == wood_frog

# Clue 3: The tree frog was bought 2 months after Ollie's pet:
m += bought_after_than(tree_frog, ollie, 2)

# Clue 4: Joann's pet is either the wood frog or the tree frog:
m += Or(joann == wood_frog, joann == tree_frog)

# Clue 5: Ida's pet is either the animal bought in April or the bullfrog:
m += Or(ida == april, ida == bullfrog)

```
None
Error when trying to check solution from predicted model: invalid syntax (<string>, line 1)
False
False
Error in constraint evaluation: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
Winifred spoke for a somewhat shorter time than Omar.
Neal talked about Diocletian.
The four students were the presenter who spoke for 8 minutes, the student who gave the presentation on Galerius, Neal and Vickie.
The student who gave the presentation on Nero spoke 2 minutes more than Vickie.
Omar was either the presenter who gave the presentation on Nero or the presenter who spoke for 10 minutes.

Entities:
names: Neal, Omar, Vickie, Winifred
lengths: 6 minutes, 8 minutes, 10 minutes, 12 minutes
emperors: Diocletian, Galerius, Licinius, Nero
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Neal == 1, and Length6 == 1, and Diocletian == 1, then Neal spoke for 6 minutes about Diocletian.

### Decision variables:
-   Names of the students: Neal, Omar, Vickie, Winifred (all different, 1 to 4)
-   Length of speeches: Length6, Length8, Length10, Length12 (all different, 1 to 4)
-   Emperors discussed: Diocletian, Galerius, Licinius, Nero (all different, 1 to 4)

### Constraints:
-   Winifred spoke for a somewhat shorter time than Omar:
    For this, we will need to add a constraint for each possible assignment of speech lengths to Winifred and Omar, such that Winifred's speech length is less than Omar's speech length. So, the constraints will be of the form:
    l1 == Winifred and l2 == Omar => l1_to_int < l2_to_int, for all l1, l2 in speech lengths.

-   Neal talked about Diocletian:
    This is a simple constraint that assigns Neal to talk about Diocletian:
    Neal == Diocletian.

-   The four students were the presenter who spoke for 8 minutes, the student who gave the presentation on Galerius, Neal, and Vickie:
    This constraint states that the four students are the ones mentioned. So, we will add constraints to ensure that each of these students is assigned to one of the mentioned categories.

-   The student who gave the presentation on Nero spoke 2 minutes more than Vickie:
    For this, we will need to add a constraint for each possible assignment of speech lengths to the student who presented on Nero and Vickie, such that the speech length of Nero's presentation is 2 minutes more than Vickie's speech length. So, the constraints will be of the form:
    l1 == Nero and l2 == Vickie => l1_to_int == l2_to_int + 2, for all l1, l2 in speech lengths.

-   Omar was either the presenter who gave the presentation on Nero or the presenter who spoke for 10 minutes:
    This is a constraint that states that Omar is either the presenter who talked about Nero or the one who spoke for 10 minutes, but not both. So:
    Xor([Omar == Nero, Omar == Length10]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Neal == 1, and Length6 == 1, and Diocletian == 1, then Neal spoke for 6 minutes about Diocletian.

### Decision variables:
-   Names of the students: Neal, Omar, Vickie, Winifred (all different, 1 to 4)
-   Length of speeches: Length6, Length8, Length10, Length12 (all different, 1 to 4)
-   Emperors discussed: Diocletian, Galerius, Licinius, Nero (all different, 1 to 4)

### Constraints:
-   Winifred spoke for a somewhat shorter time than Omar:
    For this, we will need to add a constraint for each possible assignment of speech lengths to Winifred and Omar, such that Winifred's speech length is less than Omar's speech length. So, the constraints will be of the form:
    l1 == Winifred and l2 == Omar => l1_to_int < l2_to_int, for all l1, l2 in speech lengths.

-   Neal talked about Diocletian:
    This is a simple constraint that assigns Neal to talk about Diocletian:
    Neal == Diocletian.

-   The four students were the presenter who spoke for 8 minutes, the student who gave the presentation on Galerius, Neal, and Vickie:
    This constraint states that the four students are the ones mentioned. So, we will add constraints to ensure that each of these students is assigned to one of the mentioned categories.

-   The student who gave the presentation on Nero spoke 2 minutes more than Vickie:
    For this, we will need to add a constraint for each possible assignment of speech lengths to the student who presented on Nero and Vickie, such that the speech length of Nero's presentation is 2 minutes more than Vickie's speech length. So, the constraints will be of the form:
    l1 == Nero and l2 == Vickie => l1_to_int == l2_to_int + 2, for all l1, l2 in speech lengths.

-   Omar was either the presenter who gave the presentation on Nero or the presenter who spoke for 10 minutes:
    This is a constraint that states that Omar is either the presenter who talked about Nero or the one who spoke for 10 minutes, but not both. So:
    Xor([Omar == Nero, Omar == Length10]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of student, speech length, and emperor)
# e.g. if neal == 1 and length6 == 1 and diocletian == 1, then Neal spoke for 6 minutes about Diocletian
neal, omar, vickie, winifred = students = intvar(1, 4, shape=4)
length6, length8, length10, length12 = lengths = intvar(1, 4, shape=4)
diocletian, galerius, licinius, nero = emperors = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
student_to_int = None  # N/A
length_to_int = {length6: 6, length8: 8, length10: 10, length12: 12}  # in minutes
emperor_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def spoke_shorter_than(var1, var2):
    """
    Formulate the constraint that var1 spoke for a somewhat shorter time than var2.
    """
    return [((l1 == var1) & (l2 == var2)).implies(length_to_int[l1] < length_to_int[l2])
            for l1 in lengths for l2 in lengths]


def spoke_exactly_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 spoke exactly diff minutes more than var2.
    """
    return [((l1 == var1) & (l2 == var2)).implies(length_to_int[l1] == length_to_int[l2] + diff)
            for l1 in lengths for l2 in lengths]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(students)
m += AllDifferent(lengths)
m += AllDifferent(emperors)

# Clue 1: Winifred spoke for a somewhat shorter time than Omar:
m += spoke_shorter_than(winifred, omar)

# Clue 2: Neal talked about Diocletian:
m += neal == diocletian

# Clue 3: The four students were the presenter who spoke for 8 minutes, the student who gave the presentation on Galerius, Neal, and Vickie:
m += (length8 == 1) | (galerius == 1) | (neal == 1) | (vickie == 1)

# Clue 4: The student who gave the presentation on Nero spoke 2 minutes more than Vickie:
m += spoke_exactly_more_than(nero, vickie, 2)

# Clue 5: Omar was either the presenter who gave the presentation on Nero or the presenter who spoke for 10 minutes:
m += Xor([
    omar == nero,
    omar == length10
])

```
[['vickie', 'length10', 'licinius'], ['omar', 'length12', 'nero'], ['winifred', 'length8', 'galerius'], ['neal', 'length6', 'diocletian']]
False
True
False
Wrong: 1, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Rosa paid somewhat more than the customer who got picked up at the Smith Tower.
The client with the $9 fare was picked up at the Smith Tower.
Neil paid 3 dollars more than Rosa.
The customer who got picked up at the Fremont Library was either the client with the $9 fare or Della.
The person with the $15 fare was picked up at the Neptune Theatre.

Entities:
customers: Della, Neil, Rosa, Sara
fares: $6, $9, $12, $15
pickup points: Arctic Building, Fremont Library, Neptune Theatre, Smith Tower
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Della == 1, and Fare6 == 1, and ArcticBuilding == 1, then Della paid $6 and was picked up at the Arctic Building.

### Decision variables:
-   Names of the customers: Della, Neil, Rosa, Sara (all different, 1 to 4)
-   Fares paid by the customers: Fare6, Fare9, Fare12, Fare15 (all different, 1 to 4)
-   Pickup points: Arctic Building, Fremont Library, Neptune Theatre, Smith Tower (all different, 1 to 4)

### Constraints:
-   Rosa paid somewhat more than the customer who got picked up at the Smith Tower:
    For this, we will need to add a constraint for each possible assignment of fares to Rosa and the customer picked up at the Smith Tower, such that Rosa's fare is greater than the fare of the customer picked up at the Smith Tower. So, the constraints will be of the form:
    f1 == Rosa and p1 == Smith Tower => f1_to_int > p1_to_int, for all f1, p1 in fares.

-   The client with the $9 fare was picked up at the Smith Tower:
    This is a constraint that states that the customer with the $9 fare was picked up at the Smith Tower. So:
    Fare9 == Smith Tower.

-   Neil paid 3 dollars more than Rosa:
    For this, we will need to add a constraint for each possible assignment of fares to Neil and Rosa, such that Neil's fare is 3 dollars more than Rosa's fare. So, the constraints will be of the form:
    f1 == Neil and f2 == Rosa => f1_to_int == f2_to_int + 3, for all f1, f2 in fares.

-   The customer who got picked up at the Fremont Library was either the client with the $9 fare or Della:
    This is a constraint that states that the customer picked up at the Fremont Library was either the one with the $9 fare or Della. So:
    PickupFremontLibrary == Fare9 or PickupFremontLibrary == Della.

-   The person with the $15 fare was picked up at the Neptune Theatre:
    This is a constraint that states that the person with the $15 fare was picked up at the Neptune Theatre. So:
    Fare15 == Neptune Theatre.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Della == 1, and Fare6 == 1, and ArcticBuilding == 1, then Della paid $6 and was picked up at the Arctic Building.

### Decision variables:
-   Names of the customers: Della, Neil, Rosa, Sara (all different, 1 to 4)
-   Fares paid by the customers: Fare6, Fare9, Fare12, Fare15 (all different, 1 to 4)
-   Pickup points: Arctic Building, Fremont Library, Neptune Theatre, Smith Tower (all different, 1 to 4)

### Constraints:
-   Rosa paid somewhat more than the customer who got picked up at the Smith Tower:
    For this, we will need to add a constraint for each possible assignment of fares to Rosa and the customer picked up at the Smith Tower, such that Rosa's fare is greater than the fare of the customer picked up at the Smith Tower. So, the constraints will be of the form:
    f1 == Rosa and p1 == Smith Tower => f1_to_int > p1_to_int, for all f1, p1 in fares.

-   The client with the $9 fare was picked up at the Smith Tower:
    This is a constraint that states that the customer with the $9 fare was picked up at the Smith Tower. So:
    Fare9 == Smith Tower.

-   Neil paid 3 dollars more than Rosa:
    For this, we will need to add a constraint for each possible assignment of fares to Neil and Rosa, such that Neil's fare is 3 dollars more than Rosa's fare. So, the constraints will be of the form:
    f1 == Neil and f2 == Rosa => f1_to_int == f2_to_int + 3, for all f1, f2 in fares.

-   The customer who got picked up at the Fremont Library was either the client with the $9 fare or Della:
    This is a constraint that states that the customer picked up at the Fremont Library was either the one with the $9 fare or Della. So:
    PickupFremontLibrary == Fare9 or PickupFremontLibrary == Della.

-   The person with the $15 fare was picked up at the Neptune Theatre:
    This is a constraint that states that the person with the $15 fare was picked up at the Neptune Theatre. So:
    Fare15 == Neptune Theatre.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of customer, fare, and pickup point)
# e.g. if della == 1 and fare6 == 1 and arctic_building == 1, then Della paid $6 and was picked up at the Arctic Building
della, neil, rosa, sara = customers = intvar(1, 4, shape=4)
fare6, fare9, fare12, fare15 = fares = intvar(1, 4, shape=4)
arctic_building, fremont_library, neptune_theatre, smith_tower = pickup_points = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
customer_to_int = None  # N/A
fare_to_int = {fare6: 6, fare9: 9, fare12: 12, fare15: 15}  # in dollars
pickup_to_int = {arctic_building: 1, fremont_library: 2, neptune_theatre: 3, smith_tower: 4}  # in points


# Helper functions (for formulating comparison constraints)
def paid_more_than(var1, var2):
    """
    Formulate the constraint that var1 paid more than var2.
    """
    return [((f1 == var1) & (p1 == var2)).implies(fare_to_int[f1] > pickup_to_int[p1])
            for f1 in fares for p1 in pickup_points]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(customers)
m += AllDifferent(fares)
m += AllDifferent(pickup_points)

# Clue 1: Rosa paid somewhat more than the customer who got picked up at the Smith Tower:
m += paid_more_than(rosa, smith_tower)

# Clue 2: The client with the $9 fare was picked up at the Smith Tower:
m += fare9 == smith_tower

# Clue 3: Neil paid 3 dollars more than Rosa:
m += [((f1 == neil) & (f2 == rosa)).implies(fare_to_int[f1] == fare_to_int[f2] + 3)
      for f1 in fares for f2 in fares]

# Clue 4: The customer who got picked up at the Fremont Library was either the client with the $9 fare or Della:
m += (arctic_building == fare9) | (arctic_building == della)

# Clue 5: The person with the $15 fare was picked up at the Neptune Theatre:
m += fare15 == neptune_theatre

```
[['rosa', 'fare9', 'smith_tower'], ['sara', 'fare15', 'neptune_theatre'], ['della', 'fare6', 'arctic_building'], ['neil', 'fare12', 'fremont_library']]
False
False
False
Wrong: 2, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The facility scheduled to go online in 2019 is either the Egert Facility or the project headed by Dr. Alvarez.
The project headed by Dr. Morgan is either the Zynga Complex or the facility scheduled to go online in 2019.
The project headed by Dr. Salinas will go online 1 year before the Egert Facility.
The project headed by Dr. Alvarez will go online sometime after the project headed by Dr. Noble.
The project headed by Dr. Salinas will go online sometime before the project headed by Dr. Noble.
The project headed by Dr. Morgan will go online sometime after the Bale-Hahn SSC.

Entities:
names: Bale-Hahn SSC, Egert Facility, Lectra 4C, Zynga Complex
years: 2016, 2017, 2018, 2019
scientists: Dr. Alvarez, Dr. Morgan, Dr. Noble, Dr. Salinas
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if BaleHahn == 1, and Year2016 == 1, and Alvarez == 1, then Bale-Hahn SSC is the project headed by Dr. Alvarez going online in 2016.

### Decision variables:
-   Names of the projects: Bale-Hahn SSC, Egert Facility, Lectra 4C, Zynga Complex (all different, 1 to 4)
-   Years of going online: 2016, 2017, 2018, 2019 (all different, 1 to 4)
-   Scientists heading the projects: Dr. Alvarez, Dr. Morgan, Dr. Noble, Dr. Salinas (all different, 1 to 4)

### Constraints:
-   The facility scheduled to go online in 2019 is either the Egert Facility or the project headed by Dr. Alvarez:
    This constraint states that the project going online in 2019 is either the Egert Facility or the project headed by Dr. Alvarez. So, we can represent this as:
    Or([Year2019 == EgertFacility, Year2019 == Alvarez]).

-   The project headed by Dr. Morgan is either the Zynga Complex or the facility scheduled to go online in 2019:
    This constraint states that the project headed by Dr. Morgan is either the Zynga Complex or the project going online in 2019. So, we can represent this as:
    Or([Morgan == ZyngaComplex, Morgan == Year2019]).

-   The project headed by Dr. Salinas will go online 1 year before the Egert Facility:
    For this, we will need to add a constraint for each possible assignment of the years of going online for Dr. Salinas and the Egert Facility, such that Dr. Salinas's year of going online is 1 less than the Egert Facility's year of going online. So, the constraints will be of the form:
    y1 == Salinas and y2 == EgertFacility => y1_to_int == y2_to_int - 1, for all y1, y2 in years.

-   The project headed by Dr. Alvarez will go online sometime after the project headed by Dr. Noble:
    This constraint states that the project headed by Dr. Alvarez will go online after the project headed by Dr. Noble. So, we can represent this as:
    Alvarez_to_int > Noble_to_int.

-   The project headed by Dr. Salinas will go online sometime before the project headed by Dr. Noble:
    This constraint states that the project headed by Dr. Salinas will go online before the project headed by Dr. Noble. So, we can represent this as:
    Salinas_to_int < Noble_to_int.

-   The project headed by Dr. Morgan will go online sometime after the Bale-Hahn SSC:
    This constraint states that the project headed by Dr. Morgan will go online after the Bale-Hahn SSC. So, we can represent this as:
    Morgan_to_int > BaleHahn_to_int.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if BaleHahn == 1, and Year2016 == 1, and Alvarez == 1, then Bale-Hahn SSC is the project headed by Dr. Alvarez going online in 2016.

### Decision variables:
-   Names of the projects: Bale-Hahn SSC, Egert Facility, Lectra 4C, Zynga Complex (all different, 1 to 4)
-   Years of going online: 2016, 2017, 2018, 2019 (all different, 1 to 4)
-   Scientists heading the projects: Dr. Alvarez, Dr. Morgan, Dr. Noble, Dr. Salinas (all different, 1 to 4)

### Constraints:
-   The facility scheduled to go online in 2019 is either the Egert Facility or the project headed by Dr. Alvarez:
    This constraint states that the project going online in 2019 is either the Egert Facility or the project headed by Dr. Alvarez. So, we can represent this as:
    Or([Year2019 == EgertFacility, Year2019 == Alvarez]).

-   The project headed by Dr. Morgan is either the Zynga Complex or the facility scheduled to go online in 2019:
    This constraint states that the project headed by Dr. Morgan is either the Zynga Complex or the project going online in 2019. So, we can represent this as:
    Or([Morgan == ZyngaComplex, Morgan == Year2019]).

-   The project headed by Dr. Salinas will go online 1 year before the Egert Facility:
    For this, we will need to add a constraint for each possible assignment of the years of going online for Dr. Salinas and the Egert Facility, such that Dr. Salinas's year of going online is 1 less than the Egert Facility's year of going online. So, the constraints will be of the form:
    y1 == Salinas and y2 == EgertFacility => y1_to_int == y2_to_int - 1, for all y1, y2 in years.

-   The project headed by Dr. Alvarez will go online sometime after the project headed by Dr. Noble:
    This constraint states that the project headed by Dr. Alvarez will go online after the project headed by Dr. Noble. So, we can represent this as:
    Alvarez_to_int > Noble_to_int.

-   The project headed by Dr. Salinas will go online sometime before the project headed by Dr. Noble:
    This constraint states that the project headed by Dr. Salinas will go online before the project headed by Dr. Noble. So, we can represent this as:
    Salinas_to_int < Noble_to_int.

-   The project headed by Dr. Morgan will go online sometime after the Bale-Hahn SSC:
    This constraint states that the project headed by Dr. Morgan will go online after the Bale-Hahn SSC. So, we can represent this as:
    Morgan_to_int > BaleHahn_to_int.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of project, year, and scientist)
# e.g. if bale_hahn == 1 and year_2016 == 1 and alvarez == 1, then Bale-Hahn SSC is the project headed by Dr. Alvarez going online in 2016
bale_hahn, egert_facility, lectra_4c, zynga_complex = projects = intvar(1, 4, shape=4)
year_2016, year_2017, year_2018, year_2019 = years = intvar(1, 4, shape=4)
alvarez, morgan, noble, salinas = scientists = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
project_to_int = None  # N/A
year_to_int = {year_2016: 2016, year_2017: 2017, year_2018: 2018, year_2019: 2019}  # in years
scientist_to_int = None  # N/A


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(projects)
m += AllDifferent(years)
m += AllDifferent(scientists)

# Clue 1: The facility scheduled to go online in 2019 is either the Egert Facility or the project headed by Dr. Alvarez
m += Or([
    year_2019 == egert_facility,
    year_2019 == alvarez
])

# Clue 2: The project headed by Dr. Morgan is either the Zynga Complex or the facility scheduled to go online in 2019
m += Or([
    morgan == zynga_complex,
    morgan == year_2019
])

# Clue 3: The project headed by Dr. Salinas will go online 1 year before the Egert Facility
m += [(s == salinas) & (e == egert_facility) => year_to_int[s] == year_to_int[e] - 1
      for s in years for e in years]

# Clue 4: The project headed by Dr. Alvarez will go online sometime after the project headed by Dr. Noble
m += alvarez > noble

# Clue 5: The project headed by Dr. Salinas will go online sometime before the project headed by Dr. Noble
m += salinas < noble

# Clue 6: The project headed by Dr. Morgan will go online sometime after the Bale-Hahn SSC
m += morgan > bale_hahn

```
None
Error when trying to check solution from predicted model: invalid syntax (<string>, line 1)
False
False
Error in constraint evaluation: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
Lillian scored 6 points higher than Bessie.
The dancer who performed first scored 3 points lower than the dancer who performed ninth.
Verna scored somewhat higher than the person who danced third.
The dancer who performed seventh scored 6 points higher than the person who danced ninth.

Entities:
names: Bessie, Clara, Lillian, Verna
points: 181 points, 184 points, 187 points, 190 points
orders: first, third, seventh, ninth
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Bessie == 1, and Points181 == 1, and First == 1, then Bessie scored 181 points and performed first.

### Decision variables:
-   Names of the dancers: Bessie, Clara, Lillian, Verna (all different, 1 to 4)
-   Points scored: 181 points, 184 points, 187 points, 190 points (all different, 1 to 4)
-   Performance orders: first, third, seventh, ninth (all different, 1 to 4)

### Constraints:
-   Lillian scored 6 points higher than Bessie:
    For this, we will need to add a constraint for each possible assignment of points to Lillian and Bessie, such that Lillian's points are 6 more than Bessie's points. So, the constraints will be of the form:
    p1 == Lillian and p2 == Bessie => p1_to_int == p2_to_int + 6, for all p1, p2 in points.

-   The dancer who performed first scored 3 points lower than the dancer who performed ninth:
    For this, we will need to add a constraint for each possible assignment of points to the dancer who performed first and the dancer who performed ninth, such that the first performer's points are 3 less than the ninth performer's points. So, the constraints will be of the form:
    p1 == First and p2 == Ninth => p1_to_int == p2_to_int - 3, for all p1, p2 in points.

-   Verna scored somewhat higher than the person who danced third:
    For this, we will need to add a constraint for each possible assignment of points to Verna and the person who danced third, such that Verna's points are somewhat higher than the third dancer's points. So, the constraints will be of the form:
    p1 == Verna and p2 == Third => p1_to_int > p2_to_int, for all p1, p2 in points.

-   The dancer who performed seventh scored 6 points higher than the person who danced ninth:
    For this, we will need to add a constraint for each possible assignment of points to the dancer who performed seventh and the dancer who danced ninth, such that the seventh performer's points are 6 more than the ninth dancer's points. So, the constraints will be of the form:
    p1 == Seventh and p2 == Ninth => p1_to_int == p2_to_int + 6, for all p1, p2 in points.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Bessie == 1, and Points181 == 1, and First == 1, then Bessie scored 181 points and performed first.

### Decision variables:
-   Names of the dancers: Bessie, Clara, Lillian, Verna (all different, 1 to 4)
-   Points scored: 181 points, 184 points, 187 points, 190 points (all different, 1 to 4)
-   Performance orders: first, third, seventh, ninth (all different, 1 to 4)

### Constraints:
-   Lillian scored 6 points higher than Bessie:
    For this, we will need to add a constraint for each possible assignment of points to Lillian and Bessie, such that Lillian's points are 6 more than Bessie's points. So, the constraints will be of the form:
    p1 == Lillian and p2 == Bessie => p1_to_int == p2_to_int + 6, for all p1, p2 in points.

-   The dancer who performed first scored 3 points lower than the dancer who performed ninth:
    For this, we will need to add a constraint for each possible assignment of points to the dancer who performed first and the dancer who performed ninth, such that the first performer's points are 3 less than the ninth performer's points. So, the constraints will be of the form:
    p1 == First and p2 == Ninth => p1_to_int == p2_to_int - 3, for all p1, p2 in points.

-   Verna scored somewhat higher than the person who danced third:
    For this, we will need to add a constraint for each possible assignment of points to Verna and the person who danced third, such that Verna's points are somewhat higher than the third dancer's points. So, the constraints will be of the form:
    p1 == Verna and p2 == Third => p1_to_int > p2_to_int, for all p1, p2 in points.

-   The dancer who performed seventh scored 6 points higher than the person who danced ninth:
    For this, we will need to add a constraint for each possible assignment of points to the dancer who performed seventh and the dancer who danced ninth, such that the seventh performer's points are 6 more than the ninth dancer's points. So, the constraints will be of the form:
    p1 == Seventh and p2 == Ninth => p1_to_int == p2_to_int + 6, for all p1, p2 in points.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of dancer, points, and order)
# e.g. if bessie == 1 and points181 == 1 and first == 1, then Bessie scored 181 points and performed first
bessie, clara, lillian, verna = dancers = intvar(1, 4, shape=4)
points181, points184, points187, points190 = points = intvar(1, 4, shape=4)
first, third, seventh, ninth = orders = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
dancer_to_int = None  # N/A
points_to_int = {points181: 181, points184: 184, points187: 187, points190: 190}  # in points
order_to_int = {first: 1, third: 3, seventh: 7, ninth: 9}  # in order


# Helper functions (for formulating comparison constraints)
def scored_higher_than(var1, var2, diff):
    """
    Formulate the constraint that var1 scored diff points higher than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(points_to_int[p1] == points_to_int[p2] + diff)
            for p1 in points for p2 in points]


def scored_somewhat_higher_than(var1, var2):
    """
    Formulate the constraint that var1 scored somewhat higher than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(points_to_int[p1] > points_to_int[p2])
            for p1 in points for p2 in points]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(dancers)
m += AllDifferent(points)
m += AllDifferent(orders)

# Clue 1: Lillian scored 6 points higher than Bessie:
m += scored_higher_than(lillian, bessie, 6)

# Clue 2: The dancer who performed first scored 3 points lower than the dancer who performed ninth:
m += scored_higher_than(ninth, first, 3)

# Clue 3: Verna scored somewhat higher than the person who danced third:
m += scored_somewhat_higher_than(verna, third)

# Clue 4: The dancer who performed seventh scored 6 points higher than the person who danced ninth:
m += scored_higher_than(seventh, ninth, 6)

```
[['bessie', 'points181', 'first'], ['lillian', 'points187', 'third'], ['verna', 'points190', 'seventh'], ['clara', 'points184', 'ninth']]
True
True
True
Wrong: 0, Total: 7
---------------------------------------------------------------------------------------------

Clues:
Evan threw the orange darts.
The player who threw the violet darts scored 7 points higher than Ira.
Ira finished with 41 points.
The player who threw the white darts finished 14 points lower than Rudy.

Entities:
players: Evan, Ira, Rudy, Zachary
scores: 41, 48, 55, 62
colors: gray, orange, violet, white
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Evan == 1, and Score41 == 1, and Gray == 1, then Evan threw the gray darts and scored 41 points.

### Decision variables:
-   Names of the players: Evan, Ira, Rudy, Zachary (all different, 1 to 4)
-   Scores: 41, 48, 55, 62 (all different, 1 to 4)
-   Colors of the darts: Gray, Orange, Violet, White (all different, 1 to 4)

### Constraints:
-   Evan threw the orange darts:
    This constraint directly assigns the orange darts to Evan:
    Evan == Orange.

-   The player who threw the violet darts scored 7 points higher than Ira:
    For this, we will need to add a constraint for each possible assignment of scores to Ira and the player who threw the violet darts, such that the player who threw the violet darts scored 7 points higher than Ira. So, the constraints will be of the form:
    p1 == Ira and p2 == Violet => p2_to_int == p1_to_int + 7, for all p1, p2 in scores.

-   Ira finished with 41 points:
    This constraint directly assigns 41 points to Ira:
    Ira == Score41.

-   The player who threw the white darts finished 14 points lower than Rudy:
    For this, we will need to add a constraint for each possible assignment of scores to Rudy and the player who threw the white darts, such that the player who threw the white darts scored 14 points lower than Rudy. So, the constraints will be of the form:
    p1 == Rudy and p2 == White => p2_to_int == p1_to_int - 14, for all p1, p2 in scores.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Evan == 1, and Score41 == 1, and Gray == 1, then Evan threw the gray darts and scored 41 points.

### Decision variables:
-   Names of the players: Evan, Ira, Rudy, Zachary (all different, 1 to 4)
-   Scores: 41, 48, 55, 62 (all different, 1 to 4)
-   Colors of the darts: Gray, Orange, Violet, White (all different, 1 to 4)

### Constraints:
-   Evan threw the orange darts:
    This constraint directly assigns the orange darts to Evan:
    Evan == Orange.

-   The player who threw the violet darts scored 7 points higher than Ira:
    For this, we will need to add a constraint for each possible assignment of scores to Ira and the player who threw the violet darts, such that the player who threw the violet darts scored 7 points higher than Ira. So, the constraints will be of the form:
    p1 == Ira and p2 == Violet => p2_to_int == p1_to_int + 7, for all p1, p2 in scores.

-   Ira finished with 41 points:
    This constraint directly assigns 41 points to Ira:
    Ira == Score41.

-   The player who threw the white darts finished 14 points lower than Rudy:
    For this, we will need to add a constraint for each possible assignment of scores to Rudy and the player who threw the white darts, such that the player who threw the white darts scored 14 points lower than Rudy. So, the constraints will be of the form:
    p1 == Rudy and p2 == White => p2_to_int == p1_to_int - 14, for all p1, p2 in scores.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of player, score, and color)
# e.g. if evan == 1 and score41 == 1 and gray == 1, then Evan threw the gray darts and scored 41 points
evan, ira, rudy, zachary = players = intvar(1, 4, shape=4)
score41, score48, score55, score62 = scores = intvar(1, 4, shape=4)
gray, orange, violet, white = colors = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
player_to_int = None  # N/A
score_to_int = {score41: 41, score48: 48, score55: 55, score62: 62}  # in points
color_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def scored_higher_than(var1, var2, diff):
    """
    Formulate the constraint that var1 scored diff points higher than var2.
    """
    return [((s1 == var1) & (s2 == var2)).implies(score_to_int[s1] == score_to_int[s2] + diff)
            for s1 in scores for s2 in scores]


def scored_lower_than(var1, var2, diff):
    """
    Formulate the constraint that var1 scored diff points lower than var2.
    """
    return [((s1 == var1) & (s2 == var2)).implies(score_to_int[s1] == score_to_int[s2] - diff)
            for s1 in scores for s2 in scores]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(players)
m += AllDifferent(scores)
m += AllDifferent(colors)

# Clue 1: Evan threw the orange darts
m += evan == orange

# Clue 2: The player who threw the violet darts scored 7 points higher than Ira
m += scored_higher_than(violet, ira, 7)

# Clue 3: Ira finished with 41 points
m += ira == score41

# Clue 4: The player who threw the white darts finished 14 points lower than Rudy
m += scored_lower_than(white, rudy, 14)

```
[['rudy', 'score55', 'gray'], ['ira', 'score41', 'white'], ['evan', 'score62', 'orange'], ['zachary', 'score48', 'violet']]
True
True
True
Wrong: 0, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The 200 page project is either the book published in 2011 or the book published in 2010.
The book published in 2011 is either Orlando's project or Jan's project.
The book published in 2007 is 25 pages shorter than the book published in 2002.
The four projects are the book published in 2007, the 225 page assignment, Suzanne's project and the 175 page assignment.
Jan's assignment is 175 pages long.

Entities:
translators: Ebony, Jan, Orlando, Suzanne
pages: 150 pages, 175 pages, 200 pages, 225 pages
years: 2002, 2007, 2010, 2011
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ebony == 1, and Page150 == 1, and Year2002 == 1, then Ebony's project is the book published in 2002 with 150 pages.

### Decision variables:
-   Names of the translators: Ebony, Jan, Orlando, Suzanne (all different, 1 to 4)
-   Number of pages: Page150, Page175, Page200, Page225 (all different, 1 to 4)
-   Years of publication: Year2002, Year2007, Year2010, Year2011 (all different, 1 to 4)

### Constraints:
-   The 200-page project is either the book published in 2011 or the book published in 2010:
    This constraint states that the 200-page project is either in 2011 or 2010, but not both. So:
    Xor([Page200 == Year2011, Page200 == Year2010]).

-   The book published in 2011 is either Orlando's project or Jan's project:
    This constraint states that the book published in 2011 is either Orlando's or Jan's project, but not both. So:
    Xor([Year2011 == Orlando, Year2011 == Jan]).

-   The book published in 2007 is 25 pages shorter than the book published in 2002:
    This constraint states that the book published in 2007 is 25 pages shorter than the book published in 2002. So:
    p1 == Year2007 and p2 == Year2002 => p1_to_int == p2_to_int - 25, for all p1, p2 in pages.

-   The four projects are the book published in 2007, the 225-page assignment, Suzanne's project, and the 175-page assignment:
    This constraint states that the four projects are the book published in 2007, the 225-page assignment, Suzanne's project, and the 175-page assignment. So:
    AllDifferent([Year2007, Page225, Suzanne, Page175]).

-   Jan's assignment is 175 pages long:
    This constraint states that Jan's assignment is 175 pages long. So:
    Jan == Page175.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ebony == 1, and Page150 == 1, and Year2002 == 1, then Ebony's project is the book published in 2002 with 150 pages.

### Decision variables:
-   Names of the translators: Ebony, Jan, Orlando, Suzanne (all different, 1 to 4)
-   Number of pages: Page150, Page175, Page200, Page225 (all different, 1 to 4)
-   Years of publication: Year2002, Year2007, Year2010, Year2011 (all different, 1 to 4)

### Constraints:
-   The 200-page project is either the book published in 2011 or the book published in 2010:
    This constraint states that the 200-page project is either in 2011 or 2010, but not both. So:
    Xor([Page200 == Year2011, Page200 == Year2010]).

-   The book published in 2011 is either Orlando's project or Jan's project:
    This constraint states that the book published in 2011 is either Orlando's or Jan's project, but not both. So:
    Xor([Year2011 == Orlando, Year2011 == Jan]).

-   The book published in 2007 is 25 pages shorter than the book published in 2002:
    This constraint states that the book published in 2007 is 25 pages shorter than the book published in 2002. So:
    p1 == Year2007 and p2 == Year2002 => p1_to_int == p2_to_int - 25, for all p1, p2 in pages.

-   The four projects are the book published in 2007, the 225-page assignment, Suzanne's project, and the 175-page assignment:
    This constraint states that the four projects are the book published in 2007, the 225-page assignment, Suzanne's project, and the 175-page assignment. So:
    AllDifferent([Year2007, Page225, Suzanne, Page175]).

-   Jan's assignment is 175 pages long:
    This constraint states that Jan's assignment is 175 pages long. So:
    Jan == Page175.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of translator, pages, and year)
# e.g. if ebony == 1 and page150 == 1 and year2002 == 1, then Ebony's project is the book published in 2002 with 150 pages
ebony, jan, orlando, suzanne = translators = intvar(1, 4, shape=4)
page150, page175, page200, page225 = pages = intvar(1, 4, shape=4)
year2002, year2007, year2010, year2011 = years = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
translator_to_int = None  # N/A
page_to_int = {page150: 150, page175: 175, page200: 200, page225: 225}  # in pages
year_to_int = {year2002: 2002, year2007: 2007, year2010: 2010, year2011: 2011}  # in years


# Helper functions (for formulating comparison constraints)
def shorter_by(var1, var2, diff):
    """
    Formulate the constraint that var1 is shorter by diff pages than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(page_to_int[p1] == page_to_int[p2] - diff)
            for p1 in pages for p2 in pages]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(translators)
m += AllDifferent(pages)
m += AllDifferent(years)

# Clue 1: The 200-page project is either the book published in 2011 or the book published in 2010:
m += Xor([
    page200 == year2011,
    page200 == year2010
])

# Clue 2: The book published in 2011 is either Orlando's project or Jan's project:
m += Xor([
    year2011 == orlando,
    year2011 == jan
])

# Clue 3: The book published in 2007 is 25 pages shorter than the book published in 2002:
m += shorter_by(year2007, year2002, 25)

# Clue 4: The four projects are the book published in 2007, the 225-page assignment, Suzanne's project, and the 175-page assignment:
m += AllDifferent([year2007, page225, suzanne, page175])

# Clue 5: Jan's assignment is 175 pages long:
m += jan == page175

```
[['jan', 'page175', 'year2002'], ['orlando', 'page225', 'year2011'], ['suzanne', 'page200', 'year2010'], ['ebony', 'page150', 'year2007']]
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Mrs. Danielson's cake will be delivered 1 day before the order shaped like a sports car.
The order shaped like a turtle will be delivered 2 days before Mrs. Ingram's cake.
The cake shaped like a bowling pin is either the October 5 delivery or Mrs. Ingram's cake.
Mrs. Nolan's cake will be in the shape of a sports car.
The October 7 delivery will be in the shape of a bowling pin.

Entities:
customers: Danielson, Estrada, Ingram, Nolan
delivery dates: October 5, October 6, October 7, October 8
cake shapes: baseball glove, bowling pin, sports car, turtle
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Danielson == 1, and October5 == 1, and BaseballGlove == 1, then Mrs. Danielson's cake will be delivered on October 5 in the shape of a baseball glove.

### Decision variables:
-   Names of the customers: Danielson, Estrada, Ingram, Nolan (all different, 1 to 4)
-   Delivery dates: October 5, October 6, October 7, October 8 (all different, 1 to 4)
-   Cake shapes: BaseballGlove, BowlingPin, SportsCar, Turtle (all different, 1 to 4)

### Constraints:
-   Mrs. Danielson's cake will be delivered 1 day before the order shaped like a sports car:
    For this, we will need to add a constraint for each possible assignment of the delivery dates for Mrs. Danielson's cake and the sports car-shaped order, such that Mrs. Danielson's delivery date is 1 less than the sports car-shaped order's delivery date. So, the constraints will be of the form:
    d1 == Danielson and d2 == SportsCar => d1_to_int == d2_to_int - 1, for all d1, d2 in delivery dates.

-   The order shaped like a turtle will be delivered 2 days before Mrs. Ingram's cake:
    For this, we will need to add a constraint for each possible assignment of the delivery dates for the turtle-shaped order and Mrs. Ingram's cake, such that the turtle-shaped order's delivery date is 2 less than Mrs. Ingram's delivery date. So, the constraints will be of the form:
    d1 == Turtle and d2 == Ingram => d1_to_int == d2_to_int - 2, for all d1, d2 in delivery dates.

-   The cake shaped like a bowling pin is either the October 5 delivery or Mrs. Ingram's cake:
    This is a constraint that states that the bowling pin-shaped cake is either delivered on October 5 or is Mrs. Ingram's cake, but not both. So:
    Xor([BowlingPin == October5, BowlingPin == Ingram]).

-   Mrs. Nolan's cake will be in the shape of a sports car:
    This is a constraint that states that Mrs. Nolan's cake will be in the shape of a sports car. So:
    Nolan == SportsCar.

-   The October 7 delivery will be in the shape of a bowling pin:
    This is a constraint that states that the delivery on October 7 will be in the shape of a bowling pin. So:
    October7 == BowlingPin.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Danielson == 1, and October5 == 1, and BaseballGlove == 1, then Mrs. Danielson's cake will be delivered on October 5 in the shape of a baseball glove.

### Decision variables:
-   Names of the customers: Danielson, Estrada, Ingram, Nolan (all different, 1 to 4)
-   Delivery dates: October 5, October 6, October 7, October 8 (all different, 1 to 4)
-   Cake shapes: BaseballGlove, BowlingPin, SportsCar, Turtle (all different, 1 to 4)

### Constraints:
-   Mrs. Danielson's cake will be delivered 1 day before the order shaped like a sports car:
    For this, we will need to add a constraint for each possible assignment of the delivery dates for Mrs. Danielson's cake and the sports car-shaped order, such that Mrs. Danielson's delivery date is 1 less than the sports car-shaped order's delivery date. So, the constraints will be of the form:
    d1 == Danielson and d2 == SportsCar => d1_to_int == d2_to_int - 1, for all d1, d2 in delivery dates.

-   The order shaped like a turtle will be delivered 2 days before Mrs. Ingram's cake:
    For this, we will need to add a constraint for each possible assignment of the delivery dates for the turtle-shaped order and Mrs. Ingram's cake, such that the turtle-shaped order's delivery date is 2 less than Mrs. Ingram's delivery date. So, the constraints will be of the form:
    d1 == Turtle and d2 == Ingram => d1_to_int == d2_to_int - 2, for all d1, d2 in delivery dates.

-   The cake shaped like a bowling pin is either the October 5 delivery or Mrs. Ingram's cake:
    This is a constraint that states that the bowling pin-shaped cake is either delivered on October 5 or is Mrs. Ingram's cake, but not both. So:
    Xor([BowlingPin == October5, BowlingPin == Ingram]).

-   Mrs. Nolan's cake will be in the shape of a sports car:
    This is a constraint that states that Mrs. Nolan's cake will be in the shape of a sports car. So:
    Nolan == SportsCar.

-   The October 7 delivery will be in the shape of a bowling pin:
    This is a constraint that states that the delivery on October 7 will be in the shape of a bowling pin. So:
    October7 == BowlingPin.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of customer, delivery date, and cake shape)
# e.g. if danielson == 1 and october5 == 1 and baseball_glove == 1, then Mrs. Danielson's cake will be delivered on October 5 in the shape of a baseball glove
danielson, estrada, ingram, nolan = customers = intvar(1, 4, shape=4)
october5, october6, october7, october8 = delivery_dates = intvar(1, 4, shape=4)
baseball_glove, bowling_pin, sports_car, turtle = cake_shapes = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
customer_to_int = None  # N/A
delivery_date_to_int = {october5: 5, october6: 6, october7: 7, october8: 8}  # in days
cake_shape_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def delivered_before_than(var1, var2, diff):
    """
    Formulate the constraint that var1 is delivered diff days before var2.
    """
    return [((d1 == var1) & (d2 == var2)).implies(delivery_date_to_int[d1] == delivery_date_to_int[d2] - diff)
            for d1 in delivery_dates for d2 in delivery_dates]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(customers)
m += AllDifferent(delivery_dates)
m += AllDifferent(cake_shapes)

# Clue 1: Mrs. Danielson's cake will be delivered 1 day before the order shaped like a sports car:
m += delivered_before_than(danielson, sports_car, 1)

# Clue 2: The order shaped like a turtle will be delivered 2 days before Mrs. Ingram's cake:
m += delivered_before_than(turtle, ingram, 2)

# Clue 3: The cake shaped like a bowling pin is either the October 5 delivery or Mrs. Ingram's cake:
m += Xor([
    bowling_pin == october5,
    bowling_pin == ingram
])

# Clue 4: Mrs. Nolan's cake will be in the shape of a sports car:
m += nolan == sports_car

# Clue 5: The October 7 delivery will be in the shape of a bowling pin:
m += october7 == bowling_pin

```
[['danielson', 'october5', 'turtle'], ['nolan', 'october6', 'sports_car'], ['estrada', 'october8', 'baseball_glove'], ['ingram', 'october7', 'bowling_pin']]
True
True
False
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Of Ingram Arena and Noble Arena, one holds 150 people and the other is set up for rugby games.
The lacrosse facility holds 40 more people than Wilcox Arena.
Ingram Arena holds 230 people.
Wilcox Arena holds 80 fewer people than the soccer facility.

Entities:
arenas: Frederick, Ingram, Noble, Wilcox
capacities: 110, 150, 190, 230
sports: basketball, lacrosse, rugby, soccer
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Frederick == 1, and Capacity110 == 1, and Basketball == 1, then Frederick's arena has a capacity of 110 for basketball games.

### Decision variables:
-   Names of the arenas: Frederick, Ingram, Noble, Wilcox (all different, 1 to 4)
-   Capacities of the arenas: Capacity110, Capacity150, Capacity190, Capacity230 (all different, 1 to 4)
-   Sports played in the arenas: Basketball, Lacrosse, Rugby, Soccer (all different, 1 to 4)

### Constraints:
-   Of Ingram Arena and Noble Arena, one holds 150 people and the other is set up for rugby games:
    This constraint implies that Ingram and Noble have capacities of 150 and are set up for rugby games. So, we can add the following constraints:
    (Ingram == Capacity150 and Noble == Rugby) or (Noble == Capacity150 and Ingram == Rugby).

-   The lacrosse facility holds 40 more people than Wilcox Arena:
    This constraint implies that the lacrosse facility has a capacity 40 more than Wilcox Arena. So, we can add the following constraint:
    (Lacrosse == Wilcox + 40).

-   Ingram Arena holds 230 people:
    This constraint implies that Ingram Arena has a capacity of 230 people. So, we can add the following constraint:
    (Ingram == Capacity230).

-   Wilcox Arena holds 80 fewer people than the soccer facility:
    This constraint implies that Wilcox Arena has a capacity 80 fewer than the soccer facility. So, we can add the following constraint:
    (Wilcox == Soccer - 80).

-   All entities have different values:
    To ensure that all entities have different values, we can add the following constraint:
    AllDifferent([Frederick, Ingram, Noble, Wilcox, Capacity110, Capacity150, Capacity190, Capacity230, Basketball, Lacrosse, Rugby, Soccer]).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Frederick == 1, and Capacity110 == 1, and Basketball == 1, then Frederick's arena has a capacity of 110 for basketball games.

### Decision variables:
-   Names of the arenas: Frederick, Ingram, Noble, Wilcox (all different, 1 to 4)
-   Capacities of the arenas: Capacity110, Capacity150, Capacity190, Capacity230 (all different, 1 to 4)
-   Sports played in the arenas: Basketball, Lacrosse, Rugby, Soccer (all different, 1 to 4)

### Constraints:
-   Of Ingram Arena and Noble Arena, one holds 150 people and the other is set up for rugby games:
    This constraint implies that Ingram and Noble have capacities of 150 and are set up for rugby games. So, we can add the following constraints:
    (Ingram == Capacity150 and Noble == Rugby) or (Noble == Capacity150 and Ingram == Rugby).

-   The lacrosse facility holds 40 more people than Wilcox Arena:
    This constraint implies that the lacrosse facility has a capacity 40 more than Wilcox Arena. So, we can add the following constraint:
    (Lacrosse == Wilcox + 40).

-   Ingram Arena holds 230 people:
    This constraint implies that Ingram Arena has a capacity of 230 people. So, we can add the following constraint:
    (Ingram == Capacity230).

-   Wilcox Arena holds 80 fewer people than the soccer facility:
    This constraint implies that Wilcox Arena has a capacity 80 fewer than the soccer facility. So, we can add the following constraint:
    (Wilcox == Soccer - 80).

-   All entities have different values:
    To ensure that all entities have different values, we can add the following constraint:
    AllDifferent([Frederick, Ingram, Noble, Wilcox, Capacity110, Capacity150, Capacity190, Capacity230, Basketball, Lacrosse, Rugby, Soccer]).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of arena, capacity, and sport)
# e.g. if frederick == 1 and capacity110 == 1 and basketball == 1, then Frederick's arena has a capacity of 110 for basketball games
frederick, ingram, noble, wilcox = arenas = intvar(1, 4, shape=4)
capacity110, capacity150, capacity190, capacity230 = capacities = intvar(1, 4, shape=4)
basketball, lacrosse, rugby, soccer = sports = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
arena_to_int = None  # N/A
capacity_to_int = {capacity110: 110, capacity150: 150, capacity190: 190, capacity230: 230}  # in people
sport_to_int = None  # N/A


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(arenas)
m += AllDifferent(capacities)
m += AllDifferent(sports)

# Clue 1: Of Ingram Arena and Noble Arena, one holds 150 people and the other is set up for rugby games
m += ((ingram == capacity150) & (noble == rugby)) | ((noble == capacity150) & (ingram == rugby))

# Clue 2: The lacrosse facility holds 40 more people than Wilcox Arena
m += lacrosse == wilcox + 40

# Clue 3: Ingram Arena holds 230 people
m += ingram == capacity230

# Clue 4: Wilcox Arena holds 80 fewer people than the soccer facility
m += wilcox == soccer - 80

# All entities have different values
m += AllDifferent([frederick, ingram, noble, wilcox, capacity110, capacity150, capacity190, capacity230, basketball, lacrosse, rugby, soccer])

```
None
False
False
False
Wrong: 4, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The $35,000 structure is 15 sq ft smaller than the $29,000 home.
The Whitehead's structure sold for $29,000.
The Kirby's house is 15 sq ft smaller than the $35,000 house.
The $36,000 house is somewhat smaller than the Gillespie's structure.
Of the 110 sq ft home and the 140 sq ft home, one sold for $35,000 and the other is for the Gillespies.

Entities:
customers: Gillespie, Kirby, Pratt, Whitehead
sq footage: 95 sq ft, 110 sq ft, 125 sq ft, 140 sq ft
prices: $25,000, $29,000, $35,000, $36,000
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Gillespie == 1, and SqFt110 == 1, and Price35000 == 1, then Gillespie bought the 110 sq ft house for $35,000.

### Decision variables:
-   Names of the customers: Gillespie, Kirby, Pratt, Whitehead (all different, 1 to 4)
-   Square footage of the houses: SqFt95, SqFt110, SqFt125, SqFt140 (all different, 1 to 4)
-   Prices of the houses: Price25000, Price29000, Price35000, Price36000 (all different, 1 to 4)

### Constraints:
-   The $35,000 structure is 15 sq ft smaller than the $29,000 home:
    For this, we will need to add a constraint for each possible assignment of prices to the $35,000 and $29,000 houses, such that the $35,000 house is 15 sq ft smaller than the $29,000 house. So, the constraints will be of the form:
    p1 == Price35000 and p2 == Price29000 => s1 == s2 - 15, for all p1, p2 in prices and s1, s2 in square footage.

-   The Whitehead's structure sold for $29,000:
    This is a simple constraint that states that Whitehead bought the house for $29,000. So:
    Whitehead == Price29000.

-   The Kirby's house is 15 sq ft smaller than the $35,000 house:
    For this, we will need to add a constraint for each possible assignment of prices to the $35,000 house and Kirby's house, such that Kirby's house is 15 sq ft smaller than the $35,000 house. So, the constraints will be of the form:
    p1 == Price35000 and p2 == Kirby => s1 == s2 + 15, for all p1, p2 in prices and s1, s2 in square footage.

-   The $36,000 house is somewhat smaller than the Gillespie's structure:
    For this, we will need to add a constraint for each possible assignment of prices to the $36,000 house and Gillespie's house, such that the $36,000 house is somewhat smaller than Gillespie's house. So, the constraints will be of the form:
    p1 == Price36000 and p2 == Gillespie => s1 < s2, for all p1, p2 in prices and s1, s2 in square footage.

-   Of the 110 sq ft home and the 140 sq ft home, one sold for $35,000 and the other is for the Gillespies:
    This is a constraint that states that one of the houses with 110 sq ft and 140 sq ft was sold for $35,000 and the other was bought by the Gillespies. So:
    (SqFt110 == Price35000 and SqFt140 == Gillespie) or (SqFt110 == Gillespie and SqFt140 == Price35000).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Gillespie == 1, and SqFt110 == 1, and Price35000 == 1, then Gillespie bought the 110 sq ft house for $35,000.

### Decision variables:
-   Names of the customers: Gillespie, Kirby, Pratt, Whitehead (all different, 1 to 4)
-   Square footage of the houses: SqFt95, SqFt110, SqFt125, SqFt140 (all different, 1 to 4)
-   Prices of the houses: Price25000, Price29000, Price35000, Price36000 (all different, 1 to 4)

### Constraints:
-   The $35,000 structure is 15 sq ft smaller than the $29,000 home:
    For this, we will need to add a constraint for each possible assignment of prices to the $35,000 and $29,000 houses, such that the $35,000 house is 15 sq ft smaller than the $29,000 house. So, the constraints will be of the form:
    p1 == Price35000 and p2 == Price29000 => s1 == s2 - 15, for all p1, p2 in prices and s1, s2 in square footage.

-   The Whitehead's structure sold for $29,000:
    This is a simple constraint that states that Whitehead bought the house for $29,000. So:
    Whitehead == Price29000.

-   The Kirby's house is 15 sq ft smaller than the $35,000 house:
    For this, we will need to add a constraint for each possible assignment of prices to the $35,000 house and Kirby's house, such that Kirby's house is 15 sq ft smaller than the $35,000 house. So, the constraints will be of the form:
    p1 == Price35000 and p2 == Kirby => s1 == s2 + 15, for all p1, p2 in prices and s1, s2 in square footage.

-   The $36,000 house is somewhat smaller than the Gillespie's structure:
    For this, we will need to add a constraint for each possible assignment of prices to the $36,000 house and Gillespie's house, such that the $36,000 house is somewhat smaller than Gillespie's house. So, the constraints will be of the form:
    p1 == Price36000 and p2 == Gillespie => s1 < s2, for all p1, p2 in prices and s1, s2 in square footage.

-   Of the 110 sq ft home and the 140 sq ft home, one sold for $35,000 and the other is for the Gillespies:
    This is a constraint that states that one of the houses with 110 sq ft and 140 sq ft was sold for $35,000 and the other was bought by the Gillespies. So:
    (SqFt110 == Price35000 and SqFt140 == Gillespie) or (SqFt110 == Gillespie and SqFt140 == Price35000).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of customer, sq footage, and price)
# e.g. if gillespie == 1 and sqft110 == 1 and price35000 == 1, then Gillespie bought the 110 sq ft house for $35,000
gillespie, kirby, pratt, whitehead = customers = intvar(1, 4, shape=4)
sqft95, sqft110, sqft125, sqft140 = sq_footage = intvar(1, 4, shape=4)
price25000, price29000, price35000, price36000 = prices = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
customer_to_int = None  # N/A
sqft_to_int = {sqft95: 95, sqft110: 110, sqft125: 125, sqft140: 140}  # in sq ft
price_to_int = {price25000: 25000, price29000: 29000, price35000: 35000, price36000: 36000}  # in dollars


# Helper functions (for formulating comparison constraints)
def smaller_by(var1, var2, diff):
    """
    Formulate the constraint that var1 is diff sq ft smaller than var2.
    """
    return [((s1 == var1) & (s2 == var2)).implies(sqft_to_int[s1] == sqft_to_int[s2] - diff)
            for s1 in sq_footage for s2 in sq_footage]


def somewhat_smaller_than(var1, var2):
    """
    Formulate the constraint that var1 is somewhat smaller than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(sqft_to_int[sqft_to_int[p1]] < sqft_to_int[sqft_to_int[p2]])
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(customers)
m += AllDifferent(sq_footage)
m += AllDifferent(prices)

# Clue 1: The $35,000 structure is 15 sq ft smaller than the $29,000 home:
m += smaller_by(price35000, price29000, 15)

# Clue 2: The Whitehead's structure sold for $29,000:
m += whitehead == price29000

# Clue 3: The Kirby's house is 15 sq ft smaller than the $35,000 house:
m += smaller_by(kirby, price35000, 15)

# Clue 4: The $36,000 house is somewhat smaller than the Gillespie's structure:
m += somewhat_smaller_than(price36000, gillespie)

# Clue 5: Of the 110 sq ft home and the 140 sq ft home, one sold for $35,000 and the other is for the Gillespies:
m += ((sqft110 == price35000) & (sqft140 == gillespie)) | ((sqft110 == gillespie) & (sqft140 == price35000))

```
None
Error when trying to check solution from predicted model: name 'IV6990' is not defined
False
False
Error in constraint evaluation: name 'IV7014' is not defined
---------------------------------------------------------------------------------------------

Clues:
The Nielsen's house is 30 sq ft larger than the $35,000 structure.
The 125 sq ft home is either the Whitehead's home or the $32,250 home.
The Whitehead's house sold for $29,000.
The Ewing's home sold for $32,250.
The $29,000 house is somewhat smaller than the $32,250 structure.

Entities:
customers: Ewing, Kirby, Nielsen, Whitehead
sq footage: 95 sq ft, 110 sq ft, 125 sq ft, 140 sq ft
prices: $27,500, $29,000, $32,250, $35,000
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ewing == 1, and SqFt95 == 1, and Price27500 == 1, then Ewing's house is 95 sq ft and sold for $27,500.

### Decision variables:
-   Names of the customers: Ewing, Kirby, Nielsen, Whitehead (all different, 1 to 4)
-   Square footage of the houses: SqFt95, SqFt110, SqFt125, SqFt140 (all different, 1 to 4)
-   Prices of the houses: Price27500, Price29000, Price32250, Price35000 (all different, 1 to 4)

### Constraints:
-   The Nielsen's house is 30 sq ft larger than the $35,000 structure:
    For this, we will need to add a constraint for each possible assignment of square footage to the Nielsen's house and the $35,000 structure, such that Nielsen's house is 30 sq ft larger than the $35,000 structure. So, the constraints will be of the form:
    s1 == Nielsen and s2 == Price35000 => s1_to_int == s2_to_int + 30, for all s1, s2 in square footage.

-   The 125 sq ft home is either the Whitehead's home or the $32,250 home:
    This is a constraint that states that the 125 sq ft house is either Whitehead's or the $32,250 house, but not both. So:
    Xor([SqFt125 == Whitehead, SqFt125 == Price32250]).

-   The Whitehead's house sold for $29,000:
    This is a constraint that directly assigns the price of $29,000 to Whitehead's house:
    Whitehead == Price29000.

-   The Ewing's home sold for $32,250:
    This is a constraint that directly assigns the price of $32,250 to Ewing's house:
    Ewing == Price32250.

-   The $29,000 house is somewhat smaller than the $32,250 structure:
    For this, we will need to add a constraint for each possible assignment of square footage to the $29,000 house and the $32,250 house, such that the $29,000 house is somewhat smaller than the $32,250 house. So, the constraints will be of the form:
    s1 == Price29000 and s2 == Price32250 => s1_to_int < s2_to_int, for all s1, s2 in square footage.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Ewing == 1, and SqFt95 == 1, and Price27500 == 1, then Ewing's house is 95 sq ft and sold for $27,500.

### Decision variables:
-   Names of the customers: Ewing, Kirby, Nielsen, Whitehead (all different, 1 to 4)
-   Square footage of the houses: SqFt95, SqFt110, SqFt125, SqFt140 (all different, 1 to 4)
-   Prices of the houses: Price27500, Price29000, Price32250, Price35000 (all different, 1 to 4)

### Constraints:
-   The Nielsen's house is 30 sq ft larger than the $35,000 structure:
    For this, we will need to add a constraint for each possible assignment of square footage to the Nielsen's house and the $35,000 structure, such that Nielsen's house is 30 sq ft larger than the $35,000 structure. So, the constraints will be of the form:
    s1 == Nielsen and s2 == Price35000 => s1_to_int == s2_to_int + 30, for all s1, s2 in square footage.

-   The 125 sq ft home is either the Whitehead's home or the $32,250 home:
    This is a constraint that states that the 125 sq ft house is either Whitehead's or the $32,250 house, but not both. So:
    Xor([SqFt125 == Whitehead, SqFt125 == Price32250]).

-   The Whitehead's house sold for $29,000:
    This is a constraint that directly assigns the price of $29,000 to Whitehead's house:
    Whitehead == Price29000.

-   The Ewing's home sold for $32,250:
    This is a constraint that directly assigns the price of $32,250 to Ewing's house:
    Ewing == Price32250.

-   The $29,000 house is somewhat smaller than the $32,250 structure:
    For this, we will need to add a constraint for each possible assignment of square footage to the $29,000 house and the $32,250 house, such that the $29,000 house is somewhat smaller than the $32,250 house. So, the constraints will be of the form:
    s1 == Price29000 and s2 == Price32250 => s1_to_int < s2_to_int, for all s1, s2 in square footage.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of customer, sq footage, and price)
# e.g. if ewing == 1 and sqft95 == 1 and price27500 == 1, then Ewing's house is 95 sq ft and sold for $27,500
ewing, kirby, nielsen, whitehead = customers = intvar(1, 4, shape=4)
sqft95, sqft110, sqft125, sqft140 = sq_footage = intvar(1, 4, shape=4)
price27500, price29000, price32250, price35000 = prices = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
customer_to_int = None  # N/A
sqft_to_int = {sqft95: 95, sqft110: 110, sqft125: 125, sqft140: 140}  # in sq ft
price_to_int = {price27500: 27500, price29000: 29000, price32250: 32250, price35000: 35000}  # in dollars


# Helper functions (for formulating comparison constraints)
def larger_by(var1, var2, diff):
    """
    Formulate the constraint that var1 is larger than var2 by diff sq ft.
    """
    return [((s1 == var1) & (s2 == var2)).implies(sqft_to_int[s1] == sqft_to_int[s2] + diff)
            for s1 in sq_footage for s2 in sq_footage]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(customers)
m += AllDifferent(sq_footage)
m += AllDifferent(prices)

# Clue 1: The Nielsen's house is 30 sq ft larger than the $35,000 structure:
m += larger_by(nielsen, price35000, 30)

# Clue 2: The 125 sq ft home is either the Whitehead's home or the $32,250 home:
m += Xor([
    sqft125 == whitehead,
    sqft125 == price32250
])

# Clue 3: The Whitehead's house sold for $29,000:
m += whitehead == price29000

# Clue 4: The Ewing's home sold for $32,250:
m += ewing == price32250

# Clue 5: The $29,000 house is somewhat smaller than the $32,250 structure:
m += [((s1 == price29000) & (s2 == price32250)).implies(sqft_to_int[s1] < sqft_to_int[s2])
      for s1 in sq_footage for s2 in sq_footage]

```
[['ewing', 'sqft125', 'price32250'], ['kirby', 'sqft110', 'price35000'], ['nielsen', 'sqft140', 'price27500'], ['whitehead', 'sqft95', 'price29000']]
True
False
False
Wrong: 1, Total: 8
---------------------------------------------------------------------------------------------

Clues:
Paulette's pair was a size 7.
Estelle's pair was by Cormano.
The Manzarita footwear was either the size 4 set or Whitney's pair.
Of Lucia's pair and the Schtillet footwear, one was a size 7 and the other was a size 6.

Entities:
customers: Estelle, Lucia, Paulette, Whitney
shoe sizes: 4, 5, 6, 7
brands: Cormano, Manzarita, Schtillet, Williford
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Estelle == 1, and Size4 == 1, and Cormano == 1, then Estelle's pair is size 4 from Cormano.

### Decision variables:
-   Names of the customers: Estelle, Lucia, Paulette, Whitney (all different, 1 to 4)
-   Shoe sizes: Size4, Size5, Size6, Size7 (all different, 1 to 4)
-   Brands of the footwear: Cormano, Manzarita, Schtillet, Williford (all different, 1 to 4)

### Constraints:
-   Paulette's pair was a size 7:
    This constraint states that Paulette's shoe size is 7. So, we have:
    Paulette == Size7.

-   Estelle's pair was by Cormano:
    This constraint states that Estelle's pair is from Cormano. So, we have:
    Estelle == Cormano.

-   The Manzarita footwear was either the size 4 set or Whitney's pair:
    This constraint states that Manzarita footwear is either size 4 or Whitney's pair. So, we have:
    Manzarita == Size4 or Manzarita == Whitney.

-   Of Lucia's pair and the Schtillet footwear, one was a size 7 and the other was a size 6:
    This constraint states that one of Lucia's pair and Schtillet footwear is size 7 and the other is size 6. So, we have:
    (Lucia == Size7 and Schtillet == Size6) or (Lucia == Size6 and Schtillet == Size7).
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Estelle == 1, and Size4 == 1, and Cormano == 1, then Estelle's pair is size 4 from Cormano.

### Decision variables:
-   Names of the customers: Estelle, Lucia, Paulette, Whitney (all different, 1 to 4)
-   Shoe sizes: Size4, Size5, Size6, Size7 (all different, 1 to 4)
-   Brands of the footwear: Cormano, Manzarita, Schtillet, Williford (all different, 1 to 4)

### Constraints:
-   Paulette's pair was a size 7:
    This constraint states that Paulette's shoe size is 7. So, we have:
    Paulette == Size7.

-   Estelle's pair was by Cormano:
    This constraint states that Estelle's pair is from Cormano. So, we have:
    Estelle == Cormano.

-   The Manzarita footwear was either the size 4 set or Whitney's pair:
    This constraint states that Manzarita footwear is either size 4 or Whitney's pair. So, we have:
    Manzarita == Size4 or Manzarita == Whitney.

-   Of Lucia's pair and the Schtillet footwear, one was a size 7 and the other was a size 6:
    This constraint states that one of Lucia's pair and Schtillet footwear is size 7 and the other is size 6. So, we have:
    (Lucia == Size7 and Schtillet == Size6) or (Lucia == Size6 and Schtillet == Size7).
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of customer, shoe size, and brand)
# e.g. if estelle == 1 and size4 == 1 and cormano == 1, then Estelle's pair is size 4 from Cormano
estelle, lucia, paulette, whitney = customers = intvar(1, 4, shape=4)
size4, size5, size6, size7 = shoe_sizes = intvar(1, 4, shape=4)
cormano, manzarita, schtillet, williford = brands = intvar(1, 4, shape=4)

# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(customers)
m += AllDifferent(shoe_sizes)
m += AllDifferent(brands)

# Clue 1: Paulette's pair was a size 7
m += paulette == size7

# Clue 2: Estelle's pair was by Cormano
m += estelle == cormano

# Clue 3: The Manzarita footwear was either the size 4 set or Whitney's pair
m += (manzarita == size4) | (manzarita == whitney)

# Clue 4: Of Lucia's pair and the Schtillet footwear, one was a size 7 and the other was a size 6
m += ((lucia == size7) & (schtillet == size6)) | ((lucia == size6) & (schtillet == size7))

```
[['whitney', 'size4', 'manzarita'], ['lucia', 'size6', 'williford'], ['estelle', 'size5', 'cormano'], ['paulette', 'size7', 'schtillet']]
False
True
False
Wrong: 2, Total: 7
---------------------------------------------------------------------------------------------

Clues:
The project on the Serenity starts 1 month after Stacy's project.
Darryl's project starts 1 month after Gene's assignment.
The study beginning in April is either the study on the Liberty or the project on the Pegasus.
Lauren's project is on the Pegasus.

Entities:
students: Darryl, Gene, Lauren, Stacy
months: March, April, May, June
ships: Liberty, Osprey, Pegasus, Serenity
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Darryl == 1, and March == 1, and Liberty == 1, then Darryl's project starts in March on the Liberty.

### Decision variables:
-   Names of the students: Darryl, Gene, Lauren, Stacy (all different, 1 to 4)
-   Months of project start: March, April, May, June (all different, 1 to 4)
-   Ships for the projects: Liberty, Osprey, Pegasus, Serenity (all different, 1 to 4)

### Constraints:
-   The project on the Serenity starts 1 month after Stacy's project:
    For this, we will need to add a constraint for each possible assignment of the months of project start for Serenity and Stacy, such that Serenity's month of project start is 1 more than Stacy's month of project start. So, the constraints will be of the form:
    m1 == Serenity and m2 == Stacy => m1_to_int == m2_to_int + 1, for all m1, m2 in months of project start.

-   Darryl's project starts 1 month after Gene's assignment:
    For this, we will need to add a constraint for each possible assignment of the months of project start for Darryl and Gene, such that Darryl's month of project start is 1 more than Gene's month of project start. So, the constraints will be of the form:
    m1 == Darryl and m2 == Gene => m1_to_int == m2_to_int + 1, for all m1, m2 in months of project start.

-   The study beginning in April is either the study on the Liberty or the project on the Pegasus:
    This is a constraint that states that the project starting in April is either on the Liberty or the Pegasus, but not both. So:
    Xor([April == Liberty, April == Pegasus]).

-   Lauren's project is on the Pegasus:
    This is a constraint that directly assigns Lauren's project to the Pegasus:
    Lauren == Pegasus.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Darryl == 1, and March == 1, and Liberty == 1, then Darryl's project starts in March on the Liberty.

### Decision variables:
-   Names of the students: Darryl, Gene, Lauren, Stacy (all different, 1 to 4)
-   Months of project start: March, April, May, June (all different, 1 to 4)
-   Ships for the projects: Liberty, Osprey, Pegasus, Serenity (all different, 1 to 4)

### Constraints:
-   The project on the Serenity starts 1 month after Stacy's project:
    For this, we will need to add a constraint for each possible assignment of the months of project start for Serenity and Stacy, such that Serenity's month of project start is 1 more than Stacy's month of project start. So, the constraints will be of the form:
    m1 == Serenity and m2 == Stacy => m1_to_int == m2_to_int + 1, for all m1, m2 in months of project start.

-   Darryl's project starts 1 month after Gene's assignment:
    For this, we will need to add a constraint for each possible assignment of the months of project start for Darryl and Gene, such that Darryl's month of project start is 1 more than Gene's month of project start. So, the constraints will be of the form:
    m1 == Darryl and m2 == Gene => m1_to_int == m2_to_int + 1, for all m1, m2 in months of project start.

-   The study beginning in April is either the study on the Liberty or the project on the Pegasus:
    This is a constraint that states that the project starting in April is either on the Liberty or the Pegasus, but not both. So:
    Xor([April == Liberty, April == Pegasus]).

-   Lauren's project is on the Pegasus:
    This is a constraint that directly assigns Lauren's project to the Pegasus:
    Lauren == Pegasus.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of student, month, and ship)
# e.g. if darryl == 1 and march == 1 and liberty == 1, then Darryl's project starts in March on the Liberty
darryl, gene, lauren, stacy = students = intvar(1, 4, shape=4)
march, april, may, june = months = intvar(1, 4, shape=4)
liberty, osprey, pegasus, serenity = ships = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
student_to_int = None  # N/A
month_to_int = {march: 1, april: 2, may: 3, june: 4}  # in months
ship_to_int = {liberty: 1, osprey: 2, pegasus: 3, serenity: 4}  # in ships


# Helper functions (for formulating comparison constraints)
def starts_after_than(var1, var2):
    """
    Formulate the constraint that var1 starts after var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] == month_to_int[m2] + 1)
            for m1 in months for m2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(students)
m += AllDifferent(months)
m += AllDifferent(ships)

# Clue 1: The project on the Serenity starts 1 month after Stacy's project:
m += starts_after_than(serenity, stacy)

# Clue 2: Darryl's project starts 1 month after Gene's assignment:
m += starts_after_than(darryl, gene)

# Clue 3: The study beginning in April is either the study on the Liberty or the project on the Pegasus:
m += Xor([
    april == liberty,
    april == pegasus
])

# Clue 4: Lauren's project is on the Pegasus:
m += lauren == pegasus

```
[['darryl', 'june', 'osprey'], ['gene', 'may', 'serenity'], ['stacy', 'april', 'liberty'], ['lauren', 'march', 'pegasus']]
True
True
True
Wrong: 0, Total: 7
---------------------------------------------------------------------------------------------

Clues:
Zimmerman is from the Wolverines.
The person from the Ice Hogs scored 1 goal less than the player from the Wolverines.
Klein had 9 goals this season.
The player from the Checkers scored 1 goal more than Walls.

Entities:
players: Klein, Underwood, Walls, Zimmerman
goals: 6, 7, 8, 9
teams: Checkers, Comets, Ice Hogs, Wolverines
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Klein == 1, and Goals9 == 1, and Wolverines == 1, then Klein from the Wolverines scored 9 goals.

### Decision variables:
-   Names of the players: Klein, Underwood, Walls, Zimmerman (all different, 1 to 4)
-   Number of goals scored: Goals6, Goals7, Goals8, Goals9 (all different, 1 to 4)
-   Teams: Checkers, Comets, Ice Hogs, Wolverines (all different, 1 to 4)

### Constraints:
-   Zimmerman is from the Wolverines:
    This constraint directly assigns Zimmerman to the Wolverines:
    Zimmerman == Wolverines.

-   The person from the Ice Hogs scored 1 goal less than the player from the Wolverines:
    For this, we will need to add a constraint for each possible assignment of goals for the players from the Wolverines and the Ice Hogs, such that the Ice Hogs player's goals are 1 less than the Wolverines player's goals. So, the constraints will be of the form:
    g1 == Wolverines and g2 == Ice Hogs => g1_to_int == g2_to_int + 1, for all g1, g2 in goals.

-   Klein had 9 goals this season:
    This constraint directly assigns Klein to have scored 9 goals:
    Klein == Goals9.

-   The player from the Checkers scored 1 goal more than Walls:
    For this, we will need to add a constraint for each possible assignment of goals for the players from the Checkers and Walls, such that the Checkers player's goals are 1 more than Walls' goals. So, the constraints will be of the form:
    g1 == Checkers and g2 == Walls => g1_to_int == g2_to_int + 1, for all g1, g2 in goals.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Klein == 1, and Goals9 == 1, and Wolverines == 1, then Klein from the Wolverines scored 9 goals.

### Decision variables:
-   Names of the players: Klein, Underwood, Walls, Zimmerman (all different, 1 to 4)
-   Number of goals scored: Goals6, Goals7, Goals8, Goals9 (all different, 1 to 4)
-   Teams: Checkers, Comets, Ice Hogs, Wolverines (all different, 1 to 4)

### Constraints:
-   Zimmerman is from the Wolverines:
    This constraint directly assigns Zimmerman to the Wolverines:
    Zimmerman == Wolverines.

-   The person from the Ice Hogs scored 1 goal less than the player from the Wolverines:
    For this, we will need to add a constraint for each possible assignment of goals for the players from the Wolverines and the Ice Hogs, such that the Ice Hogs player's goals are 1 less than the Wolverines player's goals. So, the constraints will be of the form:
    g1 == Wolverines and g2 == Ice Hogs => g1_to_int == g2_to_int + 1, for all g1, g2 in goals.

-   Klein had 9 goals this season:
    This constraint directly assigns Klein to have scored 9 goals:
    Klein == Goals9.

-   The player from the Checkers scored 1 goal more than Walls:
    For this, we will need to add a constraint for each possible assignment of goals for the players from the Checkers and Walls, such that the Checkers player's goals are 1 more than Walls' goals. So, the constraints will be of the form:
    g1 == Checkers and g2 == Walls => g1_to_int == g2_to_int + 1, for all g1, g2 in goals.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of player, goals, and team)
# e.g. if klein == 1 and goals9 == 1 and wolverines == 1, then Klein from the Wolverines scored 9 goals
klein, underwood, walls, zimmerman = players = intvar(1, 4, shape=4)
goals6, goals7, goals8, goals9 = goals = intvar(1, 4, shape=4)
checkers, comets, ice_hogs, wolverines = teams = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
player_to_int = None  # N/A
goals_to_int = {goals6: 6, goals7: 7, goals8: 8, goals9: 9}  # number of goals
team_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def scored_less_than(var1, var2):
    """
    Formulate the constraint that var1 scored 1 goal less than var2.
    """
    return [((g1 == var1) & (g2 == var2)).implies(goals_to_int[g1] == goals_to_int[g2] + 1)
            for g1 in goals for g2 in goals]


def scored_more_than(var1, var2):
    """
    Formulate the constraint that var1 scored 1 goal more than var2.
    """
    return [((g1 == var1) & (g2 == var2)).implies(goals_to_int[g1] == goals_to_int[g2] + 1)
            for g1 in goals for g2 in goals]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(players)
m += AllDifferent(goals)
m += AllDifferent(teams)

# Clue 1: Zimmerman is from the Wolverines
m += zimmerman == wolverines

# Clue 2: The person from the Ice Hogs scored 1 goal less than the player from the Wolverines
m += scored_less_than(wolverines, ice_hogs)

# Clue 3: Klein had 9 goals this season
m += klein == goals9

# Clue 4: The player from the Checkers scored 1 goal more than Walls
m += scored_more_than(checkers, walls

```
None
Error when trying to check solution from predicted model: invalid syntax (<string>, line 1)
False
False
Error in constraint evaluation: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
Of the bird bought in February and the bird bought in January, one is Gladys's and the other is the macaw.
The macaw was bought 2 months before Ellen's pet.
The parakeet was bought 1 month after the finch.
Alberta's pet was bought 1 month before Gladys's pet.
The finch was bought sometime after the lovebird.

Entities:
names: Alberta, Della, Ellen, Gladys
months: January, February, March, April
birds: finch, lovebird, macaw, parakeet
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Alberta == 1, and January == 1, and Finch == 1, then Alberta bought a finch in January.

### Decision variables:
-   Names of the owners: Alberta, Della, Ellen, Gladys (all different, 1 to 4)
-   Months of purchase: January, February, March, April (all different, 1 to 4)
-   Types of birds: Finch, Lovebird, Macaw, Parakeet (all different, 1 to 4)

### Constraints:
-   Of the bird bought in February and the bird bought in January, one is Gladys's and the other is the macaw:
    This constraint states that one of the birds bought in February and January is Gladys's, and the other is the macaw. So, we need to add constraints to ensure this:
    (m1 == February and m2 == January and b1 == Gladys and b2 == Macaw) or (m1 == January and m2 == February and b1 == Macaw and b2 == Gladys), for all m1, m2 in months and b1, b2 in birds.

-   The macaw was bought 2 months before Ellen's pet:
    For this, we will need to add a constraint for each possible assignment of the months of purchase for the macaw and Ellen's pet, such that the macaw's month of purchase is 2 less than Ellen's pet's month of purchase. So, the constraints will be of the form:
    m1 == Macaw and m2 == Ellen => m1_to_int == m2_to_int - 2, for all m1, m2 in months.

-   The parakeet was bought 1 month after the finch:
    For this, we will need to add a constraint for each possible assignment of the months of purchase for the parakeet and the finch, such that the parakeet's month of purchase is 1 more than the finch's month of purchase. So, the constraints will be of the form:
    m1 == Parakeet and m2 == Finch => m1_to_int == m2_to_int + 1, for all m1, m2 in months.

-   Alberta's pet was bought 1 month before Gladys's pet:
    For this, we will need to add a constraint for each possible assignment of the months of purchase for Alberta's pet and Gladys's pet, such that Alberta's pet's month of purchase is 1 less than Gladys's pet's month of purchase. So, the constraints will be of the form:
    m1 == Alberta and m2 == Gladys => m1_to_int == m2_to_int - 1, for all m1, m2 in months.

-   The finch was bought sometime after the lovebird:
    This constraint states that the finch was bought after the lovebird, so we need to add a constraint to ensure this:
    m1 == Finch and m2 == Lovebird => m1_to_int > m2_to_int, for all m1, m2 in months.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Alberta == 1, and January == 1, and Finch == 1, then Alberta bought a finch in January.

### Decision variables:
-   Names of the owners: Alberta, Della, Ellen, Gladys (all different, 1 to 4)
-   Months of purchase: January, February, March, April (all different, 1 to 4)
-   Types of birds: Finch, Lovebird, Macaw, Parakeet (all different, 1 to 4)

### Constraints:
-   Of the bird bought in February and the bird bought in January, one is Gladys's and the other is the macaw:
    This constraint states that one of the birds bought in February and January is Gladys's, and the other is the macaw. So, we need to add constraints to ensure this:
    (m1 == February and m2 == January and b1 == Gladys and b2 == Macaw) or (m1 == January and m2 == February and b1 == Macaw and b2 == Gladys), for all m1, m2 in months and b1, b2 in birds.

-   The macaw was bought 2 months before Ellen's pet:
    For this, we will need to add a constraint for each possible assignment of the months of purchase for the macaw and Ellen's pet, such that the macaw's month of purchase is 2 less than Ellen's pet's month of purchase. So, the constraints will be of the form:
    m1 == Macaw and m2 == Ellen => m1_to_int == m2_to_int - 2, for all m1, m2 in months.

-   The parakeet was bought 1 month after the finch:
    For this, we will need to add a constraint for each possible assignment of the months of purchase for the parakeet and the finch, such that the parakeet's month of purchase is 1 more than the finch's month of purchase. So, the constraints will be of the form:
    m1 == Parakeet and m2 == Finch => m1_to_int == m2_to_int + 1, for all m1, m2 in months.

-   Alberta's pet was bought 1 month before Gladys's pet:
    For this, we will need to add a constraint for each possible assignment of the months of purchase for Alberta's pet and Gladys's pet, such that Alberta's pet's month of purchase is 1 less than Gladys's pet's month of purchase. So, the constraints will be of the form:
    m1 == Alberta and m2 == Gladys => m1_to_int == m2_to_int - 1, for all m1, m2 in months.

-   The finch was bought sometime after the lovebird:
    This constraint states that the finch was bought after the lovebird, so we need to add a constraint to ensure this:
    m1 == Finch and m2 == Lovebird => m1_to_int > m2_to_int, for all m1, m2 in months.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of owner, month, and bird)
# e.g. if alberta == 1 and january == 1 and finch == 1, then Alberta bought a finch in January
alberta, della, ellen, gladys = owners = intvar(1, 4, shape=4)
january, february, march, april = months = intvar(1, 4, shape=4)
finch, lovebird, macaw, parakeet = birds = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
owner_to_int = None  # N/A
month_to_int = {january: 1, february: 2, march: 3, april: 4}  # in months
bird_to_int = {finch: 1, lovebird: 2, macaw: 3, parakeet: 4}  # in bird types


# Helper functions (for formulating comparison constraints)
def one_is_gladys_and_macaw(var1, var2, var3, var4):
    """
    Formulate the constraint that one of var1 and var2 is Gladys's and the other is the macaw.
    """
    return [
        ((m1 == var1) & (m2 == var2) & (b1 == var3) & (b2 == var4)).implies(
            ((m1 == february) & (m2 == january) & (b1 == gladys) & (b2 == macaw)) |
            ((m1 == january) & (m2 == february) & (b1 == macaw) & (b2 == gladys))
        )
        for m1 in months for m2 in months for b1 in birds for b2 in birds
    ]


def bought_months_before(var1, var2, diff):
    """
    Formulate the constraint that var1 was bought diff months before var2.
    """
    return [((m1 == var1) & (m2 == var2)).implies(month_to_int[m1] == month_to_int[m2] - diff)
            for m1 in months for m2 in months]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(owners)
m += AllDifferent(months)
m += AllDifferent(birds)

# Clue 1: Of the bird bought in February and the bird bought in January, one is Gladys's and the other is the macaw:
m += one_is_gladys_and_macaw(february, january, gladys, macaw)

# Clue 2: The macaw was bought 2 months before Ellen's pet:
m += bought_months_before(macaw, ellen, 2)

# Clue 3: The parakeet was bought 1 month after the finch:
m += bought_months_before(parakeet, finch, 1)

# Clue 4: Alberta's pet was bought 1 month before Gladys's pet:
m += bought_months_before(alberta, gladys, 1)

# Clue 5: The finch was bought sometime after the lovebird:
m += [((m1 == finch) & (m2 == lovebird)).implies(month_to_int[m1] > month_to_int[m2])
      for m1 in months for m2 in months]

```
[['alberta', 'february', 'macaw'], ['gladys', 'march', 'parakeet'], ['della', 'january', 'lovebird'], ['ellen', 'april', 'finch']]
False
False
False
Wrong: 2, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The Tevatron LHC is either the facility scheduled to go online in 2019 or the accelerator scheduled to go online in 2016.
Of the project headed by Dr. Baldwin and the project headed by Dr. Quinn, one is the Falston LCS and the other will go online in 2017.
The project headed by Dr. Ewing will go online sometime before the Zynga Complex.
Of the project headed by Dr. Ewing and the facility scheduled to go online in 2018, one is the Egert Facility and the other is the Tevatron LHC.
The Zynga Complex is headed by Dr. Baldwin.

Entities:
names: Egert Facility, Falston LCS, Tevatron LHC, Zynga Complex
years: 2016, 2017, 2018, 2019
scientists: Dr. Baldwin, Dr. Ewing, Dr. Kirk, Dr. Quinn
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Egert Facility == 1, and Year2016 == 1, and Dr. Baldwin == 1, then the Egert Facility is the project headed by Dr. Baldwin scheduled to go online in 2016.

### Decision variables:
-   Names of the projects/facilities: Egert Facility, Falston LCS, Tevatron LHC, Zynga Complex (all different, 1 to 4)
-   Years of going online: 2016, 2017, 2018, 2019 (all different, 1 to 4)
-   Scientists heading the projects: Dr. Baldwin, Dr. Ewing, Dr. Kirk, Dr. Quinn (all different, 1 to 4)

### Constraints:
-   The Tevatron LHC is either the facility scheduled to go online in 2019 or the accelerator scheduled to go online in 2016:
    This is a constraint that states that the Tevatron LHC is either in 2019 or in 2016, but not both. So:
    Xor([Tevatron LHC == 2019, Tevatron LHC == 2016]).

-   Of the project headed by Dr. Baldwin and the project headed by Dr. Quinn, one is the Falston LCS and the other will go online in 2017:
    This is a constraint that states that one of the projects headed by Dr. Baldwin and Dr. Quinn is the Falston LCS and the other goes online in 2017. So:
    Xor([Dr. Baldwin == Falston LCS and Dr. Quinn == Year2017, Dr. Quinn == Falston LCS and Dr. Baldwin == Year2017]).

-   The project headed by Dr. Ewing will go online sometime before the Zynga Complex:
    For this, we will need to add a constraint for each possible assignment of the projects headed by Dr. Ewing and the Zynga Complex, such that Dr. Ewing's project goes online before the Zynga Complex. So, the constraints will be of the form:
    p1 == Dr. Ewing and p2 == Zynga Complex => p1_to_int < p2_to_int, for all p1, p2 in years of going online.

-   Of the project headed by Dr. Ewing and the facility scheduled to go online in 2018, one is the Egert Facility and the other is the Tevatron LHC:
    This is a constraint that states that one of the projects headed by Dr. Ewing and the facility going online in 2018 is the Egert Facility and the other is the Tevatron LHC. So:
    Xor([Dr. Ewing == Egert Facility and Year2018 == Tevatron LHC, Dr. Ewing == Tevatron LHC and Year2018 == Egert Facility]).

-   The Zynga Complex is headed by Dr. Baldwin:
    This is a constraint that states that the Zynga Complex is headed by Dr. Baldwin. So:
    Zynga Complex == Dr. Baldwin.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Egert Facility == 1, and Year2016 == 1, and Dr. Baldwin == 1, then the Egert Facility is the project headed by Dr. Baldwin scheduled to go online in 2016.

### Decision variables:
-   Names of the projects/facilities: Egert Facility, Falston LCS, Tevatron LHC, Zynga Complex (all different, 1 to 4)
-   Years of going online: 2016, 2017, 2018, 2019 (all different, 1 to 4)
-   Scientists heading the projects: Dr. Baldwin, Dr. Ewing, Dr. Kirk, Dr. Quinn (all different, 1 to 4)

### Constraints:
-   The Tevatron LHC is either the facility scheduled to go online in 2019 or the accelerator scheduled to go online in 2016:
    This is a constraint that states that the Tevatron LHC is either in 2019 or in 2016, but not both. So:
    Xor([Tevatron LHC == 2019, Tevatron LHC == 2016]).

-   Of the project headed by Dr. Baldwin and the project headed by Dr. Quinn, one is the Falston LCS and the other will go online in 2017:
    This is a constraint that states that one of the projects headed by Dr. Baldwin and Dr. Quinn is the Falston LCS and the other goes online in 2017. So:
    Xor([Dr. Baldwin == Falston LCS and Dr. Quinn == Year2017, Dr. Quinn == Falston LCS and Dr. Baldwin == Year2017]).

-   The project headed by Dr. Ewing will go online sometime before the Zynga Complex:
    For this, we will need to add a constraint for each possible assignment of the projects headed by Dr. Ewing and the Zynga Complex, such that Dr. Ewing's project goes online before the Zynga Complex. So, the constraints will be of the form:
    p1 == Dr. Ewing and p2 == Zynga Complex => p1_to_int < p2_to_int, for all p1, p2 in years of going online.

-   Of the project headed by Dr. Ewing and the facility scheduled to go online in 2018, one is the Egert Facility and the other is the Tevatron LHC:
    This is a constraint that states that one of the projects headed by Dr. Ewing and the facility going online in 2018 is the Egert Facility and the other is the Tevatron LHC. So:
    Xor([Dr. Ewing == Egert Facility and Year2018 == Tevatron LHC, Dr. Ewing == Tevatron LHC and Year2018 == Egert Facility]).

-   The Zynga Complex is headed by Dr. Baldwin:
    This is a constraint that states that the Zynga Complex is headed by Dr. Baldwin. So:
    Zynga Complex == Dr. Baldwin.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of project/facility, year, and scientist)
# e.g. if egert_facility == 1 and year2016 == 1 and dr_baldwin == 1, then the Egert Facility is the project headed by Dr. Baldwin scheduled to go online in 2016
egert_facility, falston_lcs, tevatron_lhc, zynga_complex = projects = intvar(1, 4, shape=4)
year2016, year2017, year2018, year2019 = years = intvar(1, 4, shape=4)
dr_baldwin, dr_ewing, dr_kirk, dr_quinn = scientists = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
project_to_int = None  # N/A
year_to_int = {year2016: 2016, year2017: 2017, year2018: 2018, year2019: 2019}  # in years
scientist_to_int = None  # N/A


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(projects)
m += AllDifferent(years)
m += AllDifferent(scientists)

# Clue 1: The Tevatron LHC is either the facility scheduled to go online in 2019 or the accelerator scheduled to go online in 2016
m += Xor([
    tevatron_lhc == year2019,
    tevatron_lhc == year2016
])

# Clue 2: Of the project headed by Dr. Baldwin and the project headed by Dr. Quinn, one is the Falston LCS and the other will go online in 2017
m += Xor([
    (dr_baldwin == falston_lcs) & (dr_quinn == year2017),
    (dr_quinn == falston_lcs) & (dr_baldwin == year2017)
])

# Clue 3: The project headed by Dr. Ewing will go online sometime before the Zynga Complex
m += [((p1 == dr_ewing) & (p2 == zynga_complex)).implies(year_to_int[p1] < year_to_int[p2])
      for p1 in years for p2 in years]

# Clue 4: Of the project headed by Dr. Ewing and the facility scheduled to go online in 2018, one is the Egert Facility and the other is the Tevatron LHC
m += Xor([
    (dr_ewing == egert_facility) & (year2018 == tevatron_lhc),
    (dr_ewing == tevatron_lhc) & (year2018 == egert_facility)
])

# Clue 5: The Zynga Complex is headed by Dr. Baldwin
m += zynga_complex == dr_baldwin

```
[['egert_facility', 'year2018', 'dr_kirk'], ['tevatron_lhc', 'year2016', 'dr_ewing'], ['falston_lcs', 'year2019', 'dr_quinn'], ['zynga_complex', 'year2017', 'dr_baldwin']]
True
True
True
Wrong: 0, Total: 8
---------------------------------------------------------------------------------------------

Clues:
The 2004 holiday is either the skydiving holiday or the holiday with Yvonne.
Of the kayaking holiday and the trip with Isabel, one was in 2001 and the other was in 2004.
The vacation with Andy was after the trip with Yvonne.
The holiday with Bill was 1 year after the trip with Andy.
The cycling trip was before the hunting vacation.

Entities:
friends: Andy, Bill, Isabel, Yvonne
years: 2001, 2002, 2003, 2004
activities: cycling, hunting, kayaking, skydiving
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Andy == 1, and Year2001 == 1, and Cycling == 1, then Andy went cycling in 2001.

### Decision variables:
-   Names of the friends: Andy, Bill, Isabel, Yvonne (all different, 1 to 4)
-   Years of the holidays: 2001, 2002, 2003, 2004 (all different, 1 to 4)
-   Activities of the holidays: cycling, hunting, kayaking, skydiving (all different, 1 to 4)

### Constraints:
-   The 2004 holiday is either the skydiving holiday or the holiday with Yvonne:
    This is a constraint that states that the 2004 holiday is either skydiving or with Yvonne, but not both. So:
    Xor([Year2004 == Skydiving, Year2004 == Yvonne]).

-   Of the kayaking holiday and the trip with Isabel, one was in 2001 and the other was in 2004:
    This is a constraint that states that one of the kayaking holiday and the trip with Isabel was in 2001 and the other was in 2004. So:
    (YearKayaking == Year2001 and YearIsabel == Year2004) or (YearKayaking == Year2004 and YearIsabel == Year2001).

-   The vacation with Andy was after the trip with Yvonne:
    For this, we will need to add a constraint for each possible assignment of the years of the holidays with Andy and Yvonne, such that Andy's holiday year is greater than Yvonne's holiday year. So, the constraints will be of the form:
    y1 == Andy and y2 == Yvonne => y1_to_int > y2_to_int, for all y1, y2 in years.

-   The holiday with Bill was 1 year after the trip with Andy:
    For this, we will need to add a constraint for each possible assignment of the years of the holidays with Bill and Andy, such that Bill's holiday year is 1 more than Andy's holiday year. So, the constraints will be of the form:
    y1 == Bill and y2 == Andy => y1_to_int == y2_to_int + 1, for all y1, y2 in years.

-   The cycling trip was before the hunting vacation:
    For this, we will need to add a constraint for each possible assignment of the activities of the holidays with cycling and hunting, such that the cycling holiday is before the hunting vacation. So, the constraints will be of the form:
    a1 == Cycling and a2 == Hunting => a1_to_int < a2_to_int, for all a1, a2 in activities.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Andy == 1, and Year2001 == 1, and Cycling == 1, then Andy went cycling in 2001.

### Decision variables:
-   Names of the friends: Andy, Bill, Isabel, Yvonne (all different, 1 to 4)
-   Years of the holidays: 2001, 2002, 2003, 2004 (all different, 1 to 4)
-   Activities of the holidays: cycling, hunting, kayaking, skydiving (all different, 1 to 4)

### Constraints:
-   The 2004 holiday is either the skydiving holiday or the holiday with Yvonne:
    This is a constraint that states that the 2004 holiday is either skydiving or with Yvonne, but not both. So:
    Xor([Year2004 == Skydiving, Year2004 == Yvonne]).

-   Of the kayaking holiday and the trip with Isabel, one was in 2001 and the other was in 2004:
    This is a constraint that states that one of the kayaking holiday and the trip with Isabel was in 2001 and the other was in 2004. So:
    (YearKayaking == Year2001 and YearIsabel == Year2004) or (YearKayaking == Year2004 and YearIsabel == Year2001).

-   The vacation with Andy was after the trip with Yvonne:
    For this, we will need to add a constraint for each possible assignment of the years of the holidays with Andy and Yvonne, such that Andy's holiday year is greater than Yvonne's holiday year. So, the constraints will be of the form:
    y1 == Andy and y2 == Yvonne => y1_to_int > y2_to_int, for all y1, y2 in years.

-   The holiday with Bill was 1 year after the trip with Andy:
    For this, we will need to add a constraint for each possible assignment of the years of the holidays with Bill and Andy, such that Bill's holiday year is 1 more than Andy's holiday year. So, the constraints will be of the form:
    y1 == Bill and y2 == Andy => y1_to_int == y2_to_int + 1, for all y1, y2 in years.

-   The cycling trip was before the hunting vacation:
    For this, we will need to add a constraint for each possible assignment of the activities of the holidays with cycling and hunting, such that the cycling holiday is before the hunting vacation. So, the constraints will be of the form:
    a1 == Cycling and a2 == Hunting => a1_to_int < a2_to_int, for all a1, a2 in activities.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of friend, year, and activity)
# e.g. if andy == 1 and year2001 == 1 and cycling == 1, then Andy went cycling in 2001
andy, bill, isabel, yvonne = friends = intvar(1, 4, shape=4)
year2001, year2002, year2003, year2004 = years = intvar(1, 4, shape=4)
cycling, hunting, kayaking, skydiving = activities = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
friend_to_int = None  # N/A
year_to_int = {year2001: 2001, year2002: 2002, year2003: 2003, year2004: 2004}  # in years
activity_to_int = None  # N/A


# Helper functions (for formulating comparison constraints)
def after_than(var1, var2):
    """
    Formulate the constraint that var1 is after var2.
    """
    return [((y1 == var1) & (y2 == var2)).implies(year_to_int[y1] > year_to_int[y2])
            for y1 in years for y2 in years]


def exactly_after_than(var1, var2, diff):
    """
    Formulate the constraint that var1 is exactly diff years after var2.
    """
    return [((y1 == var1) & (y2 == var2)).implies(year_to_int[y1] == year_to_int[y2] + diff)
            for y1 in years for y2 in years]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(friends)
m += AllDifferent(years)
m += AllDifferent(activities)

# Clue 1: The 2004 holiday is either the skydiving holiday or the holiday with Yvonne:
m += Xor([
    year2004 == skydiving,
    year2004 == yvonne
])

# Clue 2: Of the kayaking holiday and the trip with Isabel, one was in 2001 and the other was in 2004:
m += ((yearkayaking == year2001) & (yearisabel == year2004)) | ((yearkayaking == year2004) & (yearisabel == year2001))

# Clue 3: The vacation with Andy was after the trip with Yvonne:
m += after_than(andy, yvonne)

# Clue 4: The holiday with Bill was 1 year after the trip with Andy:
m += exactly_after_than(bill, andy, 1)

# Clue 5: The cycling trip was before the hunting vacation:
m += ((cycling == year2001) & (hunting == year2004)) | ((cycling == year2002) & (hunting == year2003)) | (
        (cycling == year2003) & (hunting == year2004))

```
None
Error when trying to check solution from predicted model: invalid syntax (<string>, line 1)
False
False
Error in constraint evaluation: invalid syntax (<string>, line 1)
---------------------------------------------------------------------------------------------

Clues:
Ginger was either the person who paid $160 or Vicki's client.
Beulah paid 10 dollars more than Yvonne's client.
Hannah paid less than Debra.
Vicki's client paid more than Debra.
Debra paid less than Pam's client.

Entities:
clients: Beulah, Debra, Ginger, Hannah
prices: $150, $160, $170, $180
masseuses: Lynda, Pam, Vicki, Yvonne
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Beulah == 1, and Price150 == 1, and Lynda == 1, then Beulah paid $150 to Lynda.

### Decision variables:
-   Names of the clients: Beulah, Debra, Ginger, Hannah (all different, 1 to 4)
-   Prices paid by the clients: Price150, Price160, Price170, Price180 (all different, 1 to 4)
-   Names of the masseuses: Lynda, Pam, Vicki, Yvonne (all different, 1 to 4)

### Constraints:
-   Ginger was either the person who paid $160 or Vicki's client:
    This is a constraint that states that Ginger is either the person who paid $160 or Vicki's client, but not both. Thus:
    Xor([Ginger == Price160, Ginger == Vicki]).

-   Beulah paid 10 dollars more than Yvonne's client:
    For this, we will need to add a constraint for each possible assignment of prices to Beulah and Yvonne's client, such that Beulah's price is 10 dollars greater than Yvonne's client's price. So, the constraints will be of the form:
    p1 == Beulah and p2 == Yvonne => p1_to_int == p2_to_int + 10, for all p1, p2 in prices.

-   Hannah paid less than Debra:
    For this, we will need to add a constraint for each possible assignment of prices to Hannah and Debra, such that Hannah's price is less than Debra's price. So, the constraints will be of the form:
    p1 == Hannah and p2 == Debra => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   Vicki's client paid more than Debra:
    For this, we will need to add a constraint for each possible assignment of prices to Vicki's client and Debra, such that Vicki's client's price is greater than Debra's price. So, the constraints will be of the form:
    p1 == Vicki and p2 == Debra => p1_to_int > p2_to_int, for all p1, p2 in prices.

-   Debra paid less than Pam's client:
    For this, we will need to add a constraint for each possible assignment of prices to Debra and Pam's client, such that Debra's price is less than Pam's client's price. So, the constraints will be of the form:
    p1 == Debra and p2 == Pam => p1_to_int < p2_to_int, for all p1, p2 in prices.
### Plan:
Each entity will be represented by a decision variable that will take a value from 1 to 4. All decision variables with the same value will correspond to the same triplet. For example, if Beulah == 1, and Price150 == 1, and Lynda == 1, then Beulah paid $150 to Lynda.

### Decision variables:
-   Names of the clients: Beulah, Debra, Ginger, Hannah (all different, 1 to 4)
-   Prices paid by the clients: Price150, Price160, Price170, Price180 (all different, 1 to 4)
-   Names of the masseuses: Lynda, Pam, Vicki, Yvonne (all different, 1 to 4)

### Constraints:
-   Ginger was either the person who paid $160 or Vicki's client:
    This is a constraint that states that Ginger is either the person who paid $160 or Vicki's client, but not both. Thus:
    Xor([Ginger == Price160, Ginger == Vicki]).

-   Beulah paid 10 dollars more than Yvonne's client:
    For this, we will need to add a constraint for each possible assignment of prices to Beulah and Yvonne's client, such that Beulah's price is 10 dollars greater than Yvonne's client's price. So, the constraints will be of the form:
    p1 == Beulah and p2 == Yvonne => p1_to_int == p2_to_int + 10, for all p1, p2 in prices.

-   Hannah paid less than Debra:
    For this, we will need to add a constraint for each possible assignment of prices to Hannah and Debra, such that Hannah's price is less than Debra's price. So, the constraints will be of the form:
    p1 == Hannah and p2 == Debra => p1_to_int < p2_to_int, for all p1, p2 in prices.

-   Vicki's client paid more than Debra:
    For this, we will need to add a constraint for each possible assignment of prices to Vicki's client and Debra, such that Vicki's client's price is greater than Debra's price. So, the constraints will be of the form:
    p1 == Vicki and p2 == Debra => p1_to_int > p2_to_int, for all p1, p2 in prices.

-   Debra paid less than Pam's client:
    For this, we will need to add a constraint for each possible assignment of prices to Debra and Pam's client, such that Debra's price is less than Pam's client's price. So, the constraints will be of the form:
    p1 == Debra and p2 == Pam => p1_to_int < p2_to_int, for all p1, p2 in prices.
```python
from cpmpy import *

# Decision variables
# (variables with the same value will correspond to the same triplet of client, masseuse, and price)
# e.g. if beulah == 1 and price150 == 1 and lynda == 1, then Beulah paid $150 to Lynda
beulah, debra, ginger, hannah = clients = intvar(1, 4, shape=4)
price150, price160, price170, price180 = prices = intvar(1, 4, shape=4)
lynda, pam, vicki, yvonne = masseuses = intvar(1, 4, shape=4)

# Integer representation of the decision variables (for comparison constraints)
client_to_int = None  # N/A
masseuse_to_int = None  # N/A
price_to_int = {price150: 150, price160: 160, price170: 170, price180: 180}  # in dollars


# Helper functions (for formulating comparison constraints)
def paid_exactly_more_than(var1, var2, diff):
    """
    Formulate the constraint that var1 paid exactly $diff more than var2.
    """
    return [((p1 == var1) & (p2 == var2)).implies(price_to_int[p1] == price_to_int[p2] + diff)
            for p1 in prices for p2 in prices]


# Constraints
m = Model()

# All entities are different per category
m += AllDifferent(clients)
m += AllDifferent(prices)
m += AllDifferent(masseuses)

# Clue 1: Ginger was either the person who paid $160 or Vicki's client:
m += Xor([
    ginger == price160,
    ginger == vicki
])

# Clue 2: Beulah paid 10 dollars more than Yvonne's client:
m += paid_exactly_more_than(beulah, yvonne, 10)

# Clue 3: Hannah paid less than Debra:
m += paid_exactly_more_than(hannah, debra, -1)

# Clue 4: Vicki's client paid more than Debra:
m += paid_exactly_more_than(vicki, debra, 1)

# Clue 5: Debra paid less than Pam's client:
m += paid_exactly_more_than(debra, pam, -1)

```
None
False
False
False
Wrong: 3, Total: 8
---------------------------------------------------------------------------------------------

